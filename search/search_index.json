{"config":{"lang":["es"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"material/S1/000/","title":"Clase 0: Introducci\u00f3n a Python","text":""},{"location":"material/S1/000/#que-es-python","title":"\u00bfQu\u00e9 es Python?","text":"<p>Python es un lenguaje de programaci\u00f3n ampliamente utilizado. Fue creado por Guido van Rossum y lanzado en 1991.</p> <p>Se emplea en diversas \u00e1reas, entre ellas:</p> <ul> <li>Desarrollo web (en el lado del servidor).</li> <li>Desarrollo de software.</li> <li>Matem\u00e1tica y an\u00e1lisis de datos.</li> <li>Automatizaci\u00f3n de tareas y scripting para sistemas.</li> </ul>"},{"location":"material/S1/000/#que-permite-hacer-python","title":"\u00bfQu\u00e9 permite hacer Python?","text":"<ul> <li>Es utilizado para manejar grandes vol\u00famenes de datos y realizar c\u00e1lculos matem\u00e1ticos avanzados.</li> <li>Permite desarrollar aplicaciones web en servidores.</li> <li>Facilita la automatizaci\u00f3n de tareas y la integraci\u00f3n con otros programas.</li> <li>Proporciona herramientas para conectarse a bases de datos, as\u00ed como para leer y modificar archivos.</li> <li>Se adapta tanto a la creaci\u00f3n r\u00e1pida de prototipos como al desarrollo de software listo para producci\u00f3n.</li> </ul>"},{"location":"material/S1/000/#por-que-elegir-python","title":"\u00bfPor qu\u00e9 elegir Python?","text":"<ul> <li>Es multiplataforma, incluyendo Windows, Mac, Linux y Raspberry Pi.</li> <li>Posee una sintaxis clara y sencilla, con una estructura similar al idioma ingl\u00e9s.</li> <li>Requiere menos l\u00edneas de c\u00f3digo en comparaci\u00f3n con otros lenguajes de programaci\u00f3n.</li> <li>Funciona mediante un int\u00e9rprete, lo que permite ejecutar el c\u00f3digo inmediatamente despu\u00e9s de escribirlo. Esto agiliza el proceso de desarrollo.</li> <li>Puede ser utilizado en distintos paradigmas de programaci\u00f3n: procedural, orientado a objetos y funcional.</li> </ul>"},{"location":"material/S1/000/#aspectos-relevantes","title":"Aspectos relevantes","text":"<ul> <li>La versi\u00f3n m\u00e1s reciente y recomendada es Python 3, que ser\u00e1 la utilizada en este curso.</li> <li>En este curso, el c\u00f3digo se escribir\u00e1 en Visual Studio Code, que es un editor de texto ligero con la posibilidad de integrar extensiones para hacerlo m\u00e1s robusto.</li> <li>Existen entornos de desarrollo integrados (IDE), que tambi\u00e9n son populares. Entre ellos destaca PyCharm de JetBrains.</li> </ul>"},{"location":"material/S1/000/#sintaxis-de-python-en-comparacion-con-otros-lenguajes","title":"Sintaxis de Python en comparaci\u00f3n con otros lenguajes","text":"<ul> <li>Python ha sido dise\u00f1ado para ser legible y presenta una sintaxis influenciada por el idioma ingl\u00e9s y la notaci\u00f3n matem\u00e1tica.</li> <li>A diferencia de otros lenguajes que utilizan punto y coma (<code>;</code>) o par\u00e9ntesis, Python emplea saltos de l\u00ednea para finalizar instrucciones.</li> <li>En lugar de llaves <code>{}</code> como en otros lenguajes, Python utiliza la indentaci\u00f3n (espacios en blanco) para definir el alcance de estructuras como bucles, funciones y clases.</li> </ul> <p>Importancia de indentaci\u00f3n</p> <p>Los saltos de l\u00ednea y la indentaci\u00f3n para separar l\u00edneas y bloques de c\u00f3digo, son fundamentales pues si no se usan correctamente, el programa no va a poder ser ejecutado.</p>"},{"location":"material/S1/001/","title":"Clase 1: Conceptos b\u00e1sicos de Python","text":""},{"location":"material/S1/001/#1-indentacion-en-python","title":"1. Indentaci\u00f3n en Python","text":"<p>Python utiliza la indentaci\u00f3n para definir bloques de c\u00f3digo, en lugar de llaves <code>{}</code> como en otros lenguajes. La indentaci\u00f3n se refiere a los espacios o tabulaciones (tabs) que se a\u00f1aden al inicio de una l\u00ednea para indicar su nivel de jerarqu\u00eda dentro del c\u00f3digo.</p>"},{"location":"material/S1/001/#reglas-clave-de-la-indentacion-en-python","title":"Reglas clave de la indentaci\u00f3n en Python","text":"<ul> <li>Todos los bloques de c\u00f3digo dentro de estructuras como <code>if</code>, <code>for</code>, <code>while</code>, <code>def</code> y <code>class</code> deben estar indentados uniformemente.</li> <li>Esto se realiza para indicar que un bloque de c\u00f3digo pertenece a una jerarqu\u00eda espec\u00edfica.</li> <li>Se recomienda utilizar 4 espacios por nivel de indentaci\u00f3n.</li> <li>Una indentaci\u00f3n incorrecta generar\u00e1 un error de sintaxis (<code>IndentationError</code>).</li> </ul>"},{"location":"material/S1/001/#ejemplo-de-indentacion-correcta","title":"Ejemplo de indentaci\u00f3n correcta","text":"<pre><code>def saludar():\n    nombre = \"Ana\"\n    print(\"Hola,\", nombre)  # La l\u00ednea est\u00e1 indentada correctamente\n\nsaludar()\n</code></pre>"},{"location":"material/S1/001/#ejemplo-de-indentacion-incorrecta","title":"Ejemplo de indentaci\u00f3n incorrecta","text":"<p>El siguiente c\u00f3digo generar\u00e1 un error porque la l\u00ednea <code>nombre = \"Ana\"</code> no est\u00e1 correctamente indentada:</p> <pre><code>def saludar():\nnombre = \"Ana\" # Parece que la funci\u00f3n saludar() est\u00e1 vac\u00eda\n    print(\"Hola,\", nombre) # Esta indentaci\u00f3n no tiene sentido porque la l\u00ednea anterior no posee\n\nsaludar()\n</code></pre> <p>Salida esperada:</p> <pre><code>IndentationError: expected an indented block\n</code></pre>"},{"location":"material/S1/001/#2-declaracion-y-definicion-de-variables","title":"2. Declaraci\u00f3n y Definici\u00f3n de Variables","text":"<p>Una variable es un espacio de memoria donde se almacena un valor. En Python, no es necesario declarar expl\u00edcitamente el tipo de dato de una variable, puesto que el lenguaje usa tipado din\u00e1mico (asigna autom\u00e1ticamente el tipo de dato).</p>"},{"location":"material/S1/001/#reglas-para-declarar-variables","title":"Reglas para declarar variables","text":"<ul> <li>Los nombres de las variables no pueden comenzar con un n\u00famero.</li> <li>S\u00f3lo pueden contener letras, n\u00fameros y guiones bajos (<code>_</code>)</li> <li>NO pueden contener espacios ni caracteres especiales.</li> <li>Convenciones para nombrar variables:</li> <li><code>snake_case</code></li> <li><code>camelCase</code></li> <li><code>PascalCase</code></li> <li>Distinci\u00f3n entre may\u00fasculas y min\u00fasculas (<code>edad</code> y <code>Edad</code> son variables diferentes).</li> <li>Se pueden definir m\u00faltiples variables en una sola l\u00ednea.</li> </ul>"},{"location":"material/S1/001/#ejemplo-de-declaracion-y-asignacion-de-variables","title":"Ejemplo de declaraci\u00f3n y asignaci\u00f3n de variables","text":"<pre><code>nombre = \"Carlos\"  # Variable tipo string\nedad = 25  # Variable tipo entero\naltura = 1.75  # Variable tipo flotante\nes_estudiante = True  # Variable tipo booleano\n\nprint(nombre, edad, altura, es_estudiante)\n</code></pre> <p>Salida esperada:</p> <pre><code>Carlos 25 1.75 True\n</code></pre>"},{"location":"material/S1/001/#ejemplo-de-asignacion-multiple","title":"Ejemplo de asignaci\u00f3n m\u00faltiple","text":"<p>Python permite asignar valores a varias variables en una sola l\u00ednea:</p> <pre><code>x, y, z = 10, 20, 30\nprint(x, y, z)  # Salida: 10 20 30\n</code></pre> <p>Tambi\u00e9n es posible asignar el mismo valor a varias variables a la vez:</p> <pre><code>a = b = c = \"Python\"\nprint(a, b, c)  # Salida: Python Python Python\n</code></pre>"},{"location":"material/S1/001/#variables-constantes-en-python","title":"Variables constantes en Python","text":"<p>No existe una palabra clave <code>const</code> como en otros lenguajes de programaci\u00f3n, pero por convenci\u00f3n, se utilizan nombres en may\u00fasculas para representar constantes:</p> <pre><code>PI = 3.1416\nURL_BASE = \"https://ejemplo.com\"\n</code></pre> <p>Aunque estos valores pueden cambiarse, se espera que permanezcan constantes durante la ejecuci\u00f3n del programa. Sirven para indicarle al programador que no modifique estas variables.</p>"},{"location":"material/S1/001/#3-comentarios-en-python","title":"3. Comentarios en Python","text":"<p>Los comentarios son l\u00edneas de texto dentro del c\u00f3digo que no afectan su ejecuci\u00f3n. Se utilizan para mejorar la legibilidad del c\u00f3digo y explicar su funcionamiento.</p>"},{"location":"material/S1/001/#comentarios-de-una-linea","title":"Comentarios de una l\u00ednea","text":"<p>Se crean utilizando el s\u00edmbolo <code>#</code>. Todo lo que se escriba despu\u00e9s en la misma l\u00ednea ser\u00e1 ignorado por el int\u00e9rprete.</p> <pre><code># Esto es un comentario de una l\u00ednea\nnombre = \"Luis\"  # Se puede colocar un comentario al final de una l\u00ednea de c\u00f3digo\n</code></pre>"},{"location":"material/S1/001/#comentarios-multilinea","title":"Comentarios multil\u00ednea","text":"<p>Python no tiene un s\u00edmbolo espec\u00edfico para comentarios multil\u00ednea, pero se puede lograr utilizando comillas triples (<code>\"\"\" \"\"\"</code> o <code>''' '''</code>). Aunque en realidad se usan para docstrings (documentaci\u00f3n de funciones y clases), el int\u00e9rprete ignora su contenido cuando no est\u00e1n asignados a ninguna variable.</p> <pre><code>\"\"\"\nEste es un comentario de m\u00faltiples l\u00edneas.\nSe usa para documentar el c\u00f3digo.\n\"\"\"\nprint(\"Hola, mundo\")  # El comentario anterior es ignorado\n</code></pre> <p>Otra opci\u00f3n es utilizar <code>#</code> en varias l\u00edneas consecutivas:</p> <pre><code># Este es un comentario largo\n# que ocupa varias l\u00edneas\n# y explica el c\u00f3digo en detalle.\n</code></pre>"},{"location":"material/S1/001/#4-tipos-de-datos-en-python","title":"4. Tipos de Datos en Python","text":"<p>Python maneja diferentes tipos de datos, organizados en categor\u00edas.</p> Categor\u00eda Tipo Descripci\u00f3n Ejemplo Type casting Texto <code>str</code> Cadenas de caracteres <code>\"Hola, Python!\"</code> <code>str(valor)</code> Num\u00e9ricos <code>int</code> N\u00fameros enteros <code>5, -3, 100</code> <code>int(valor)</code> <code>float</code> N\u00fameros decimales <code>3.14, -0.5, 2.71</code> <code>float(valor)</code> <code>complex</code> N\u00fameros complejos <code>3+5j, -1j</code> <code>complex(valor)</code> Secuencias <code>list</code> Lista de valores modificables <code>[1, 2, 3]</code> <code>list(valor)</code> <code>tuple</code> Lista de valores inmutables <code>(10, 20, 30)</code> <code>tuple(valor)</code> <code>range</code> Rango de n\u00fameros <code>range(5)</code> = (0,1,2,3,4) <code>range(inicio, fin, paso)</code> Mapas <code>dict</code> Almacena pares clave-valor <code>{\"nombre\": \"Ana\", \"edad\": 17}</code> <code>dict(valor)</code> Conjuntos <code>set</code> Conjunto de valores \u00fanicos <code>{1, 2, 3}</code> <code>set(valor)</code> <code>frozenset</code> Conjunto inmutable <code>frozenset([1, 2, 3])</code> <code>frozenset(valor)</code> Booleanos <code>bool</code> Valores l\u00f3gicos <code>True</code> o <code>False</code> <code>True, False</code> <code>bool(valor)</code> Binarios <code>bytes</code> Secuencia de bytes inmutable <code>b\"Hola\"</code> <code>bytes(valor)</code> <code>bytearray</code> Secuencia de bytes modificable <code>bytearray(5)</code> <code>bytearray(valor)</code> <code>memoryview</code> Vista de memoria de un objeto binario <code>memoryview(b\"Hola\")</code> <code>memoryview(valor)</code> Nulo <code>NoneType</code> Representa ausencia de valor <code>None</code> No aplica <p>A continuaci\u00f3n se muestra la definici\u00f3n de variables de cada uno de los tipos de datos anteriores:</p> <pre><code>texto = \"Hola, mundo\"  # str\nnumero = 42  # int\ndecimal = 3.14  # float\ncomplejo = 2 + 3j  # complex\nlista = [1, 2, 3]  # list\ntupla = (10, 20, 30)  # tuple\nrango = range(5)  # range\ndiccionario = {\"nombre\": \"Luis\", \"edad\": 22}  # dict\nconjunto = {1, 2, 3}  # set\nconjunto_fijo = frozenset([1, 2, 3])  # frozenset\nbooleano = True  # bool\nbinario = b\"Hola\"  # bytes\nmutable_binario = bytearray(5)  # bytearray\nvista_memoria = memoryview(b\"Hola\")  # memoryview\nnulo = None  # NoneType\n\nprint(texto, numero, decimal, complejo, lista, tupla, rango, diccionario, conjunto, conjunto_fijo, booleano, binario, mutable_binario, vista_memoria, nulo)\n</code></pre>"},{"location":"material/S1/001/#funcion-type","title":"Funci\u00f3n <code>type</code>","text":"<p>Esta funci\u00f3n sirve para determinar el tipo de dato de una variable que se ingrese como par\u00e1metro.</p> <pre><code>var = \"Hola mundo!\"\ntipo = type(var)\nprint(tipo)\n</code></pre> <p>Salida esperada</p> <pre><code>&lt;class 'str'&gt;\n</code></pre>"},{"location":"material/S1/001/#5-funciones-de-entrada-y-salida-io-en-python","title":"5. Funciones de Entrada y Salida (I/O) en Python","text":""},{"location":"material/S1/001/#print-mostrar-informacion-en-pantalla","title":"<code>print()</code>: Mostrar informaci\u00f3n en pantalla","text":"<p>La funci\u00f3n <code>print()</code> permite imprimir valores en la terminal.</p> <pre><code>nombre = \"Ana\"\nprint(\"Hola,\", nombre)\n</code></pre> <p>Se pueden imprimir m\u00faltiples valores separados por comas:</p> <pre><code>print(\"Nombre:\", \"Juan\", \"Edad:\", 20)\n</code></pre> <p>Tambi\u00e9n se puede cambiar el separador (<code>sep</code>) o el final de l\u00ednea (<code>end</code>):</p> <pre><code>print(\"Python\", \"es\", \"genial\", sep=\"-\")  # Salida: Python-es-genial\nprint(\"Hola\", end=\" \")\nprint(\"Mundo\")  # Salida: Hola Mundo\n</code></pre> <p>Valores predeterminados en <code>print()</code></p> <p>De forma predeterminada, <code>sep=\" \"</code> y <code>end=\"\\n\"</code>.</p>"},{"location":"material/S1/001/#input-leer-informacion-del-usuario","title":"<code>input()</code>: Leer informaci\u00f3n del usuario","text":"<p>La funci\u00f3n <code>input()</code> permite recibir informaci\u00f3n desde el teclado y siempre devuelve un string.</p> <pre><code>nombre = input(\"\u00bfCu\u00e1l es tu nombre? \")\nprint(\"Hola,\", nombre)\n</code></pre> <p>Si se necesita un n\u00famero, debe convertirse expl\u00edcitamente:</p> <pre><code>edad = int(input(\"Ingresa tu edad: \"))  # Conversi\u00f3n a entero\nprecio = float(input(\"Ingresa un precio: \"))  # Conversi\u00f3n a flotante\n\nprint(\"Edad:\", edad, \"Precio:\", precio)\n</code></pre>"},{"location":"material/S1/001/#6-concatenacion-de-strings","title":"6. Concatenaci\u00f3n de Strings","text":"<p>La concatenaci\u00f3n de strings es la uni\u00f3n de dos o m\u00e1s cadenas de texto.</p>"},{"location":"material/S1/001/#metodos-de-concatenacion","title":"M\u00e9todos de concatenaci\u00f3n","text":""},{"location":"material/S1/001/#uso-del-operador","title":"Uso del operador <code>+</code>","text":"<p>Se puede usar <code>+</code> para unir dos cadenas de texto. Se debe agregar un espacio manualmente si es necesario.</p> <pre><code>nombre = \"Juan\"\napellido = \"P\u00e9rez\"\nnombre_completo = nombre + \" \" + apellido\nprint(\"Tu nombre completo es: \" + nombre_completo)\n</code></pre>"},{"location":"material/S1/001/#uso-de-f-strings-python-36-en-adelante","title":"Uso de <code>f-strings</code> (Python 3.6 en adelante)","text":"<p>Permite insertar variables dentro de un string de manera m\u00e1s sencilla.</p> <pre><code>nombre = \"Ana\"\nedad = 17\nstring_completo = f\"Hola, {nombre}, tienes {edad} a\u00f1os.\"\nprint(string_completo)\n</code></pre>"},{"location":"material/S1/002/","title":"Clase 2: Operadores, strings y estructura de control <code>if-elif-else</code>","text":""},{"location":"material/S1/002/#1-operadores-en-python","title":"1. Operadores en Python","text":"<p>Los operadores en Python permiten realizar diversas operaciones, desde c\u00e1lculos matem\u00e1ticos hasta comparaciones l\u00f3gicas. Son fundamentales para la programaci\u00f3n, puesto que permiten manipular datos de manera efectiva.</p>"},{"location":"material/S1/002/#operadores-matematicos","title":"Operadores Matem\u00e1ticos","text":"<p>Los operadores matem\u00e1ticos permiten realizar c\u00e1lculos entre valores num\u00e9ricos. Python maneja autom\u00e1ticamente los tipos de datos adecuados en las operaciones.</p> Operador Descripci\u00f3n Ejemplo (<code>a = 10, b = 3</code>) Resultado <code>+</code> Suma <code>a + b</code> <code>13</code> <code>-</code> Resta <code>a - b</code> <code>7</code> <code>*</code> Multiplicaci\u00f3n <code>a * b</code> <code>30</code> <code>/</code> Divisi\u00f3n (decimal) <code>a / b</code> <code>3.3333</code> <code>//</code> Divisi\u00f3n entera <code>a // b</code> <code>3</code> <code>%</code> M\u00f3dulo (residuo) <code>a % b</code> <code>1</code> <code>**</code> Potencia <code>a ** b</code> <code>1000</code> <p>Python respeta la jerarqu\u00eda de operaciones matem\u00e1ticas. Primero ejecuta las potencias, luego multiplicaciones y divisiones, y por \u00faltimo sumas y restas.</p> <p>Ejemplo de las operaciones matem\u00e1ticas:</p> <pre><code>a = 10\nb = 3\n\nprint(a + b)   # Suma: 13\nprint(a - b)   # Resta: 7\nprint(a * b)   # Multiplicaci\u00f3n: 30\nprint(a / b)   # Divisi\u00f3n: 3.3333\nprint(a // b)  # Divisi\u00f3n entera: 3\nprint(a % b)   # M\u00f3dulo: 1\nprint(a ** b)  # Potencia: 1000\n</code></pre>"},{"location":"material/S1/002/#operadores-de-asignacion","title":"Operadores de Asignaci\u00f3n","text":"<p>Los operadores de asignaci\u00f3n permiten modificar el valor de una variable de manera eficiente. En lugar de escribir expresiones completas como <code>x = x + 5</code>, se puede utilizar <code>x += 5</code> para reducir la complejidad del c\u00f3digo.</p> Operador Descripci\u00f3n Ejemplo (<code>a = 5</code>) Equivalente <code>=</code> Asigna un valor <code>a = 5</code> <code>a = 5</code> <code>+=</code> Suma y asigna <code>a += 3</code> <code>a = a + 3</code> <code>-=</code> Resta y asigna <code>a -= 2</code> <code>a = a - 2</code> <code>*=</code> Multiplica y asigna <code>a *= 4</code> <code>a = a * 4</code> <code>/=</code> Divide y asigna <code>a /= 2</code> <code>a = a / 2</code> <code>//=</code> Divisi\u00f3n entera y asigna <code>a //= 3</code> <code>a = a // 3</code> <code>%=</code> M\u00f3dulo y asigna <code>a %= 2</code> <code>a = a % 2</code> <code>**=</code> Exponente y asigna <code>a **= 3</code> <code>a = a ** 3</code>"},{"location":"material/S1/002/#operadores-relacionales","title":"Operadores Relacionales","text":"<p>Estos operadores permiten comparar valores y devuelven un resultado booleano (<code>True</code> o <code>False</code>).</p> Operador Descripci\u00f3n Ejemplo (<code>a = 10, b = 3</code>) Resultado <code>==</code> Igualdad <code>a == b</code> <code>False</code> <code>!=</code> Diferente <code>a != b</code> <code>True</code> <code>&gt;</code> Mayor que <code>a &gt; b</code> <code>True</code> <code>&lt;</code> Menor que <code>a &lt; b</code> <code>False</code> <code>&gt;=</code> Mayor o igual que <code>a &gt;= b</code> <code>True</code> <code>&lt;=</code> Menor o igual que <code>a &lt;= b</code> <code>False</code>"},{"location":"material/S1/002/#operadores-logicos","title":"Operadores L\u00f3gicos","text":"<p>Se usan para combinar expresiones booleanas.</p> Operador Descripci\u00f3n Ejemplo (<code>a = True, b = False</code>) Resultado <code>and</code> <code>True</code> si ambas son <code>True</code> <code>a and b</code> <code>False</code> <code>or</code> <code>True</code> si al menos una es <code>True</code> <code>a or b</code> <code>True</code> <code>not</code> Invierte el valor <code>not a</code> <code>False</code>"},{"location":"material/S1/002/#2-uso-de-strings-en-python","title":"2. Uso de Strings en Python","text":"<p>Los strings en Python son secuencias de caracteres y ofrecen una gran variedad de m\u00e9todos para manipularlos. A continuaci\u00f3n, se explican algunas de sus principales funcionalidades.</p>"},{"location":"material/S1/002/#metodos-de-strings","title":"M\u00e9todos de Strings","text":"<p>Python proporciona diversos m\u00e9todos para trabajar con cadenas de texto. Se presenta una tabla con los m\u00e9todos m\u00e1s comunes:</p> M\u00e9todo Descripci\u00f3n <code>capitalize()</code> Convierte el primer car\u00e1cter en may\u00fascula. <code>center(width)</code> Centra el string dentro de un ancho especificado. <code>count(substring)</code> Devuelve el n\u00famero de veces que aparece un valor especificado. <code>encode()</code> Codifica el string a una versi\u00f3n espec\u00edfica. <code>endswith(suffix)</code> Devuelve <code>True</code> si la cadena termina con el valor especificado. <code>expandtabs(size)</code> Establece el tama\u00f1o del tabulador en el string. <code>find(substring)</code> Busca una subcadena y devuelve la posici\u00f3n donde se encontr\u00f3 por primera vez. <code>format()</code> Formatea valores dentro de un string. <code>index(substring)</code> Similar a <code>find()</code>, pero genera error si no se encuentra. <code>isalnum()</code> Devuelve <code>True</code> si todos los caracteres son alfanum\u00e9ricos. <code>isalpha()</code> Devuelve <code>True</code> si todos los caracteres son letras. <code>isdigit()</code> Devuelve <code>True</code> si todos los caracteres son n\u00fameros. <code>islower()</code> Devuelve <code>True</code> si todos los caracteres est\u00e1n en min\u00fascula. <code>isnumeric()</code> Devuelve <code>True</code> si el string solo contiene n\u00fameros. <code>isspace()</code> Devuelve <code>True</code> si todos los caracteres son espacios en blanco. <code>join(iterable)</code> Une elementos de un iterable con la cadena como separador. <code>lower()</code> Convierte el string a min\u00fasculas (menos agresivo que <code>casefold()</code>). <code>replace(old, new)</code> Reemplaza un valor por otro dentro de la cadena. <code>split(separator)</code> Divide la cadena en una lista, usando un separador espec\u00edfico. <code>startswith(prefix)</code> Devuelve <code>True</code> si el string comienza con el valor especificado. <code>strip()</code> Elimina espacios en blanco al inicio y al final de la cadena. <code>upper()</code> Convierte todos los caracteres a may\u00fasculas. <code>zfill(width)</code> Rellena la cadena con ceros a la izquierda hasta el ancho especificado. <p>La sintaxis para ejecutar un m\u00e9todo sobre un string es la siguiente:</p> <pre><code>[string].[m\u00e9todo]([par\u00e1metros])\n</code></pre> <p>Ejemplo de uso de m\u00e9todos comunes:</p> <pre><code>texto = \"hola mundo\"\nprint(texto.capitalize())  # Hola mundo\nprint(texto.upper())       # HOLA MUNDO\nprint(texto.replace(\"mundo\", \"Python\"))  # hola Python\n</code></pre>"},{"location":"material/S1/002/#slicing-de-strings","title":"Slicing de Strings","text":"<p>El slicing permite extraer partes espec\u00edficas de un string mediante \u00edndices.</p> <p>Es importante mencionar que los strings (cadenas de caracteres) permiten acceder a cada uno de sus caracteres por medio de la posici\u00f3n o \u00edndice en que se encuentran en el string. Esta numeraci\u00f3n comienza a partir de 0, el cual corresponde al primer caracter.</p> Expresi\u00f3n Descripci\u00f3n <code>cadena[0:n]</code> Extrae desde el inicio hasta el \u00edndice <code>n</code> (sin incluirlo). <code>cadena[m:]</code> Extrae desde el \u00edndice <code>m</code> hasta el final. <code>cadena[m:n]</code> Extrae desde el \u00edndice <code>m</code> hasta el <code>n</code> (sin incluirlo). <code>cadena[-n:]</code> Extrae los \u00faltimos <code>n</code> caracteres. <p>Ejemplo de slicing:</p> <pre><code>texto = \"Python\"\nprint(texto[:4])   # Pyth\nprint(texto[2:])   # thon\nprint(texto[1:4])  # yth\nprint(texto[-3:])  # hon\n</code></pre>"},{"location":"material/S1/002/#caracteres-de-escape-en-strings","title":"Caracteres de Escape en Strings","text":"<p>Los caracteres de escape permiten incluir caracteres especiales dentro de un string sin interferencias respecto a sus funciones nativas en Python.</p> Caracter Descripci\u00f3n <code>\\'</code> Comilla simple. <code>\\\\</code> Barra invertida. <code>\\n</code> Nueva l\u00ednea. <code>\\r</code> Retorno de carro. <code>\\t</code> Tabulaci\u00f3n. <code>\\b</code> Retroceso. <code>\\f</code> Salto de p\u00e1gina. <code>\\ooo</code> Valor octal. <code>\\xhh</code> Valor hexadecimal. <p>Ejemplo de uso de los caracteres de escape:</p> <pre><code>print(\"Hola\\nMundo\")  # Salto de l\u00ednea\nprint(\"C:\\\\Archivos\\\\Datos\")  # Ruta con barra invertida\n</code></pre>"},{"location":"material/S1/002/#3-valores-booleanos-en-python","title":"3. Valores Booleanos en Python","text":"<p>Python maneja valores booleanos (<code>True</code> y <code>False</code>) que resultan de comparaciones y operaciones l\u00f3gicas.</p> <pre><code>x = 10\ny = 5\n\nes_mayor = x &gt; y  # True\nes_igual = x == y  # False\n\nprint(es_mayor, es_igual)\n</code></pre>"},{"location":"material/S1/002/#4-estructura-de-control-if-elif-else","title":"4. Estructura de Control <code>if-elif-else</code>","text":""},{"location":"material/S1/002/#que-es-una-estructura-condicional","title":"\u00bfQu\u00e9 es una estructura condicional?","text":"<p>En programaci\u00f3n, una estructura condicional permite tomar decisiones basadas en ciertas condiciones. En Python, se usa la estructura <code>if-elif-else</code> para evaluar diferentes escenarios y ejecutar bloques de c\u00f3digo seg\u00fan se cumplan o no determinadas condiciones.</p>"},{"location":"material/S1/002/#sintaxis-basica-de-if","title":"Sintaxis b\u00e1sica de <code>if</code>","text":"<pre><code>if condicion:\n    # C\u00f3digo que se ejecuta si la condici\u00f3n es verdadera\n</code></pre> <p>Uso correcto de la indentaci\u00f3n</p> <p>Observe la indentaci\u00f3n para indicar que el bloque de c\u00f3digo pertenece al <code>if</code>.</p> <p>El bloque de c\u00f3digo dentro del <code>if</code> se ejecuta solo si la condici\u00f3n es <code>True</code>. Si la condici\u00f3n es <code>False</code>, el bloque se ignora.</p> <p>Ejemplo:</p> <pre><code>edad = 20\nif edad &gt;= 18:\n    print(\"Eres mayor de edad.\")\n</code></pre>"},{"location":"material/S1/002/#uso-de-elif-y-else","title":"Uso de <code>elif</code> y <code>else</code>","text":"<ul> <li><code>elif</code>: Se utiliza para verificar una condici\u00f3n alternativa respecto a la del <code>if</code> inicial. Esta se verifica si el <code>if</code> no se ejecut\u00f3.</li> <li><code>else</code>: En el caso en que ninguna condici\u00f3n se cumpla, se ejecuta el bloque de c\u00f3digo perteneciente a esta.</li> </ul> <pre><code>edad = 14\nif edad &gt;= 18:\n    print(\"Eres adulto.\")\nelif edad &gt;= 13:\n    print(\"Eres adolescente.\")\nelse:\n    print(\"Eres un ni\u00f1o.\")\n</code></pre>"},{"location":"material/S1/002/#if-anidado","title":"<code>if</code> anidado","text":"<p>Es posible anidar estructuras <code>if</code> dentro de otras para evaluar m\u00faltiples condiciones de manera jer\u00e1rquica.</p> <pre><code>x = 20\nif x &gt; 10:\n    print(\"Mayor que 10\")\n    if x &gt; 15:\n        print(\"Mayor que 15\")\n</code></pre>"},{"location":"material/S1/002/#operador-ternario","title":"Operador ternario","text":"<p>Python permite simplificar condicionales mediante un operador ternario, que es una expresi\u00f3n compacta equivalente a <code>if-else</code>.</p> <pre><code>edad = 20\nmensaje = \"Mayor de edad\" if edad &gt;= 18 else \"Menor de edad\"\nprint(mensaje)\n</code></pre> <p>Este operador es \u00fatil cuando se necesita asignar valores en funci\u00f3n de una condici\u00f3n de manera concisa.</p>"},{"location":"material/S1/003/","title":"Clase 3: Listas y sus m\u00e9todos en Python","text":""},{"location":"material/S1/003/#listas-en-python","title":"Listas en Python","text":""},{"location":"material/S1/003/#concepto-y-creacion-de-listas","title":"Concepto y Creaci\u00f3n de Listas","text":"<p>Una lista es una estructura de datos en Python que permite almacenar m\u00faltiples valores en un solo contenedor. A diferencia de otros tipos de datos, las listas pueden contener elementos de diferentes tipos y permiten duplicados.</p> <p>Las listas son \u00fatiles cuando se necesita manejar colecciones de datos, como nombres de usuarios, precios de productos o resultados de c\u00e1lculos.</p> <p>Se pueden crear listas de dos maneras:</p> <pre><code># Usando corchetes []\nmi_lista = [1, 2, 3, 4, 5]\n\n# Usando list()\notra_lista = list((\"rojo\", \"verde\", \"azul\"))\n</code></pre> <p>Ambas formas crean una lista, aunque <code>list()</code> tambi\u00e9n puede usarse para convertir otros tipos de datos en listas.</p>"},{"location":"material/S1/003/#uso-del-operador-in","title":"Uso del Operador <code>in</code>","text":"<p>El operador <code>in</code> permite verificar si un elemento se encuentra dentro de una lista o string. Es una forma sencilla y eficiente de comprobar pertenencia.</p>"},{"location":"material/S1/003/#ejemplo-en-listas","title":"Ejemplo en listas","text":"<pre><code>frutas = [\"manzana\", \"banana\", \"cereza\"]\nif \"banana\" in frutas:\n    print(\"La banana est\u00e1 en la lista de frutas.\")\n</code></pre>"},{"location":"material/S1/003/#ejemplo-en-strings","title":"Ejemplo en strings","text":"<pre><code>mensaje = \"Bienvenidos a la clase de Python\"\nif \"Python\" in mensaje:\n    print(\"El mensaje menciona Python.\")\n</code></pre> <p>Este operador se usa frecuentemente en estructuras de control como <code>if</code>, y tambi\u00e9n en bucles <code>for</code> para iterar sobre listas o strings.</p>"},{"location":"material/S1/003/#propiedades-de-las-listas","title":"Propiedades de las Listas","text":"<p>Las listas en Python tienen varias caracter\u00edsticas clave:</p> <ul> <li>Mutabilidad: Se pueden modificar despu\u00e9s de su creaci\u00f3n.</li> <li>Permiten duplicados: Se pueden almacenar valores repetidos.</li> <li>Almacenan diferentes tipos de datos: Una lista puede contener elementos de distintos tipos.</li> </ul> <p>Ejemplo:</p> <pre><code>lista_mixta = [10, \"Python\", 3.14, True]\nprint(lista_mixta)\n</code></pre> <p>Esta caracter\u00edstica de aceptar m\u00faltiples tipos de datos hace que las listas sean extremadamente flexibles.</p>"},{"location":"material/S1/003/#largo-de-una-lista","title":"Largo de una Lista","text":"<p>Se usa la funci\u00f3n <code>len()</code> para obtener la cantidad de elementos en una lista. Tambi\u00e9n se puede utilizar para contar caracteres en un string.</p> <pre><code>lista = [1, 2, 3, 4, 5]\nprint(len(lista))  # Salida: 5\n\ncadena = \"Hola mundo\"\nprint(len(cadena))  # Salida: 10\n</code></pre> <p>Esta funci\u00f3n es \u00fatil para determinar la cantidad de elementos presentes en una colecci\u00f3n de datos.</p>"},{"location":"material/S1/003/#acceso-y-modificacion-de-elementos","title":"Acceso y Modificaci\u00f3n de Elementos","text":"<p>Los elementos de una lista se acceden mediante \u00edndices, comenzando desde <code>0</code>.</p> <pre><code>mi_lista = [\"manzana\", \"banana\", \"cereza\"]\nprint(mi_lista[0])  # manzana\n\nmi_lista[1] = \"uva\"\nprint(mi_lista)  # ['manzana', 'uva', 'cereza']\n</code></pre> <p>Tambi\u00e9n es posible acceder a elementos desde el final usando \u00edndices negativos:</p> <pre><code>print(mi_lista[-1])  # \u00daltimo elemento: cereza\n</code></pre>"},{"location":"material/S1/003/#metodos-para-modificar-listas","title":"M\u00e9todos para Modificar Listas","text":""},{"location":"material/S1/003/#agregar-elementos","title":"Agregar Elementos","text":""},{"location":"material/S1/003/#appendx-agregar-un-elemento-al-final-de-la-lista","title":"<code>append(x)</code>: Agregar un elemento al final de la lista","text":"<p>Agrega un elemento <code>x</code> al final de la lista.</p> <pre><code>numeros = [1, 2, 3]\nnumeros.append(4)\nprint(numeros)  # [1, 2, 3, 4]\n</code></pre>"},{"location":"material/S1/003/#inserti-x-insertar-un-elemento-en-una-posicion-especifica","title":"<code>insert(i, x)</code>: Insertar un elemento en una posici\u00f3n espec\u00edfica","text":"<p>Inserta un elemento en el \u00edndice <code>i</code> y con el valor de <code>x</code>.</p> <pre><code>colores = [\"rojo\", \"azul\", \"verde\"]\ncolores.insert(1, \"amarillo\")\nprint(colores)  # ['rojo', 'amarillo', 'azul', 'verde']\n</code></pre>"},{"location":"material/S1/003/#eliminar-elementos","title":"Eliminar Elementos","text":""},{"location":"material/S1/003/#removex-eliminar-la-primera-ocurrencia-de-un-elemento","title":"<code>remove(x)</code>: Eliminar la primera ocurrencia de un elemento","text":"<p>Elimina un elemento basado en su valor <code>x</code>.</p> <pre><code>frutas = [\"manzana\", \"banana\", \"cereza\", \"banana\"]\nfrutas.remove(\"banana\")\nprint(frutas)  # ['manzana', 'cereza', 'banana']\n</code></pre>"},{"location":"material/S1/003/#popi-eliminar-un-elemento-en-una-posicion-especifica","title":"<code>pop(i)</code>: Eliminar un elemento en una posici\u00f3n espec\u00edfica","text":"<p>Elimina un elemento basado en su \u00edndice en la lista.</p> <pre><code>numeros = [10, 20, 30, 40]\nultimo = numeros.pop()\nprint(numeros)  # [10, 20, 30]\nprint(\"Elemento eliminado:\", ultimo)  # 40\n</code></pre>"},{"location":"material/S1/003/#ordenar-y-revertir-listas","title":"Ordenar y Revertir Listas","text":""},{"location":"material/S1/003/#sort-ordenar-la-lista-en-orden-ascendente","title":"<code>sort()</code>: Ordenar la lista en orden ascendente","text":"<pre><code>numeros = [3, 1, 4, 1, 5, 9]\nnumeros.sort()\nprint(numeros)  # [1, 1, 3, 4, 5, 9]\n</code></pre>"},{"location":"material/S1/003/#reverse-invertir-el-orden-de-los-elementos-de-la-lista","title":"<code>reverse()</code>: Invertir el orden de los elementos de la lista","text":"<pre><code>letras = [\"a\", \"b\", \"c\", \"d\"]\nletras.reverse()\nprint(letras)  # ['d', 'c', 'b', 'a']\n</code></pre>"},{"location":"material/S1/003/#copiar-y-unir-listas","title":"Copiar y Unir Listas","text":""},{"location":"material/S1/003/#copy-crear-una-copia-de-la-lista","title":"<code>copy()</code>: Crear una copia de la lista","text":"<pre><code>original = [1, 2, 3]\ncopia = original.copy()\nprint(copia)  # [1, 2, 3]\n</code></pre>"},{"location":"material/S1/003/#extenditerable-agregar-los-elementos-de-otro-iterable","title":"<code>extend(iterable)</code>: Agregar los elementos de otro iterable","text":"<pre><code>a = [1, 2, 3]\nb = [4, 5, 6]\na.extend(b)\nprint(a)  # [1, 2, 3, 4, 5, 6]\n</code></pre> <p>Estos m\u00e9todos permiten modificar listas de manera eficiente sin necesidad de reescribir todos los valores manualmente.</p>"},{"location":"material/S1/004/","title":"Clase 4: Ejercicios de repaso y <code>for</code> loop","text":""},{"location":"material/S1/004/#ejercicios-de-repaso","title":"Ejercicios de repaso","text":""},{"location":"material/S1/004/#ejercicio-1-conversor-de-notas-a-letras","title":"Ejercicio 1: Conversor de notas a letras","text":"<p>Escribe una funci\u00f3n que reciba un n\u00famero representando una calificaci\u00f3n (de 0 a 100) y devuelva la letra correspondiente seg\u00fan la siguiente escala:</p> <ul> <li>90-100 \u2192 A</li> <li>80-89 \u2192 B</li> <li>70-79 \u2192 C</li> <li>60-69 \u2192 D</li> <li>Menos de 60 \u2192 F</li> </ul> <p>Ejemplo:</p> <pre><code>Entrada: 85\nSalida: 'B'\n</code></pre>"},{"location":"material/S1/004/#ejercicio-2-clasificacion-de-palabras","title":"Ejercicio 2: Clasificaci\u00f3n de palabras","text":"<p>Escribe una funci\u00f3n que reciba una palabra y determine si cumple con alguna de las siguientes condiciones:</p> <ul> <li>Es un pal\u00edndromo (se lee igual al derecho y al rev\u00e9s).</li> <li>Tiene m\u00e1s de 5 caracteres.</li> <li>Comienza con una vocal.</li> </ul> <p>La funci\u00f3n debe devolver una lista con los mensajes correspondientes.</p> <p>Ejemplo:</p> <pre><code>Entrada: \"radar\"\nSalida: ['La palabra es un pal\u00edndromo.']\n</code></pre>"},{"location":"material/S1/004/#ejercicio-3-encontrar-el-numero-mayor-y-menor-en-una-lista","title":"Ejercicio 3: Encontrar el n\u00famero mayor y menor en una lista","text":"<p>Escribe una funci\u00f3n que reciba una lista de n\u00fameros enteros y devuelva el n\u00famero m\u00e1s grande y el m\u00e1s peque\u00f1o.</p> <p>Ejemplo:</p> <pre><code>Entrada: 3 1 7 9 2 8\nSalida: (9, 1)\n</code></pre>"},{"location":"material/S1/004/#ejercicio-4-ultima-palabra-de-una-oracion","title":"Ejercicio 4: \u00daltima palabra de una oraci\u00f3n","text":"<p>Escribe una funci\u00f3n que reciba una oraci\u00f3n como string y devuelva la \u00faltima palabra de la oraci\u00f3n.</p> <p>Ejemplo:</p> <pre><code>Entrada: \"Hola, esto es un test\"\nSalida: 'test'\n</code></pre>"},{"location":"material/S1/004/#ejercicio-5-comprobar-si-un-numero-es-multiplo-de-otro","title":"Ejercicio 5: Comprobar si un n\u00famero es m\u00faltiplo de otro","text":"<p>Pide dos n\u00fameros y muestra si el primero es m\u00faltiplo del segundo.</p> <pre><code>Entrada: 12 4\nSalida: \"12 es m\u00faltiplo de 4.\"\n</code></pre>"},{"location":"material/S1/004/#ejercicio-6-comparar-la-longitud-de-dos-palabras","title":"Ejercicio 6: Comparar la longitud de dos palabras","text":"<p>Solicita dos palabras al usuario y muestra cu\u00e1l es m\u00e1s larga o si tienen la misma cantidad de letras.</p> <pre><code>Entrada: \"manzana pera\"\nSalida: \"La palabra 'manzana' es m\u00e1s larga que 'pera'.\"\n</code></pre>"},{"location":"material/S1/004/#ejercicio-7-verificar-si-una-palabra-empieza-con-vocal","title":"Ejercicio 7: Verificar si una palabra empieza con vocal","text":"<p>Pide al usuario una palabra y muestra un mensaje indicando si comienza con una vocal.</p> <pre><code>Entrada: \"elefante\"\nSalida: \"La palabra comienza con una vocal.\"\n</code></pre>"},{"location":"material/S1/004/#ejercicio-8-oci-i-eliminatoria-2023","title":"Ejercicio 8: OCI I Eliminatoria 2023","text":"<p>En una peque\u00f1a ciudad rodeada de vibrante vegetaci\u00f3n y r\u00edos cristalinos, Camila y Jonathan son apasionados por la historia y la cultura que se refleja en un s\u00edmbolo nacional muy particular, el Yig\u00fcirro, el ave nacional. Ambos han dedicado a\u00f1os a coleccionar sellos con la imagen de este encantador p\u00e1jaro.</p> <p>Un buen d\u00eda, un amigo historiador les solicita prestados algunos de sus sellos para una exposici\u00f3n. La cantidad var\u00eda cada vez, y se vuelve un tanto complicado para Camila y Jonathan llevar la cuenta de cu\u00e1ntos sellos les quedan luego de cada pr\u00e9stamo. Necesitan tu ayuda para llevar un registro preciso. En cada ocasi\u00f3n, te informar\u00e1n cu\u00e1ntos sellos ten\u00edan originalmente y cu\u00e1ntos su amigo les ha pedido prestados. Con esa informaci\u00f3n, deber\u00e1s indicarles cu\u00e1ntos sellos les quedan. Recuerda, si el amigo les solicita m\u00e1s sellos de los que tienen, simplemente entregan todos sus sellos.</p> <pre><code>Entrada: \"10 5\"\nSalida: 5\n</code></pre>"},{"location":"material/S1/004/#bucles-for-en-python","title":"Bucles <code>for</code> en Python","text":"<p>Un bucle <code>for</code> permite ejecutar un bloque de c\u00f3digo m\u00faltiples veces, iterando sobre elementos de una secuencia como una lista, un string o un rango de n\u00fameros.</p>"},{"location":"material/S1/004/#iteracion-sobre-listas-y-strings","title":"Iteraci\u00f3n sobre Listas y Strings","text":"<pre><code>colores = [\"rojo\", \"verde\", \"azul\"]\nfor color in colores:\n    print(color)\n\nmensaje = \"Python\"\nfor letra in mensaje:\n    print(letra)\n</code></pre> <p>En estos ejemplos, el bucle <code>for</code> recorre cada elemento de la lista <code>colores</code> y cada car\u00e1cter del string <code>mensaje</code>.</p>"},{"location":"material/S1/004/#iteracion-con-range","title":"Iteraci\u00f3n con <code>range()</code>","text":"<p>El <code>range()</code> genera una secuencia de n\u00fameros, \u00fatil para iterar un n\u00famero espec\u00edfico de veces. El rango creado inicia en 0 de forma predeterminada.</p> <pre><code>for i in range(5):\n    print(i)  # 0, 1, 2, 3, 4\n</code></pre> <p>El <code>range(inicio, fin, paso)</code> permite especificar un inicio y un incremento personalizado. El valor de <code>fin</code> no es incluido en el rango final, realmente se recorre de <code>inicio</code> a <code>fin - 1</code>.</p> <pre><code>for i in range(2, 10, 2):\n    print(i)  # 2, 4, 6, 8\n</code></pre> <p>\u00bfPor qu\u00e9 se usa <code>range()</code> en bucles?</p> <ul> <li>Es eficiente: No genera una lista en memoria, sino que produce los valores sobre la marcha.</li> <li>Es flexible: Permite definir rangos personalizados con diferentes pasos.</li> <li>Es f\u00e1cil de usar con estructuras iterativas.</li> </ul>"},{"location":"material/S1/004/#uso-de-break-continue-pass","title":"Uso de <code>break</code>, <code>continue</code>, <code>pass</code>","text":"<pre><code>for num in range(10):\n    if num == 5:\n        break  # Detiene el bucle\n    if num % 2 == 0:\n        continue  # Salta a la siguiente iteraci\u00f3n\n    print(num)\n</code></pre> <pre><code>for _ in range(3):\n    pass  # No hace nada\n</code></pre>"},{"location":"material/S1/004/#bucles-for-anidados","title":"Bucles <code>for</code> Anidados","text":"<pre><code>for i in range(3):\n    for j in range(3):\n        print(f\"({i}, {j})\")\n</code></pre> <p>Complejidad: Un <code>for</code> anidado puede aumentar la cantidad de ejecuciones, generalmente con una complejidad de O(n\u00b2).</p>"},{"location":"material/S1/004/#else-en-un-for","title":"<code>else</code> en un <code>for</code>","text":"<p>Si el bucle <code>for</code> no se interrumpe con <code>break</code>, el bloque <code>else</code> se ejecuta.</p> <pre><code>for num in range(5):\n    print(num)\nelse:\n    print(\"Bucle terminado sin interrupci\u00f3n\")\n</code></pre>"},{"location":"material/S1/004/#uso-de-for-como-iterador-o-acceso-por-indice","title":"Uso de <code>for</code> como iterador o acceso por \u00edndice","text":"<p>Existen dos casos de uso del <code>for</code> loop: - Como iterador: Recorrer elemento por elemento de un objeto iterable. - \u00cdndice por \u00edndice: Acceder a los elementos por su \u00edndice.</p> <pre><code>string = \"Python\"\n\n# Elemento por elemento\nfor letra in string:\n    print(letra)\n\n# \u00cdndice por \u00edndice\n# Lo que interesa es que i est\u00e9 en el intervalo de 0, largo-1\nfor i in range(len(string)):\n    letra = string[i]\n    print(letra)\n</code></pre>"},{"location":"material/S1/005/","title":"Clase 5: Ejercicios de <code>for</code> loops","text":""},{"location":"material/S1/005/#ejercicio-1-contar-vocales-en-una-palabra","title":"Ejercicio 1: Contar vocales en una palabra","text":"<p>Escribe un programa que reciba una palabra y cuente cu\u00e1ntas vocales (<code>a, e, i, o, u</code>) tiene.</p> <p>Ejemplo:</p> <pre><code>Entrada: \"elefante\"\nSalida: 4\n\nEntrada: \"python\"\nSalida: 1\n</code></pre>"},{"location":"material/S1/005/#ejercicio-2-filtrar-palabras-cortas","title":"Ejercicio 2: Filtrar palabras cortas","text":"<p>Dada una lista de palabras, devuelve una nueva lista que contenga solo aquellas palabras con m\u00e1s de 4 letras.</p> <p>Ejemplo:</p> <pre><code>Entrada: [\"sol\", \"estrella\", \"luz\", \"universo\"]\nSalida: [\"estrella\", \"universo\"]\n</code></pre>"},{"location":"material/S1/005/#ejercicio-3-encontrar-la-palabra-mas-larga-en-una-lista","title":"Ejercicio 3: Encontrar la palabra m\u00e1s larga en una lista","text":"<p>Dada una lista de palabras, devuelve la palabra con m\u00e1s caracteres. Si hay m\u00e1s de una con la misma longitud, devuelve la primera que aparece.</p> <p>Ejemplo:</p> <pre><code>Entrada: [\"perro\", \"elefante\", \"rat\u00f3n\"]\nSalida: \"elefante\"\n</code></pre>"},{"location":"material/S1/005/#ejercicio-4-contar-palabras-que-contienen-una-letra-especifica","title":"Ejercicio 4: Contar palabras que contienen una letra espec\u00edfica","text":"<p>Dada una lista de palabras y una letra, cuenta cu\u00e1ntas palabras contienen esa letra.</p> <p>Ejemplo:</p> <pre><code>Entrada: [\"casa\", \"carro\", \"perro\", \"gato\"], \"r\"\nSalida: 2\n</code></pre>"},{"location":"material/S1/005/#ejercicio-5-convertir-palabras-a-mayusculas-si-tienen-mas-de-5-letras","title":"Ejercicio 5: Convertir palabras a may\u00fasculas si tienen m\u00e1s de 5 letras","text":"<p>Dada una lista de palabras, devuelve una nueva lista donde las palabras con m\u00e1s de 5 letras est\u00e9n en may\u00fasculas y las dem\u00e1s queden igual.</p> <p>Ejemplo:</p> <pre><code>Entrada: [\"hola\", \"elefante\", \"mundo\", \"estrella\"]\nSalida: [\"hola\", \"ELEFANTE\", \"mundo\", \"ESTRELLA\"]\n</code></pre>"},{"location":"material/S1/005/#ejercicio-6-reemplazar-vocales-en-una-palabra","title":"Ejercicio 6: Reemplazar vocales en una palabra","text":"<p>Escribe un programa que reemplace todas las vocales de una palabra por un asterisco <code>*</code>.</p> <p>Ejemplo:</p> <pre><code>Entrada: \"programaci\u00f3n\"\nSalida: \"pr*gr*m*c**n\"\n</code></pre>"},{"location":"material/S1/005/#ejercicio-7-eliminar-palabras-repetidas-de-una-lista","title":"Ejercicio 7: Eliminar palabras repetidas de una lista","text":"<p>Dada una lista de palabras, devuelve una nueva lista con las palabras sin repetir, conservando el orden original.</p> <p>Ejemplo:</p> <pre><code>Entrada: [\"manzana\", \"pera\", \"manzana\", \"uva\", \"pera\"]\nSalida: [\"manzana\", \"pera\", \"uva\"]\n</code></pre>"},{"location":"material/S1/005/#ejercicio-8-determinar-si-una-lista-esta-ordenada","title":"Ejercicio 8: Determinar si una lista est\u00e1 ordenada","text":"<p>Escribe un programa que reciba una lista de n\u00fameros y determine si est\u00e1 ordenada de menor a mayor.</p> <p>Ejemplo:</p> <pre><code>Entrada: [1, 2, 3, 4, 5]\nSalida: True\n\nEntrada: [3, 1, 4, 2, 5]\nSalida: False\n</code></pre>"},{"location":"material/S1/005/#ejercicio-9-concatenar-todas-las-palabras-de-una-lista","title":"Ejercicio 9: Concatenar todas las palabras de una lista","text":"<p>Dada una lista de palabras, devuelve un solo string donde todas las palabras est\u00e9n separadas por un espacio (sin utilizar el m\u00e9todo <code>join()</code>)</p> <p>Ejemplo:</p> <pre><code>Entrada: [\"Hola\", \"mundo\", \"esto\", \"es\", \"Python\"]\nSalida: \"Hola mundo esto es Python\"\n</code></pre>"},{"location":"material/S1/005/#ejercicio-10-contar-numeros-pares-e-impares-en-una-lista","title":"Ejercicio 10: Contar n\u00fameros pares e impares en una lista","text":"<p>Dada una lista de n\u00fameros enteros, cuenta cu\u00e1ntos son pares y cu\u00e1ntos son impares.</p> <p>Ejemplo:</p> <pre><code>Entrada: [1, 2, 3, 4, 5, 6]\nSalida: \"Pares: 3, Impares: 3\"\n</code></pre>"},{"location":"material/S1/005/#ejercicio-11-contar-letras-en-una-lista-de-palabras","title":"Ejercicio 11: Contar letras en una lista de palabras","text":"<p>Dada una lista de palabras, devuelve una nueva lista con la cantidad de letras que tiene cada palabra.</p> <p>Ejemplo:</p> <pre><code>Entrada: [\"hola\", \"elefante\", \"sol\"]\nSalida: [4, 8, 3]\n</code></pre>"},{"location":"material/S1/005/#ejercicio-12-palabras-que-terminan-con-una-letra-especifica","title":"Ejercicio 12: Palabras que terminan con una letra espec\u00edfica","text":"<p>Dada una lista de palabras y una letra, devuelve una lista con las palabras que terminan con esa letra.</p> <p>Ejemplo:</p> <pre><code>Entrada: [\"luz\", \"sol\", \"coral\", \"animal\"], \"l\"\nSalida: [\"coral\", \"animal\"]\n</code></pre>"},{"location":"material/S1/005/#ejercicio-13-contar-cuantas-veces-aparece-una-letra-en-cada-palabra","title":"Ejercicio 13: Contar cu\u00e1ntas veces aparece una letra en cada palabra","text":"<p>Dada una lista de palabras y una letra, crea una nueva lista con la cantidad de veces que esa letra aparece en cada palabra.</p> <p>Ejemplo:</p> <pre><code>Entrada: [\"banana\", \"manzana\", \"pera\"], \"a\"\nSalida: [3, 3, 1]\n</code></pre>"},{"location":"material/S1/005/#ejercicio-14-buscar-palabras-con-letras-repetidas-for-anidado","title":"Ejercicio 14: Buscar palabras con letras repetidas (for anidado)","text":"<p>Dada una lista de palabras, devuelve una lista con las palabras que tienen alguna letra repetida.</p> <p>Ejemplo:</p> <pre><code>Entrada: [\"sol\", \"gato\", \"taza\", \"luz\", \"elefante\"]\nSalida: [\"taza\", \"elefante\"]\n</code></pre>"},{"location":"material/S1/005/#ejercicio-15-contar-letras-vocales-en-cada-palabra-for-anidado","title":"Ejercicio 15: Contar letras vocales en cada palabra (for anidado)","text":"<p>Dada una lista de palabras, devuelve una lista con la cantidad de vocales que tiene cada una.</p> <p>Ejemplo:</p> <pre><code>Entrada: [\"hola\", \"python\", \"elefante\"]\nSalida: [2, 1, 4]\n</code></pre>"},{"location":"material/S1/005/#ejercicio-16-mostrar-letras-comunes-entre-pares-de-palabras-for-anidado","title":"Ejercicio 16: Mostrar letras comunes entre pares de palabras (for anidado)","text":"<p>Dada una lista de dos palabras, muestra las letras que tienen en com\u00fan (sin repetir letras).</p> <p>Ejemplo:</p> <pre><code>Entrada: [\"python\", \"elefante\"]\nSalida: ['e', 'n']\n</code></pre>"},{"location":"material/S1/005/#ejercicio-17-contar-cuantas-palabras-contienen-al-menos-una-vocal","title":"Ejercicio 17: Contar cu\u00e1ntas palabras contienen al menos una vocal","text":"<p>Dada una lista de palabras, cuenta cu\u00e1ntas contienen al menos una vocal.</p> <p>Ejemplo:</p> <pre><code>Entrada: [\"sky\", \"agua\", \"sol\", \"fly\"]\nSalida: 2\n</code></pre>"},{"location":"material/S1/006/","title":"Clase 6: Bucle <code>while</code> en Python","text":""},{"location":"material/S1/006/#sintaxis-basica-del-while","title":"Sintaxis b\u00e1sica del <code>while</code>","text":"<p>El bucle <code>while</code> en Python permite ejecutar un bloque de c\u00f3digo mientras se cumpla una condici\u00f3n. Es una de las estructuras de control de flujo m\u00e1s utilizadas cuando no se sabe de antemano cu\u00e1ntas veces se necesita repetir un conjunto de instrucciones.</p> <p>La condici\u00f3n se eval\u00faa antes de cada iteraci\u00f3n. Si es <code>True</code>, se ejecuta el bloque. Cuando la condici\u00f3n sea <code>False</code>, se detiene el bucle.</p> <pre><code>while condici\u00f3n:\n    # bloque de c\u00f3digo a ejecutar mientras la condici\u00f3n sea True\n</code></pre>"},{"location":"material/S1/006/#ejemplo-con-contador","title":"Ejemplo con contador","text":"<p>Este bucle imprime los n\u00fameros del 1 al 5. Se utiliza un contador que se incrementa en cada vuelta para evitar un bucle infinito.</p> <pre><code>contador = 1\nwhile contador &lt;= 5:\n    print(\"Iteraci\u00f3n n\u00famero:\", contador)\n    contador += 1  # incremento del contador\n</code></pre>"},{"location":"material/S1/006/#ejemplo-con-condicion-booleana","title":"Ejemplo con condici\u00f3n booleana","text":"<p>Aqu\u00ed el bucle se mantiene activo mientras el usuario escriba <code>s</code>. La condici\u00f3n depende de una variable booleana que se actualiza dentro del bucle.</p> <pre><code>continuar = True\nwhile continuar:\n    respuesta = input(\"\u00bfDesea continuar? (s/n): \")\n    if respuesta.lower() != \"s\":\n        continuar = False\n</code></pre>"},{"location":"material/S1/006/#palabras-clave-utiles-en-bucles","title":"Palabras clave \u00fatiles en bucles","text":""},{"location":"material/S1/006/#break","title":"<code>break</code>","text":"<p>Detiene el bucle inmediatamente, sin esperar a que la condici\u00f3n sea falsa.</p> <pre><code>while True:\n    entrada = input(\"Escriba 'salir' para terminar: \")\n    if entrada == \"salir\":\n        break\n    print(\"Ingres\u00f3:\", entrada)\n</code></pre> <p>Uso del <code>break</code> y bucles infinitos</p> <p>El uso de bucles infinitos con <code>while True</code> y luego terminarlos repentinamente con <code>break</code> no es recomendable ni considerado un buena pr\u00e1ctica de programaci\u00f3n. Es mejor utilizar una condici\u00f3n booleana como las del ejemplo 1.2 y cambiar su estado cuando se desea terminar el loop.</p>"},{"location":"material/S1/006/#continue","title":"<code>continue</code>","text":"<p>Salta al siguiente ciclo del bucle, sin ejecutar el resto del bloque actual.</p> <pre><code>i = 0\nwhile i &lt; 5:\n    i += 1\n    if i == 3:\n        continue\n    print(i)  # No imprimir\u00e1 el n\u00famero 3\n</code></pre>"},{"location":"material/S1/006/#pass","title":"<code>pass</code>","text":"<p>No hace nada. Se utiliza cuando la sintaxis requiere una instrucci\u00f3n pero no se desea ejecutar ninguna acci\u00f3n (placeholder).</p> <pre><code>while True:\n    pass  # Bucle infinito sin instrucciones (ejemplo te\u00f3rico)\n</code></pre>"},{"location":"material/S1/006/#casos-de-uso-del-while","title":"Casos de uso del <code>while</code>","text":""},{"location":"material/S1/006/#contador-con-condicion","title":"Contador con condici\u00f3n","text":"<pre><code>i = 0\nwhile i &lt; 10:\n    print(i)\n    i += 1\n</code></pre>"},{"location":"material/S1/006/#validacion-de-entrada","title":"Validaci\u00f3n de entrada","text":"<pre><code>usuario = \"\"\nwhile usuario != \"admin\":\n    usuario = input(\"Ingrese el nombre de usuario correcto: \")\nprint(\"Bienvenido, admin.\")\n</code></pre>"},{"location":"material/S1/006/#esperar-una-condicion-externa","title":"Esperar una condici\u00f3n externa","text":"<pre><code>import random\n\nnumero = 0\nwhile numero != 5:\n    numero = random.randint(1, 10)\n    print(\"N\u00famero generado:\", numero)\n</code></pre>"},{"location":"material/S1/006/#repetir-hasta-que-se-introduzca-un-numero-valido","title":"Repetir hasta que se introduzca un n\u00famero v\u00e1lido","text":"<pre><code>entrada = input(\"Ingrese un n\u00famero positivo: \")\nwhile not entrada.isdigit() or int(entrada) &lt;= 0:\n    entrada = input(\"Error. Ingrese un n\u00famero positivo: \")\nprint(\"N\u00famero aceptado:\", entrada)\n</code></pre>"},{"location":"material/S1/006/#calcular-la-suma-de-numeros-hasta-que-el-usuario-escriba-fin","title":"Calcular la suma de n\u00fameros hasta que el usuario escriba \"fin\"","text":"<pre><code>suma = 0\nentrada = input(\"Ingrese un n\u00famero o 'fin' para terminar: \")\nwhile entrada != \"fin\":\n    if entrada.isdigit():\n        suma += int(entrada)\n    else:\n        print(\"Dato inv\u00e1lido, intente nuevamente.\")\n    entrada = input(\"Ingrese un n\u00famero o 'fin' para terminar: \")\nprint(\"La suma total es:\", suma)\n</code></pre>"},{"location":"material/S1/006/#contrasena-con-intento-limitado","title":"Contrase\u00f1a con intento limitado","text":"<pre><code>intentos = 0\nclave = \"python123\"\nwhile intentos &lt; 3:\n    entrada = input(\"Ingrese la contrase\u00f1a: \")\n    if entrada == clave:\n        print(\"Acceso concedido.\")\n        break\n    else:\n        print(\"Contrase\u00f1a incorrecta.\")\n        intentos += 1\nelse:\n    print(\"Demasiados intentos fallidos.\")\n</code></pre>"},{"location":"material/S1/006/#importancia-del-control-del-bucle","title":"Importancia del control del bucle","text":"<p>Es fundamental asegurarse de que la condici\u00f3n del <code>while</code> pueda llegar a ser falsa, de lo contrario el programa entrar\u00e1 en un bucle infinito. Normalmente esto se controla mediante:</p> <ul> <li>Incremento o modificaci\u00f3n de variables internas.</li> <li>Validaci\u00f3n de condiciones externas (como input).</li> </ul>"},{"location":"material/S1/006/#else-con-while","title":"<code>else</code> con <code>while</code>","text":"<p>El bucle <code>while</code> puede incluir un bloque <code>else</code>, que se ejecuta cuando la condici\u00f3n ya no se cumple y el bucle no fue interrumpido con <code>break</code>.</p> <pre><code>i = 1\nwhile i &lt;= 3:\n    print(i)\n    i += 1\nelse:\n    print(\"El bucle termin\u00f3 normalmente.\")\n</code></pre>"},{"location":"material/S1/006/#ejercicios-del-bucle-while","title":"Ejercicios del Bucle <code>while</code>","text":"<p>A continuaci\u00f3n se presentan ejercicios para profundizar en el uso del bucle <code>while</code>.</p>"},{"location":"material/S1/006/#ejercicio-1-contador-con-condiciones","title":"Ejercicio 1: Contador con condiciones","text":"<p>Escribe un programa que imprima los n\u00fameros del 1 al 20, pero:</p> <ul> <li>Si el n\u00famero es m\u00faltiplo de 3, imprime \"Fizz\".</li> <li>Si es m\u00faltiplo de 5, imprime \"Buzz\".</li> <li>Si es m\u00faltiplo de ambos, imprime \"FizzBuzz\".   Usa un bucle <code>while</code>.</li> </ul>"},{"location":"material/S1/006/#ejercicio-2-validacion-de-numero-primo","title":"Ejercicio 2: Validaci\u00f3n de n\u00famero primo","text":"<p>Solicita al usuario un n\u00famero mayor que 1. Luego determina si es primo utilizando un bucle <code>while</code> que verifique sus divisores.</p>"},{"location":"material/S1/006/#ejercicio-3-suma-acumulativa-con-control-de-errores","title":"Ejercicio 3: Suma acumulativa con control de errores","text":"<p>Pide al usuario que ingrese n\u00fameros uno por uno. Suma los valores v\u00e1lidos (enteros positivos) hasta que el usuario escriba \"fin\". Si ingresa algo incorrecto (como letras o n\u00fameros negativos), ign\u00f3ralos y contin\u00faa.</p>"},{"location":"material/S1/006/#ejercicio-4-sistema-de-login-con-bloqueo","title":"Ejercicio 4: Sistema de login con bloqueo","text":"<p>Simula un sistema de login donde el usuario tiene hasta 3 intentos para ingresar un usuario y contrase\u00f1a v\u00e1lidos. Si falla, muestra un mensaje de bloqueo. El usuario v\u00e1lido es <code>admin</code> y la contrase\u00f1a <code>1234</code>.</p>"},{"location":"material/S1/006/#ejercicio-5-adivinar-numero-con-intentos-contados","title":"Ejercicio 5: Adivinar n\u00famero con intentos contados","text":"<p>Genera un n\u00famero aleatorio entre 1 y 50. El usuario tiene hasta 5 intentos para adivinarlo. Despu\u00e9s de cada intento, informa si el n\u00famero secreto es mayor o menor que el ingresado. Si no lo acierta, indica el n\u00famero correcto al final.</p>"},{"location":"material/S1/006/#ejercicio-6-frecuencia-de-letra-en-una-palabra","title":"Ejercicio 6: Frecuencia de letra en una palabra","text":"<p>Solicita al usuario una palabra y una letra. Recorre la palabra con un bucle <code>while</code> y cuenta cu\u00e1ntas veces aparece la letra (sin usar <code>.count()</code>).</p>"},{"location":"material/S1/006/#ejercicio-7-confirmacion-de-cierre-con-multiples-respuestas","title":"Ejercicio 7: Confirmaci\u00f3n de cierre con m\u00faltiples respuestas","text":"<p>Solicita al usuario si desea salir del programa. Acepta \"s\u00ed\", \"no\", \"s\", \"n\", en may\u00fasculas o min\u00fasculas. Solo finaliza cuando la respuesta sea afirmativa.</p>"},{"location":"material/S1/006/#ejercicio-8-suma-de-digitos-sin-strings","title":"Ejercicio 8: Suma de d\u00edgitos (sin strings)","text":"<p>Solicita un n\u00famero entero positivo y calcula la suma de sus d\u00edgitos uno a uno usando solo operaciones aritm\u00e9ticas. Ejemplo: 342 \u2192 3 + 4 + 2 = 9.</p>"},{"location":"material/S1/006/#ejercicio-9-tabla-personalizada-de-multiplicar","title":"Ejercicio 9: Tabla personalizada de multiplicar","text":"<p>Solicita al usuario un n\u00famero entre 1 y 9, y el l\u00edmite de la tabla (por ejemplo, hasta 15). Imprime su tabla de multiplicar con <code>while</code> hasta el n\u00famero indicado.</p>"},{"location":"material/S1/006/#ejercicio-10-menu-interactivo-con-opciones","title":"Ejercicio 10: Men\u00fa interactivo con opciones","text":"<p>Crea un men\u00fa con las siguientes opciones:</p> <ol> <li>Ingresar nombre</li> <li>Mostrar saludo personalizado</li> <li>Salir</li> </ol> <p>Debe funcionar con un <code>while</code> hasta que el usuario elija salir. Si selecciona la opci\u00f3n 2 sin haber ingresado un nombre, muestra un mensaje de advertencia.</p>"},{"location":"material/S1/007/","title":"Clase 7: Ejercicios de repaso","text":"<p>En esta clase, se realizan 3 ejercicios como repaso para el primer examen parcial del curso.</p>"},{"location":"material/S1/007/#ejercicio-1-evaluacion-de-rendimiento-academico","title":"Ejercicio 1: Evaluaci\u00f3n de Rendimiento Acad\u00e9mico","text":"<p>Solicita al usuario ingresar los nombres y notas de varios estudiantes. Luego muestra:</p> <ul> <li>Lista de estudiantes con su nota</li> <li>Promedio general del grupo</li> <li>Cu\u00e1ntos estudiantes aprobaron (nota &gt;= 70)</li> <li>Cu\u00e1l fue el mejor y el peor estudiante</li> </ul> <p>Requisitos:</p> <ul> <li>Usar dos listas: una para nombres y otra para notas</li> <li>Usar <code>zip()</code> para emparejar nombre y nota al mostrar resultados</li> </ul> <p>Ejemplo esperado de ejecuci\u00f3n:</p> <pre><code>\u00bfCu\u00e1ntos estudiantes desea registrar?: 3\nNombre del estudiante 1: Ana\nNota del estudiante 1: 80\nNombre del estudiante 2: Luis\nNota del estudiante 2: 65\nNombre del estudiante 3: Marta\nNota del estudiante 3: 92\n\nNotas ingresadas:\nAna - 80\nLuis - 65\nMarta - 92\nPromedio: 79.0\nAprobados: 2\nMejor estudiante: Marta (92)\nPeor estudiante: Luis (65)\n</code></pre>"},{"location":"material/S1/007/#ejercicio-2-clasificador-de-palabras","title":"Ejercicio 2: Clasificador de Palabras","text":"<p>Solicita al usuario una lista de palabras (separadas por coma). Luego:</p> <ul> <li>Crea una lista con palabras que empiezan con vocal</li> <li>Otra con palabras que empiezan con consonante</li> <li>Muestra la cantidad de palabras en cada categor\u00eda y sus listas respectivas</li> </ul> <p>Ejemplo esperado de ejecuci\u00f3n:</p> <pre><code>Ingrese una lista de palabras separadas por coma: \u00e1rbol, sol, elefante, casa, igl\u00fa, nube\n\nPalabras que empiezan con vocal: ['\u00e1rbol', 'elefante', 'igl\u00fa']\nCantidad con vocal: 3\nPalabras que empiezan con consonante: ['sol', 'casa', 'nube']\nCantidad con consonante: 3\n</code></pre>"},{"location":"material/S1/007/#ejercicio-3-analisis-de-precios","title":"Ejercicio 3: An\u00e1lisis de Precios","text":"<p>Pide al usuario que ingrese una lista de precios de productos. Luego:</p> <ul> <li>Calcula el total de la compra</li> <li>Muestra cu\u00e1ntos productos son mayores a 1000 colones</li> <li>Muestra el precio m\u00e1s caro y m\u00e1s barato</li> <li>Aplica un 10% de descuento si el total supera los 5000 colones</li> </ul> <p>Requisitos:</p> <ul> <li>Validar que los precios sean positivos</li> <li>Usar listas y funciones como <code>sum()</code>, <code>max()</code>, <code>min()</code></li> </ul> <p>Ejemplo esperado de ejecuci\u00f3n:</p> <pre><code>Ingrese los precios de los productos separados por coma: 1200, 300, 5200, 1500\n\nTotal antes de descuento: 8200\nProductos mayores a 1000 colones: 3\nPrecio m\u00e1s caro: 5200\nPrecio m\u00e1s barato: 300\nTotal con descuento:\n</code></pre>"},{"location":"material/S1/008/","title":"Clase 8: Estructuras de Datos en Python (Tuplas, Diccionarios y Sets)","text":"<p>Esta clase cubre tres estructuras de datos fundamentales restantes en Python: tuplas, diccionarios y sets. Cada una tiene propiedades particulares, ventajas espec\u00edficas y una variedad de m\u00e9todos \u00fatiles para resolver distintos tipos de problemas.</p>"},{"location":"material/S1/008/#tuplas","title":"Tuplas","text":""},{"location":"material/S1/008/#que-es-una-tupla","title":"\u00bfQu\u00e9 es una tupla?","text":"<p>Una tupla es una colecci\u00f3n ordenada de elementos que no puede ser modificada despu\u00e9s de su creaci\u00f3n. Son \u00fatiles cuando se desea almacenar datos que no deben cambiar, como coordenadas, fechas o informaci\u00f3n de configuraci\u00f3n.</p>"},{"location":"material/S1/008/#como-crear-una-tupla","title":"\u00bfC\u00f3mo crear una tupla?","text":"<p>Las tuplas pueden crearse utilizando par\u00e9ntesis o el constructor <code>tuple()</code>.</p> <pre><code>tupla1 = (\"manzana\", \"banana\", \"cereza\")\ntupla2 = tuple([1, 2, 3])\n</code></pre>"},{"location":"material/S1/008/#propiedades-de-las-tuplas","title":"Propiedades de las tuplas","text":"<ul> <li>Son ordenadas: mantienen el orden en el que fueron creadas.</li> <li>Son inmutables: no se pueden modificar despu\u00e9s de creadas.</li> <li>Permiten elementos duplicados.</li> <li>Son iterables: se pueden recorrer con un bucle <code>for</code>.</li> </ul>"},{"location":"material/S1/008/#obtener-el-largo-de-una-tupla","title":"Obtener el largo de una tupla","text":"<p>Se utiliza la funci\u00f3n <code>len()</code> para conocer la cantidad de elementos en una tupla.</p> <pre><code>print(len(tupla1)) # 3\n</code></pre>"},{"location":"material/S1/008/#acceder-a-elementos","title":"Acceder a elementos","text":"<p>Se puede acceder a los elementos por su \u00edndice, como en una lista.</p> <pre><code>print(tupla1[1])  # banana\n</code></pre>"},{"location":"material/S1/008/#modificar-una-tupla-usando-type-casting","title":"Modificar una tupla (usando type-casting)","text":"<p>Aunque no se pueden modificar directamente, se puede convertir a lista, modificar y volver a convertir a tupla.</p> <pre><code>t = (\"a\", \"b\", \"c\")\nlista = list(t)\nlista[1] = \"x\"\nt = tuple(lista)\nprint(t)  # ('a', 'x', 'c')\n</code></pre> <p>Anotaci\u00f3n</p> <p>Esto se realiza en casos espec\u00edficos donde el uso de una tupla es preferible sobre una lista y la modificaci\u00f3n es poco frecuente.</p>"},{"location":"material/S1/008/#eliminar-una-tupla","title":"Eliminar una tupla","text":"<p>Para eliminar una tupla completamente, se utiliza la palabra reservada <code>del</code>.</p> <pre><code>del tupla1\n</code></pre> <p>Anotaci\u00f3n</p> <p><code>del</code> tambi\u00e9n funciona con listas, diccionarios y variables.</p>"},{"location":"material/S1/008/#unir-tuplas","title":"Unir tuplas","text":"<p>Las tuplas pueden unirse utilizando el operador <code>+</code>.</p> <pre><code>tupla3 = tupla1 + tupla2\n</code></pre>"},{"location":"material/S1/008/#metodos-de-tuplas","title":"M\u00e9todos de tuplas","text":"<ul> <li><code>count()</code>: cuenta cu\u00e1ntas veces aparece un elemento espec\u00edfico.</li> <li><code>index()</code>: devuelve el \u00edndice de la primera aparici\u00f3n de un elemento.</li> </ul> <pre><code>t = (\"a\", \"b\", \"a\")\nprint(t.count(\"a\"))  # 2\nprint(t.index(\"b\"))  # 1\n</code></pre>"},{"location":"material/S1/008/#diccionarios","title":"Diccionarios","text":""},{"location":"material/S1/008/#que-es-un-diccionario","title":"\u00bfQu\u00e9 es un diccionario?","text":"<p>Un diccionario es una colecci\u00f3n de elementos que almacena datos en pares clave-valor. Es \u00fatil cuando se desea relacionar una clave con un valor de forma eficiente.</p> <pre><code>diccionario = {clave1:valor1, clave2:valor2, ...}\n</code></pre>"},{"location":"material/S1/008/#como-definir-un-diccionario","title":"C\u00f3mo definir un diccionario","text":"<p>Los diccionarios pueden definirse utilizando claves <code>{}</code> o con el constructor <code>dict()</code>.</p> <pre><code>d = {\"nombre\": \"Ana\", \"edad\": 25, \"activo\": True}\nd2 = dict(nombre=\"Ana\", edad=25)\n</code></pre> <p>Uso del constructor</p> <p>Observe que al utilizar el constructor, las claves no van entre comillas (\"\").</p>"},{"location":"material/S1/008/#propiedades-de-los-diccionarios","title":"Propiedades de los diccionarios","text":"<ul> <li>No permiten claves duplicadas.</li> <li>Son mutables (se pueden modificar).</li> <li>Pueden almacenar datos de diferentes tipos.</li> <li>Se accede a los valores mediante las claves.</li> </ul>"},{"location":"material/S1/008/#acceder-y-modificar-elementos","title":"Acceder y modificar elementos","text":"<p>Se accede mediante la clave y se pueden modificar los valores directamente.</p> <pre><code># Respecto al diccionario anterior\nprint(d[\"nombre\"])\nd[\"edad\"] = 26\n</code></pre>"},{"location":"material/S1/008/#metodos-utiles","title":"M\u00e9todos \u00fatiles","text":"<ul> <li><code>keys()</code>: devuelve todas las claves del diccionario.</li> <li><code>values()</code>: devuelve todos los valores.</li> <li><code>items()</code>: devuelve pares clave-valor.</li> </ul> <pre><code>print(d.keys())\nprint(d.values())\nprint(d.items())\n</code></pre>"},{"location":"material/S1/008/#agregar-elementos","title":"Agregar elementos","text":"<p>Se puede usar asignaci\u00f3n o el m\u00e9todo <code>update()</code>.</p> <pre><code>d[\"curso\"] = \"Python\" # Forma similar al acceder a un valor a partir de la clave \"curso\"\nd.update({\"pais\": \"Costa Rica\"})\n</code></pre> <p>Uso del m\u00e9todo <code>update</code></p> <p>Observe que el m\u00e9todo <code>.update()</code> y el acceso a partir de la clave con <code>[]</code> funciona tanto para agregar elementos como para modificar pares existentes.</p>"},{"location":"material/S1/008/#eliminar-elementos","title":"Eliminar elementos","text":"<p>Se pueden eliminar con <code>pop()</code>, <code>popitem()</code>, <code>del</code>, o vaciar el diccionario con <code>clear()</code>.</p> <pre><code>d.pop(\"edad\")\nd.popitem()\ndel d[\"nombre\"]\nd.clear()\n</code></pre>"},{"location":"material/S1/008/#recorrer-diccionarios","title":"Recorrer diccionarios","text":"<pre><code># Los dos primeros tienen el mismo comportamiento\nfor clave in d:\n    print(clave)\n\nfor clave in d.keys():\n    print(clave)\n\n# Imprimir valores\nfor valor in d.values():\n    print(valor)\n\n# Separar clave y valor con .items()\nfor clave, valor in d.items():\n    print(clave, valor)\n</code></pre>"},{"location":"material/S1/008/#copiar-un-diccionario","title":"Copiar un diccionario","text":"<p>Se utiliza el m\u00e9todo <code>.copy()</code> para copiar los contenidos de un diccionario (similar a como se realiza en listas).</p> <pre><code>copia = d.copy()\n</code></pre>"},{"location":"material/S1/008/#diccionarios-anidados","title":"Diccionarios anidados","text":"<p>Los diccionarios pueden contener otros diccionarios como valores.</p> <pre><code>alumnos = {\n    \"Juan\": {\"edad\": 15, \"nota\": 90},\n    \"Ana\": {\"edad\": 16, \"nota\": 95}\n}\n\nprint(alumnos[\"Juan\"][\"nota\"]) # 90\n</code></pre>"},{"location":"material/S1/008/#resumen-de-metodos-de-diccionarios","title":"Resumen de m\u00e9todos de diccionarios","text":"M\u00e9todo Descripci\u00f3n <code>.keys()</code> Devuelve todas las claves <code>.values()</code> Devuelve todos los valores <code>.items()</code> Devuelve pares (clave, valor) <code>.get()</code> Devuelve el valor asociado a una clave <code>.update()</code> Agrega o actualiza elementos <code>.pop()</code> Elimina un elemento con su clave <code>.popitem()</code> Elimina el \u00faltimo par a\u00f1adido <code>.clear()</code> Elimina todos los elementos <code>.copy()</code> Devuelve una copia del diccionario"},{"location":"material/S1/008/#sets-conjuntos","title":"Sets (Conjuntos)","text":""},{"location":"material/S1/008/#que-es-un-set","title":"\u00bfQu\u00e9 es un set?","text":"<p>Un set es una colecci\u00f3n de elementos \u00fanicos, sin orden espec\u00edfico. Es \u00fatil cuando se necesita asegurarse de que no haya duplicados en una colecci\u00f3n de datos.</p>"},{"location":"material/S1/008/#crear-un-set","title":"Crear un set","text":"<p>Puede crearse con llaves <code>{}</code> o el constructor <code>set()</code>.</p> <pre><code>s1 = {\"a\", \"b\", \"c\"}\ns2 = set([1, 2, 3]) # A partir de una lista, por ejemplo.\n</code></pre>"},{"location":"material/S1/008/#propiedades-de-los-sets","title":"Propiedades de los sets","text":"<ul> <li>No tienen orden: no se puede acceder a elementos por \u00edndice.</li> <li>No permiten elementos duplicados.</li> <li>Son mutables: se pueden agregar y eliminar elementos.</li> <li>True y 1 se consideran iguales. Igual para False y 0.</li> </ul>"},{"location":"material/S1/008/#verificar-pertenencia","title":"Verificar pertenencia","text":"<p>Se puede usar el operador <code>in</code>, similar a listas y otros tipos de estructuras de datos.</p> <pre><code>\"a\" in s1  # True\n</code></pre>"},{"location":"material/S1/008/#agregar-elementos_1","title":"Agregar elementos","text":"<p>Existen los siguientes m\u00e9todos para agregar elementos a un set:</p> <ul> <li><code>.add()</code>: Agregar un elemento \u00fanico.</li> <li><code>.update()</code>: Agregar una estructura de datos al set (set, lista, tupla).</li> </ul> <pre><code>s1.add(\"d\")\ns1.update([\"e\", \"f\"])\n</code></pre>"},{"location":"material/S1/008/#eliminar-elementos_1","title":"Eliminar elementos","text":"<p>Python implementa los siguientes m\u00e9todos para eliminar elementos de un set:</p> <ul> <li><code>.discard()</code>: No lanza error si no existe un elemento.</li> <li><code>.remove()</code>: Lanza error si no existe un elemento.</li> <li><code>.pop()</code>: Elimina un elemento aleatorio del set (usualmente <code>.pop</code> elimina a partir de un \u00edndice, pero el set est\u00e1 desordenado).</li> </ul> <pre><code>s1.discard(\"b\")\ns1.remove(\"a\")\ns1.pop()\n</code></pre>"},{"location":"material/S1/008/#operaciones-entre-sets","title":"Operaciones entre sets","text":"<p>Los sets permiten operaciones matem\u00e1ticas como uni\u00f3n, intersecci\u00f3n, diferencia y diferencia sim\u00e9trica.</p> <ul> <li>Union: Es una operaci\u00f3n entre conjuntos que une los contenidos de todos los sets en cuesti\u00f3n.</li> <li>Intersecci\u00f3n: Une los contenidos que comparten los sets de la operaci\u00f3n.</li> <li>Diferencia: Elimina los contenidos compartidos entre el set comparado y el principal de la operaci\u00f3n (guarda los que no comparten; es decir, la diferencia).</li> <li>Diferencia sim\u00e9trica: Guarda los contenidos que no son compartidos entre todos los sets (la simetr\u00eda viene porque se aplica la diferencia a todos los sets).</li> </ul> <pre><code>A = {1, 2, 3, 4}\nB = {3, 4, 5, 6}\n\nprint(A.union(B))           # {1, 2, 3, 4, 5, 6}\nprint(A | B)\n\nprint(A.intersection(B))    # {3, 4}\nprint(A &amp; B)\n\nprint(A.difference(B))      # {1, 2}\nprint(A - B)\n\nprint(A.symmetric_difference(B))  # {1, 2, 5, 6}\nprint(A ^ B)\n</code></pre> <p>La imagen a continuaci\u00f3n sirve como una explicaci\u00f3n visual de las operaciones anteriores:</p> <p> </p>"},{"location":"material/S1/008/#tabla-resumen-de-metodos-de-sets","title":"Tabla resumen de m\u00e9todos de sets","text":"M\u00e9todo Descripci\u00f3n <code>.add()</code> Agrega un solo elemento <code>.update()</code> Agrega m\u00faltiples elementos <code>.discard()</code> Elimina un elemento si existe, sin error <code>.remove()</code> Elimina un elemento, lanza error si no existe <code>.pop()</code> Elimina un elemento aleatorio <code>.clear()</code> Elimina todos los elementos del set <code>.union()</code> Une dos sets <code>.intersection()</code> Elementos comunes entre sets <code>.difference()</code> Elementos en uno pero no en el otro <code>.symmetric_difference()</code> Elementos no comunes entre los sets"},{"location":"material/S1/009/","title":"Clase 9: Ejercicios de Estructuras de Datos (Tuplas, Diccionarios y Sets)","text":"<p>En esta clase se plantean ejercicios de las estructuras de datos vistas anteriormente: sets, diccionarios y tuplas.</p>"},{"location":"material/S1/009/#1-sistema-de-evaluacion-cruzada-entre-estudiantes","title":"1. Sistema de evaluaci\u00f3n cruzada entre estudiantes","text":"<p>Solicita a cada estudiante que califique a otros compa\u00f1eros con una nota del 1 al 10. Guarda los resultados en un diccionario anidado. Luego:</p> <ul> <li>Calcula el promedio recibido por cada estudiante.</li> <li>Muestra qui\u00e9n fue el estudiante mejor evaluado.</li> </ul> <p>Ejemplo:</p> <pre><code>{\n  \"Ana\": {\"Luis\": 9, \"Carlos\": 8},\n  \"Luis\": {\"Ana\": 10, \"Carlos\": 9},\n  \"Carlos\": {\"Ana\": 7, \"Luis\": 8}\n}\n</code></pre>"},{"location":"material/S1/009/#2-analisis-de-habitos-de-lectura","title":"2. An\u00e1lisis de h\u00e1bitos de lectura","text":"<p>Recoge informaci\u00f3n sobre libros le\u00eddos por un grupo de personas (como sets). Luego:</p> <ul> <li>Muestra qu\u00e9 libros han le\u00eddo todos.</li> <li>Muestra qu\u00e9 libros son exclusivos de cada persona.</li> <li>Construye un set con todos los libros le\u00eddos sin repetir.</li> </ul> <p>Ejemplo:</p> <pre><code>{\n  \"Ana\": {\"1984\", \"El Principito\", \"Dune\"},\n  \"Luis\": {\"Dune\", \"1984\", \"It\"},\n  \"Carlos\": {\"1984\", \"Dune\"}\n}\n</code></pre>"},{"location":"material/S1/009/#3-base-de-datos-de-empleados-por-departamento","title":"3. Base de datos de empleados por departamento","text":"<p>Crea un diccionario donde la clave sea el nombre del departamento y el valor sea una lista de tuplas con informaci\u00f3n de cada empleado (nombre, edad, salario). Permite:</p> <ul> <li>Agregar un nuevo empleado.</li> <li>Calcular el promedio salarial por departamento.</li> <li>Encontrar al empleado con el salario m\u00e1s alto.</li> </ul> <p>Ejemplo:</p> <pre><code>{\n  \"TI\": [(\"Ana\", 30, 1200), (\"Luis\", 28, 1500)],\n  \"Ventas\": [(\"Carlos\", 35, 1000)]\n}\n</code></pre>"},{"location":"material/S1/009/#4-inventario-de-productos-con-multiples-almacenes","title":"4. Inventario de productos con m\u00faltiples almacenes","text":"<p>Gestiona un inventario que usa un diccionario anidado:</p> <pre><code>inventario = {\n  \"producto1\": {\"almacen1\": 20, \"almacen2\": 15},\n  \"producto2\": {\"almacen1\": 5, \"almacen2\": 0}\n}\n</code></pre> <p>Permite consultar:</p> <ul> <li>Stock total de un producto.</li> <li>Almacenes donde est\u00e1 agotado.</li> <li>Productos con stock cero en todos los almacenes.</li> </ul>"},{"location":"material/S1/009/#5-historial-de-navegacion-web","title":"5. Historial de navegaci\u00f3n web","text":"<p>Guarda en una lista de tuplas las visitas a sitios web en formato <code>(usuario, sitio, fecha)</code>. Luego:</p> <ul> <li>Crea un diccionario con claves usuario y valores como sets de sitios visitados.</li> <li>Muestra los sitios comunes entre todos los usuarios.</li> </ul> <p>Ejemplo:</p> <pre><code>[\n  (\"Ana\", \"wikipedia.org\", \"2024-05-01\"),\n  (\"Ana\", \"openai.com\", \"2024-05-02\"),\n  (\"Luis\", \"openai.com\", \"2024-05-01\"),\n  (\"Luis\", \"wikipedia.org\", \"2024-05-03\")\n]\n</code></pre>"},{"location":"material/S1/009/#6-resumen-de-encuestas","title":"6. Resumen de encuestas","text":"<p>Simula una encuesta donde cada persona puede elegir m\u00faltiples respuestas (almacenadas como sets). Luego analiza:</p> <ul> <li>La opci\u00f3n m\u00e1s popular.</li> <li>Qu\u00e9 combinaci\u00f3n de opciones fue m\u00e1s frecuente.</li> <li>Cu\u00e1ntas respuestas \u00fanicas hubo en total.</li> </ul> <p>Ejemplo:</p> <pre><code>[\n  {\"Python\", \"Java\"},\n  {\"Python\", \"C++\"},\n  {\"Python\", \"Java\"}\n]\n</code></pre>"},{"location":"material/S1/009/#7-agenda-semanal-de-un-salon-de-clases","title":"7. Agenda semanal de un sal\u00f3n de clases","text":"<p>Crea una estructura donde cada d\u00eda de la semana es una clave y su valor es una lista de tuplas con eventos <code>(nombre_evento, hora)</code>. Permite:</p> <ul> <li>Buscar eventos por nombre en toda la semana.</li> <li>Ver el evento m\u00e1s temprano de un d\u00eda espec\u00edfico.</li> <li>Detectar si hay conflictos horarios (mismo horario, mismo d\u00eda).</li> </ul> <p>Ejemplo:</p> <pre><code>{\n  \"lunes\": [(\"Matem\u00e1ticas\", 8), (\"Qu\u00edmica\", 10)],\n  \"martes\": [(\"Historia\", 8)]\n}\n</code></pre>"},{"location":"material/S1/009/#8-catalogo-de-cursos-con-prerequisitos","title":"8. Cat\u00e1logo de cursos con prerequisitos","text":"<p>Dise\u00f1a un sistema donde cada curso (clave del diccionario) tiene como valor un set de cursos prerequisito. Luego:</p> <ul> <li>Detecta si hay prerequisitos c\u00edclicos.</li> <li>Lista todos los cursos que no requieren ning\u00fan prerequisito.</li> </ul> <p>Ejemplo:</p> <pre><code>{\n  \"C\u00e1lculo II\": {\"C\u00e1lculo I\"},\n  \"F\u00edsica II\": {\"F\u00edsica I\"},\n  \"C\u00e1lculo I\": set()\n}\n</code></pre>"},{"location":"material/S1/009/#9-analisis-de-perfiles-de-usuario-en-una-red-social","title":"9. An\u00e1lisis de perfiles de usuario en una red social","text":"<p>Cada usuario tiene una tupla con su edad, ciudad y una lista de intereses. Almacena todos los usuarios en un diccionario. Luego:</p> <ul> <li>Muestra los intereses m\u00e1s comunes.</li> <li>Filtra usuarios por ciudad e inter\u00e9s.</li> <li>Agrupa usuarios por rango de edad usando sets.</li> </ul> <p>Ejemplo:</p> <pre><code>{\n  \"Ana\": (22, \"San Jos\u00e9\", [\"lectura\", \"m\u00fasica\"]),\n  \"Luis\": (28, \"Cartago\", [\"lectura\", \"deportes\"])\n}\n</code></pre>"},{"location":"material/S1/009/#10-sistema-de-control-de-asistencia-con-sets-y-diccionarios","title":"10. Sistema de control de asistencia con sets y diccionarios","text":"<p>Cada clase contiene un set de estudiantes presentes. Almacena la asistencia en un diccionario con la fecha como clave. Luego:</p> <ul> <li>Muestra el total de clases asistidas por cada estudiante.</li> <li>Identifica a quienes no asistieron nunca.</li> <li>Compara la asistencia entre dos fechas.</li> </ul> <p>Ejemplo:</p> <pre><code>{\n  \"2024-04-01\": {\"Ana\", \"Luis\"},\n  \"2024-04-02\": {\"Ana\"},\n  \"2024-04-03\": {\"Luis\", \"Carlos\"}\n}\n</code></pre>"},{"location":"material/S1/010/","title":"Clase 10: Funciones en Python","text":""},{"location":"material/S1/010/#por-que-usar-funciones","title":"\u00bfPor qu\u00e9 usar funciones?","text":"<p>Las funciones son bloques reutilizables de c\u00f3digo que permiten estructurar mejor los programas, evitar repeticiones y dividir las tareas en partes m\u00e1s peque\u00f1as. Uno de los principales beneficios que brindan las funciones est\u00e1 vinculado con el principio DRY (don't repeat yourself), pues permite llamar bloques de c\u00f3digo espec\u00edfico a partir del nombre de la funci\u00f3n.</p> <p>En esta clase se abordan desde los aspectos b\u00e1sicos hasta temas como recursi\u00f3n y tipos de argumentos. Usar funciones correctamente permite mejorar la organizaci\u00f3n del c\u00f3digo, facilitar su mantenimiento y comprensi\u00f3n.</p>"},{"location":"material/S1/010/#declarar-y-definir-una-funcion","title":"Declarar y definir una funci\u00f3n","text":"<p>Declarar una funci\u00f3n significa anunciar que existe, mientras que definir una funci\u00f3n implica escribir qu\u00e9 acciones realizar\u00e1. En Python, se utiliza la palabra clave <code>def</code> seguida del nombre de la funci\u00f3n, par\u00e9ntesis y dos puntos:</p> <pre><code>def saludar():\n    print(\"\u00a1Hola!\")\n</code></pre> <p>En este ejemplo, <code>saludar</code> es el nombre de la funci\u00f3n. Todo el bloque de c\u00f3digo indentado despu\u00e9s de los dos puntos pertenece al cuerpo de la funci\u00f3n.</p> <p>Es importante evitar usar nombres de funciones que coincidan con palabras reservadas de Python o funciones integradas como <code>print</code>, <code>sum</code>, <code>input</code>, entre otros.</p>"},{"location":"material/S1/010/#llamar-a-una-funcion","title":"Llamar a una funci\u00f3n","text":"<p>Una vez definida una funci\u00f3n, puede ser llamada desde cualquier parte del c\u00f3digo usando su nombre seguido de par\u00e9ntesis. Si la funci\u00f3n tiene par\u00e1metros, estos deben proporcionarse en la llamada.</p> <pre><code>saludar()  # Salida: \u00a1Hola!\n</code></pre> <p>Llamar una funci\u00f3n varias veces permite reutilizar el mismo bloque de instrucciones sin duplicar c\u00f3digo.</p>"},{"location":"material/S1/010/#parametros-y-argumentos","title":"Par\u00e1metros y argumentos","text":"<ul> <li>Un par\u00e1metro es una variable en la definici\u00f3n de una funci\u00f3n, es como una entrada esperada.</li> <li>Un argumento es el valor que se pasa cuando se llama a la funci\u00f3n.</li> </ul> <pre><code>def saludar(nombre):  # 'nombre' es el par\u00e1metro\n    print(f\"Hola, {nombre}\")\n\nsaludar(\"Ana\")  # \"Ana\" es el argumento\n</code></pre> <p>N\u00famero de argumentos posicionales</p> <p>El n\u00famero de argumentos debe coincidir con el n\u00famero de par\u00e1metros en la definici\u00f3n, salvo que se utilicen mecanismos como <code>*args</code> o valores predeterminados.</p> <p>Python permite definir m\u00faltiples par\u00e1metros separados por comas. Todos los argumentos se asignan en orden.</p>"},{"location":"material/S1/010/#variables-locales-y-globales","title":"Variables locales y globales","text":"<ul> <li>Variables locales: se crean dentro de una funci\u00f3n y s\u00f3lo existen mientras la funci\u00f3n se ejecuta.   No son accesibles desde fuera.</li> <li>Variables globales: se definen fuera de las funciones y pueden ser accedidas desde cualquier parte del programa.</li> </ul> <pre><code>mensaje = \"Hola global\"\n\ndef mostrar():\n    mensaje = \"Hola local\"\n    print(mensaje)\n\nmostrar()        # Hola local\nprint(mensaje)   # Hola global\n</code></pre> <p>Si se desea modificar una variable global dentro de una funci\u00f3n, se debe usar la palabra clave <code>global</code>, lo cual debe hacerse con precauci\u00f3n:</p> <pre><code>def cambiar():\n    global mensaje\n    mensaje = \"Modificado\"\n</code></pre> <p>Uso de <code>global</code></p> <p>Esta no es considerada una buena pr\u00e1ctica de programaci\u00f3n e indica un dise\u00f1o pobre.</p>"},{"location":"material/S1/010/#args-numero-arbitrario-de-argumentos","title":"<code>*args</code> \u2013 N\u00famero arbitrario de argumentos","text":"<p><code>*args</code> permite que una funci\u00f3n reciba cualquier cantidad de argumentos posicionales, que son accesibles como una tupla:</p> <pre><code>def sumar_todos(*numeros): # N\u00fameros representa una tupla\n    print(sum(numeros))\n\nsumar_todos(1, 2, 3, 4)  # Salida: 10\n</code></pre> <p>Se usa cuando no se conoce con antelaci\u00f3n cu\u00e1ntos valores ser\u00e1n enviados. No puede ir antes de argumentos normales, y s\u00f3lo se puede usar una vez en la definici\u00f3n.</p>"},{"location":"material/S1/010/#keyword-arguments","title":"Keyword arguments","text":"<p>Permiten especificar el nombre del par\u00e1metro al pasarle el argumento, sin importar el orden:</p> <pre><code>def saludar(nombre, edad):\n    print(f\"Nombre: {nombre}, Edad: {edad}\")\n\n# Se accede a las variables de los argumentos por su nombre, no por posici\u00f3n\nsaludar(edad=20, nombre=\"Luis\")\n</code></pre> <p>Esto es especialmente \u00fatil para funciones con muchos argumentos, lo cual hace el c\u00f3digo m\u00e1s legible.</p>"},{"location":"material/S1/010/#parametros-predeterminados","title":"Par\u00e1metros predeterminados","text":"<p>Se pueden definir valores por defecto para los par\u00e1metros, de modo que si no se especifican al llamar la funci\u00f3n, se use ese valor:</p> <pre><code>def saludar(nombre=\"Usuario\"):\n    print(f\"Hola, {nombre}\") # Se imprime `Usuario` si no se indica ning\u00fan argumento en la llamada\n</code></pre> <p>El par\u00e1metro con valor por defecto debe colocarse despu\u00e9s de los que no tienen. Si se define uno sin valor despu\u00e9s de uno con valor predeterminado, Python lanzar\u00e1 un error.</p>"},{"location":"material/S1/010/#paso-por-valor-y-referencia","title":"Paso por valor y referencia","text":"<ul> <li>Inmutables (<code>int</code>, <code>str</code>, <code>float</code>) se pasan por valor: no se modifica el valor original.</li> <li>Mutables (<code>list</code>, <code>dict</code>) se pasan por referencia: s\u00ed se puede modificar el objeto original desde la funci\u00f3n.</li> </ul> <pre><code>def modificar_lista(l):\n    l.append(4)\n\nmi_lista = [1, 2, 3]\nmodificar_lista(mi_lista)\nprint(mi_lista)  # Salida: [1, 2, 3, 4]\n</code></pre> <p>Para evitar efectos secundarios con estructuras mutables, se trabaja con una copia:</p> <pre><code>def modificar_sin_afectar(l):\n    copia = l.copy()\n    copia.append(99) # l no se ve afectada\n</code></pre>"},{"location":"material/S1/010/#palabra-clave-pass","title":"Palabra clave <code>pass</code>","text":"<p><code>pass</code> se utiliza cuando se necesita una funci\u00f3n vac\u00eda, por ejemplo, en una estructura que se completar\u00e1 m\u00e1s adelante.</p> <pre><code>def pendiente():\n    pass\n</code></pre> <p>Esto evita errores de sintaxis cuando a\u00fan no se define el cuerpo de la funci\u00f3n.</p>"},{"location":"material/S1/010/#palabra-clave-return","title":"Palabra clave <code>return</code>","text":"<p><code>return</code> detiene la ejecuci\u00f3n de la funci\u00f3n y puede:</p> <ul> <li>No retornar nada (equivale a <code>return None</code>)</li> <li>Recordar que el tipo de dato <code>None</code> es un tipo de dato nulo.</li> <li>Retornar un \u00fanico valor</li> <li>Retornar m\u00faltiples valores en forma de tupla</li> </ul> <p><code>return</code> permite comunicar distintas funciones o porciones de c\u00f3digo entre s\u00ed. Consiste en la salida de la funci\u00f3n.</p> <pre><code>def operaciones(a, b):\n    suma = a + b\n    resta = a - b\n    return suma, resta\n\nx, y = operaciones(5, 2)\n</code></pre> <p>Una funci\u00f3n puede tener m\u00faltiples <code>return</code>, dependiendo de las condiciones:</p> <pre><code>def analizar_numero(n):\n    if n &gt; 0:\n        return \"positivo\"\n    elif n &lt; 0:\n        return \"negativo\"\n    return \"cero\"\n</code></pre> <p>Numerosos <code>return</code> statements</p> <p>No se recomienda que las funciones tengan muchos <code>return</code> distintos.</p>"},{"location":"material/S1/011/","title":"Clase 11: Recursi\u00f3n y Estructuras de Datos en C++ (OCI)","text":""},{"location":"material/S1/011/#recursion","title":"Recursi\u00f3n","text":"<p>La recursi\u00f3n ocurre cuando una funci\u00f3n se llama a s\u00ed misma. Requiere una condici\u00f3n base que finalice la recursi\u00f3n, de lo contrario se produce un error de recursi\u00f3n infinita.</p> <p> </p> Edureka"},{"location":"material/S1/011/#ejemplo-1-factorial","title":"Ejemplo 1: Factorial","text":"<pre><code>def factorial(n):\n    if n == 0:\n        return 1\n    return n * factorial(n - 1)\n</code></pre>"},{"location":"material/S1/011/#ejemplo-2-fibonacci","title":"Ejemplo 2: Fibonacci","text":"<pre><code>def fibonacci(n):\n    if n == 0:\n        return 0\n    elif n == 1:\n        return 1\n    return fibonacci(n-1) + fibonacci(n-2)\n</code></pre>"},{"location":"material/S1/011/#ejemplo-3-suma-de-lista","title":"Ejemplo 3: Suma de lista","text":"<pre><code>def suma_lista(lista):\n    if not lista:\n        return 0\n    return lista[0] + suma_lista(lista[1:])\n</code></pre> <p>Recursi\u00f3n y memoria</p> <p>La recursi\u00f3n es elegante, pero puede ser menos eficiente que un bucle en t\u00e9rminos de memoria y tiempo. No es recomendable usar recursi\u00f3n si se pueden generar muchas funciones llamadas.</p>"},{"location":"material/S1/011/#estructuras-de-datos-en-c","title":"Estructuras de datos en C++","text":""},{"location":"material/S1/011/#1-arreglos-dinamicos-vector","title":"1. Arreglos Din\u00e1micos (<code>vector</code>)","text":"<p>Uso: Listas con acceso r\u00e1pido por \u00edndice, inserci\u00f3n al final.</p> <pre><code>vector&lt;int&gt; v = {1, 2, 3};\nv.push_back(4); // [1, 2, 3, 4]\ncout &lt;&lt; v[2];   // 3\n</code></pre>"},{"location":"material/S1/011/#2-cadenas-string","title":"2. Cadenas (<code>string</code>)","text":"<p>Uso: Manipulaci\u00f3n de texto con funciones \u00fatiles.</p> <pre><code>string a = \"hola\";\nstring b = a + \" mundo\"; // \"hola mundo\"\ncout &lt;&lt; b.substr(0, 4);  // \"hola\"\n</code></pre>"},{"location":"material/S1/011/#3-conjuntos","title":"3. Conjuntos","text":""},{"location":"material/S1/011/#set","title":"<code>set</code>","text":"<p>Uso: Elementos \u00fanicos, ordenados.</p> <pre><code>set&lt;int&gt; s = {3, 1, 4};\ns.insert(2); // {1, 2, 3, 4}\n</code></pre>"},{"location":"material/S1/011/#unordered_set","title":"<code>unordered_set</code>","text":"<p>Uso: Elementos \u00fanicos, sin orden, b\u00fasquedas r\u00e1pidas.</p> <pre><code>unordered_set&lt;int&gt; s = {1, 3, 5};\nif (s.count(3)) cout &lt;&lt; \"Existe\";\n</code></pre>"},{"location":"material/S1/011/#multiset","title":"<code>multiset</code>","text":"<p>Uso: Elementos duplicados permitidos.</p> <pre><code>multiset&lt;int&gt; ms;\nms.insert(5); ms.insert(5); // count(5) = 2\n</code></pre>"},{"location":"material/S1/011/#4-mapas","title":"4. Mapas","text":""},{"location":"material/S1/011/#map","title":"<code>map</code>","text":"<p>Uso: Claves ordenadas.</p> <pre><code>map&lt;string, int&gt; m;\nm[\"clave\"] = 5;\ncout &lt;&lt; m[\"clave\"]; // 5\n</code></pre>"},{"location":"material/S1/011/#unordered_map","title":"<code>unordered_map</code>","text":"<p>Uso: Claves sin orden, b\u00fasqueda r\u00e1pida.</p> <pre><code>unordered_map&lt;string, int&gt; m;\nm[\"banana\"] = 7;\n</code></pre>"},{"location":"material/S1/011/#5-bitset","title":"5. Bitset","text":"<p>Uso: Arreglo compacto de bits, ideal para conjuntos peque\u00f1os.</p> <pre><code>bitset&lt;8&gt; b(string(\"10101010\"));\ncout &lt;&lt; b.count(); // 4\n</code></pre>"},{"location":"material/S1/011/#6-deque","title":"6. Deque","text":"<p>Uso: Acceso eficiente al frente y fondo.</p> <pre><code>deque&lt;int&gt; d;\nd.push_front(3); d.push_back(5); // [3, 5]\nd.pop_front(); // [5]\n</code></pre>"},{"location":"material/S1/011/#7-pila-stack","title":"7. Pila (<code>stack</code>)","text":"<p>Uso: \u00daltimo en entrar, primero en salir (LIFO).</p> <pre><code>stack&lt;int&gt; s;\ns.push(1); s.push(2);\ns.pop(); // top = 1\n</code></pre>"},{"location":"material/S1/011/#8-cola-queue","title":"8. Cola (<code>queue</code>)","text":"<p>Uso: Primero en entrar, primero en salir (FIFO).</p> <pre><code>queue&lt;int&gt; q;\nq.push(1); q.push(2);\nq.pop(); // front = 2\n</code></pre>"},{"location":"material/S1/011/#9-cola-de-prioridad","title":"9. Cola de Prioridad","text":"<p>Uso: Recuperar y eliminar el mayor (por defecto) o menor.</p> <pre><code>priority_queue&lt;int&gt; pq;\npq.push(4); pq.push(10);\ncout &lt;&lt; pq.top(); // 10\n</code></pre>"},{"location":"material/S1/011/#comparacion-de-usos","title":"Comparaci\u00f3n de Usos","text":"Necesidad Estructura recomendada Acceso por \u00edndice <code>vector</code> Verificar pertenencia <code>unordered_set</code> Elementos \u00fanicos ordenados <code>set</code> Asociar claves a valores <code>map</code> / <code>unordered_map</code> LIFO / FIFO <code>stack</code> / <code>queue</code> Recuperar m\u00e1ximo/m\u00ednimo r\u00e1pido <code>priority_queue</code> Representar bits <code>bitset</code> Acceso a ambos extremos <code>deque</code>"},{"location":"material/S1/012/","title":"Clase 12: Algoritmos sobre n\u00fameros (OCI)","text":""},{"location":"material/S1/012/#minimo-y-maximo-en-un-arreglo","title":"M\u00ednimo y M\u00e1ximo en un Arreglo","text":""},{"location":"material/S1/012/#logica","title":"L\u00f3gica:","text":"<p>Buscar el valor m\u00ednimo o m\u00e1ximo en un arreglo consiste en recorrer todos los elementos y comparar cada uno con el actual m\u00ednimo o m\u00e1ximo registrado.</p> <p>Al inicio, se toma como referencia el primer elemento del arreglo. A medida que se avanza, si se encuentra un valor menor al m\u00ednimo registrado, se actualiza. De igual forma con el m\u00e1ximo. Esta operaci\u00f3n es \u00fatil para encontrar extremos en conjuntos de datos, como temperaturas m\u00e1s altas, precios m\u00ednimos, entre otros. El algoritmo es lineal porque analiza todos los elementos una sola vez.</p>"},{"location":"material/S1/012/#codigo-por-elemento","title":"C\u00f3digo por elemento:","text":"<pre><code>minimo = maximo = arreglo[0]\n\nfor valor in arreglo:\n    if valor &lt; minimo:\n        minimo = valor\n    if valor &gt; maximo:\n        maximo = valor\n</code></pre>"},{"location":"material/S1/012/#codigo-por-indice","title":"C\u00f3digo por \u00edndice:","text":"<pre><code>indice_min = indice_max = 0\nfor i in range(1, len(arreglo)):\n    if arreglo[i] &lt; arreglo[indice_min]:\n        indice_min = i\n    if arreglo[i] &gt; arreglo[indice_max]:\n        indice_max = i\n</code></pre>"},{"location":"material/S1/012/#sumas-de-prefijos","title":"Sumas de Prefijos","text":""},{"location":"material/S1/012/#logica-lineal","title":"L\u00f3gica lineal:","text":"<p>La suma de prefijos es una t\u00e9cnica que permite calcular r\u00e1pidamente la suma de cualquier subarreglo en tiempo constante, una vez se ha hecho un preprocesamiento en tiempo lineal.</p> <p>Consiste en crear un arreglo auxiliar donde cada posici\u00f3n guarda la suma acumulada desde el inicio hasta esa posici\u00f3n. Esto es \u00fatil para responder muchas consultas de suma de rangos en arreglos de forma eficiente.</p> <pre><code>prefijos = [0] * len(numeros)\nprefijos[0] = numeros[0]\nfor i in range(1, len(numeros)):\n    prefijos[i] = prefijos[i-1] + numeros[i]\n</code></pre>"},{"location":"material/S1/012/#logica-bidimensional","title":"L\u00f3gica bidimensional:","text":"<p>En el caso de matrices, la suma de prefijos bidimensional extiende esta idea para permitir obtener la suma de cualquier submatriz.</p> <p>Se usa una matriz acumulada donde cada celda representa la suma de la submatriz desde (0,0) hasta esa celda. Esta t\u00e9cnica es muy poderosa en procesamiento de im\u00e1genes o an\u00e1lisis de datos en cuadr\u00edculas.</p> <pre><code>filas, columnas = len(matriz), len(matriz[0])\np = [[0]*columnas for _ in range(filas)]\n\n# Primera fila y columna\np[0][0] = matriz[0][0]\nfor i in range(1, filas):\n    p[i][0] = p[i-1][0] + matriz[i][0]\nfor j in range(1, columnas):\n    p[0][j] = p[0][j-1] + matriz[0][j]\n\n# Resto de la matriz\nfor i in range(1, filas):\n    for j in range(1, columnas):\n        p[i][j] = p[i-1][j] + p[i][j-1] - p[i-1][j-1] + matriz[i][j]\n\ndef suma_submatriz(f1, c1, f2, c2):\n    suma = p[f2][c2]\n    if f1 &gt; 0: suma -= p[f1-1][c2]\n    if c1 &gt; 0: suma -= p[f2][c1-1]\n    if f1 &gt; 0 and c1 &gt; 0: suma += p[f1-1][c1-1]\n    return suma\n</code></pre>"},{"location":"material/S1/012/#busqueda-binaria","title":"B\u00fasqueda Binaria","text":""},{"location":"material/S1/012/#logica_1","title":"L\u00f3gica:","text":"<p>La b\u00fasqueda binaria es una t\u00e9cnica eficiente para encontrar un elemento dentro de una lista ordenada.</p> <p>En lugar de revisar todos los elementos, divide el arreglo a la mitad y decide en qu\u00e9 mitad continuar la b\u00fasqueda seg\u00fan si el objetivo es menor o mayor que el valor medio. Este enfoque reduce el tama\u00f1o del problema a la mitad en cada paso, lo cual da una complejidad logar\u00edtmica O(log n). Es fundamental que el arreglo est\u00e9 ordenado para que esta estrategia funcione.</p>"},{"location":"material/S1/012/#iterativa","title":"Iterativa:","text":"<pre><code>def busqueda_binaria(arr, objetivo):\n    izq, der = 0, len(arr) - 1\n    while izq &lt;= der:\n        medio = (izq + der) // 2\n        if arr[medio] == objetivo:\n            return medio\n        elif arr[medio] &lt; objetivo:\n            izq = medio + 1\n        else:\n            der = medio - 1\n    return -1\n</code></pre>"},{"location":"material/S1/012/#recursiva","title":"Recursiva:","text":"<pre><code>def busqueda_binaria_rec(arr, objetivo, izq, der):\n    if izq &gt; der:\n        return -1\n    medio = (izq + der) // 2\n    if arr[medio] == objetivo:\n        return medio\n    elif arr[medio] &lt; objetivo:\n        return busqueda_binaria_rec(arr, objetivo, medio + 1, der)\n    else:\n        return busqueda_binaria_rec(arr, objetivo, izq, medio - 1)\n</code></pre>"},{"location":"material/S1/012/#algoritmo-de-euclides","title":"Algoritmo de Euclides","text":""},{"location":"material/S1/012/#logica_2","title":"L\u00f3gica:","text":"<p>El algoritmo de Euclides es un m\u00e9todo cl\u00e1sico para encontrar el m\u00e1ximo com\u00fan divisor (MCD) de dos n\u00fameros enteros. Se basa en el principio de que el MCD de dos n\u00fameros no cambia si el n\u00famero mayor se reemplaza por su diferencia con el menor. Este proceso se repite hasta que el residuo sea cero, y el \u00faltimo valor distinto de cero es el MCD. Es un algoritmo muy eficiente, con complejidad temporal $\\(O(\\log{n})\\)$.</p> \\[ \\text{mcd}(a,b) = \\begin{matrix} a &amp; b = 0 \\\\ \\text{mcd(b, a mod b)} &amp; b \\ne 0 \\end{matrix} \\] <pre><code>def mcd(a, b):\n    while b:\n        a, b = b, a % b\n    return a\n</code></pre>"},{"location":"material/S1/012/#exponenciacion-binaria","title":"Exponenciaci\u00f3n Binaria","text":""},{"location":"material/S1/012/#logica_3","title":"L\u00f3gica:","text":"<p>La exponenciaci\u00f3n binaria permite calcular potencias de forma muy eficiente, especialmente en contextos donde el exponente es muy grande, como en criptograf\u00eda o teor\u00eda de n\u00fameros. En lugar de multiplicar <code>a</code> por s\u00ed mismo <code>b</code> veces, divide el problema usando que \\(a^b = (a^{\\frac{b}{2}})^2\\) si $\\(b\\)$ es par, o $\\(a \\cdot a^{b-1}\\)$ si es impar. Esta estrategia reduce el n\u00famero de multiplicaciones a $\\(O(\\log{b})\\)$, aprovechando la representaci\u00f3n binaria del exponente. }</p> <pre><code>def exponenciacion_binaria(a, b):\n    if b == 0:\n        return 1\n    mitad = exponenciacion_binaria(a, b // 2)\n    if b % 2 == 0:\n        return mitad * mitad\n    else:\n        return a * mitad * mitad\n</code></pre>"},{"location":"material/S1/012/#test-de-primalidad-on","title":"Test de Primalidad O(\u221an)","text":""},{"location":"material/S1/012/#logica_4","title":"L\u00f3gica:","text":"<p>Un n\u00famero <code>n</code> es primo si tiene exactamente dos divisores: 1 y \u00e9l mismo. Para verificar esto, basta con probar si <code>n</code> es divisible por alg\u00fan n\u00famero entre 2 y \u221an. Si <code>n</code> tiene un divisor en ese rango, no es primo. Este m\u00e9todo es eficiente porque cualquier divisor mayor que \u221an implicar\u00eda uno menor que ya se habr\u00eda encontrado.</p> <pre><code>from math import isqrt\n\ndef es_primo(n):\n    if n &lt;= 1:\n        return False\n    for i in range(2, isqrt(n) + 1):\n        if n % i == 0:\n            return False\n    return True\n</code></pre>"},{"location":"material/S1/012/#factorizacion","title":"Factorizaci\u00f3n","text":""},{"location":"material/S1/012/#logica_5","title":"L\u00f3gica:","text":"<p>La factorizaci\u00f3n consiste en descomponer un n\u00famero en sus factores primos, es decir, en los n\u00fameros primos que multiplicados entre s\u00ed dan como resultado el n\u00famero original.</p> <p>El m\u00e9todo m\u00e1s com\u00fan es dividir el n\u00famero <code>n</code> por todos los posibles divisores desde 2 hasta $\\(\\sqrt{n}\\)$, y repetir mientras sea divisible. Si al final queda un n\u00famero mayor que 1, tambi\u00e9n es primo. Esta t\u00e9cnica se usa en criptograf\u00eda y an\u00e1lisis de n\u00fameros.</p> <pre><code>from math import isqrt\n\ndef factorizar(n):\n    resultado = set()\n    for i in range(1, int(sqrt(n)) + 1):\n        if n % i == 0:\n            resultado.add(i)\n            resultado.add(n // i)\n    return sorted(resultado)\n</code></pre>"},{"location":"material/S1/012/#criba-de-eratostenes","title":"Criba de Erat\u00f3stenes","text":""},{"location":"material/S1/012/#logica_6","title":"L\u00f3gica:","text":"<p>La Criba de Erat\u00f3stenes es un algoritmo antiguo y muy eficiente para encontrar todos los n\u00fameros primos hasta un n\u00famero dado <code>n</code>.</p> <p>Permite encontrar todos los n\u00fameros primos menores o iguales a un n\u00famero <code>n</code>. Se parte de una lista donde todos son considerados primos. Luego, se eliminan los m\u00faltiplos de cada n\u00famero primo empezando desde 2.</p>"},{"location":"material/S1/012/#parte-1-generar-la-lista-de-primos","title":"Parte 1: Generar la lista de primos","text":"<pre><code>def criba_lista(n):\n    lista_criba = [0] * (n - 1)  # de 2 a n\n    for i in range(2, n + 1):\n        if lista_criba[i - 2] != 0:\n            continue\n        for j in range(2 * i, n + 1, i):\n            lista_criba[j - 2] = i\n    print(lista_criba)  # 0 si es primo, o su menor divisor primo\n</code></pre>"},{"location":"material/S1/012/#parte-2-verificar-si-un-numero-es-primo-con-criba","title":"Parte 2: Verificar si un n\u00famero es primo con criba","text":"<pre><code>def criba_verificar_primo(n):\n    es_primo = [True for _ in range(n + 1)]\n    menor_primo = [-1 for _ in range(n + 1)]\n    es_primo[0] = es_primo[1] = False\n    for i in range(2, n + 1):\n        if es_primo[i]:\n            for j in range(i * i, n + 1, i):\n                es_primo[j] = False\n                if menor_primo[j] == -1:\n                    menor_primo[j] = i\n    print(es_primo[n], menor_primo[n])\n</code></pre>"},{"location":"material/S1/012/#calculo-de-distancia-entre-puntos","title":"C\u00e1lculo de distancia entre puntos","text":""},{"location":"material/S1/012/#logica_7","title":"L\u00f3gica:","text":"<p>La distancia entre dos puntos en el plano se calcula con el teorema de Pit\u00e1goras: \\(d = \\sqrt{(x_2 - x_1)^2 + (y_2 - y_1)^2}\\)</p>"},{"location":"material/S1/012/#codigo","title":"C\u00f3digo:","text":"<pre><code>from math import sqrt\n\ndef distancia(p1, p2):\n    x1, y1 = p1\n    x2, y2 = p2\n    return sqrt((x2 - x1)**2 + (y2 - y1)**2)\n</code></pre>"},{"location":"material/S1/012/#suma-maxima-de-un-subarreglo-algoritmo-de-kadane","title":"Suma M\u00e1xima de un Subarreglo (Algoritmo de Kadane)","text":""},{"location":"material/S1/012/#logica_8","title":"L\u00f3gica:","text":"<p>El algoritmo de Kadane permite encontrar la suma m\u00e1s alta posible de una secuencia continua dentro de un arreglo.</p>"},{"location":"material/S1/012/#codigo_1","title":"C\u00f3digo:","text":"<pre><code>def algoritmo_kadane(arr):\n    max_actual = max_total = arr[0]\n    for num in arr[1:]:\n        max_actual = max(num, max_actual + num)\n        max_total = max(max_total, max_actual)\n    return max_total\n</code></pre>"},{"location":"material/S1/013/","title":"Clase 13: Estrategias de resoluci\u00f3n de problemas y Complejidad temporal y espacial","text":""},{"location":"material/S1/013/#estrategias-mediante-ciclos","title":"Estrategias mediante Ciclos","text":""},{"location":"material/S1/013/#conceptos-clave","title":"Conceptos clave:","text":"<ul> <li>Uso eficiente de ciclos (<code>for</code>, <code>while</code>) para explorar soluciones.</li> <li>T\u00e9cnicas b\u00e1sicas para recorrer estructuras y verificar condiciones.</li> </ul>"},{"location":"material/S1/013/#en-que-consisten","title":"\u00bfEn qu\u00e9 consisten?","text":"<ul> <li>Repetici\u00f3n sistem\u00e1tica y controlada para evaluar m\u00faltiples posibilidades.</li> <li>Muy \u00fatil para problemas simples o de tama\u00f1o peque\u00f1o.</li> </ul>"},{"location":"material/S1/013/#estrategias-de-identificacion","title":"Estrategias de identificaci\u00f3n:","text":"<ul> <li>Se identifican cuando las soluciones requieren verificar casos particulares o iteraciones limitadas.</li> <li>Ejemplo t\u00edpico: evaluar condiciones de todos los elementos o combinaciones simples.</li> </ul>"},{"location":"material/S1/013/#ejemplo-clave","title":"Ejemplo clave:","text":"<p>Encontrar el m\u00e1ximo en un arreglo recorriendo cada elemento:</p> <pre><code>arr = [3, 7, 2, 9, 4]\nmaximo = arr[0]\nfor i in range(1, len(arr)):\n    if arr[i] &gt; maximo:\n        maximo = arr[i]\nprint(\"M\u00e1ximo:\", maximo)\n</code></pre>"},{"location":"material/S1/013/#algoritmos-de-fuerza-bruta-busqueda-exhaustiva","title":"Algoritmos de Fuerza Bruta (B\u00fasqueda Exhaustiva)","text":""},{"location":"material/S1/013/#conceptos-clave_1","title":"Conceptos clave:","text":"<ul> <li>Explorar todas las soluciones posibles.</li> <li>Asegurar respuesta correcta con m\u00e9todos sencillos, aunque potencialmente ineficientes.</li> </ul>"},{"location":"material/S1/013/#en-que-consisten_1","title":"\u00bfEn qu\u00e9 consisten?","text":"<ul> <li>Generar expl\u00edcitamente todas las soluciones posibles para elegir la mejor o contar soluciones.</li> <li>T\u00e9cnicas comunes: generaci\u00f3n de subconjuntos y permutaciones.</li> </ul>"},{"location":"material/S1/013/#estrategias-de-identificacion_1","title":"Estrategias de identificaci\u00f3n:","text":"<ul> <li>\u00datil cuando la entrada es suficientemente peque\u00f1a.</li> <li>Se usa cuando la exactitud es esencial y el tiempo lo permite.</li> </ul>"},{"location":"material/S1/013/#metodos-comunes","title":"M\u00e9todos comunes:","text":"<ul> <li>Generaci\u00f3n de subconjuntos (recursi\u00f3n, representaci\u00f3n en bits).</li> <li>Generaci\u00f3n de permutaciones (recursi\u00f3n, funciones como <code>next_permutation</code>).</li> </ul>"},{"location":"material/S1/013/#ejemplo-clave_1","title":"Ejemplo clave:","text":"<p>Generar todas las permutaciones de un conjunto peque\u00f1o de n\u00fameros:</p> <pre><code>from itertools import permutations\nfor p in permutations([1, 2, 3]):\n    print(p)\n</code></pre>"},{"location":"material/S1/013/#algoritmos-voraces-greedy-algorithms","title":"Algoritmos Voraces (Greedy Algorithms)","text":""},{"location":"material/S1/013/#conceptos-clave_2","title":"Conceptos clave:","text":"<ul> <li>Tomar decisiones localmente \u00f3ptimas esperando un resultado globalmente \u00f3ptimo.</li> <li>Soluciones r\u00e1pidas y eficientes cuando se garantiza su correcci\u00f3n.</li> </ul>"},{"location":"material/S1/013/#en-que-consisten_2","title":"\u00bfEn qu\u00e9 consisten?","text":"<ul> <li>Construir la soluci\u00f3n paso a paso escogiendo la opci\u00f3n \u00f3ptima inmediata.</li> </ul>"},{"location":"material/S1/013/#estrategias-de-identificacion_2","title":"Estrategias de identificaci\u00f3n:","text":"<ul> <li>\u00datil cuando las elecciones locales garantizan un \u00f3ptimo global (justificaci\u00f3n matem\u00e1tica clara).</li> <li>Ejemplos cl\u00e1sicos: problemas de monedas, planificaci\u00f3n, selecci\u00f3n de actividades.</li> </ul>"},{"location":"material/S1/013/#ejemplos-tipicos","title":"Ejemplos t\u00edpicos:","text":"<ul> <li>Problema de monedas (selecci\u00f3n de moneda m\u00e1s grande posible).</li> <li>Tareas y tiempos l\u00edmite (ordenar por duraci\u00f3n).</li> </ul>"},{"location":"material/S1/013/#ejemplo-clave_2","title":"Ejemplo clave:","text":"<p>Problema de monedas: seleccionar la menor cantidad posible de monedas para formar una suma dada.</p> <p>L\u00f3gica: Este algoritmo ordena las monedas en orden descendente y selecciona repetidamente la moneda m\u00e1s grande posible que no exceda el monto restante. Como siempre se elige la mayor moneda disponible, el n\u00famero de monedas usadas es m\u00ednimo (siempre que el conjunto de monedas cumpla con la propiedad de ser un sistema can\u00f3nico, como el del euro).</p> <pre><code>monedas = [1, 2, 5, 10, 20, 50, 100, 200]\nmonto = 520\nconteo = 0\n\nmonedas.sort(reverse=True)\nfor moneda in monedas:\n    while monto &gt;= moneda:\n        monto -= moneda\n        conteo += 1\n\nprint(\"N\u00famero m\u00ednimo de monedas:\", conteo)\n</code></pre>"},{"location":"material/S1/013/#divide-y-venceras","title":"Divide y Vencer\u00e1s","text":""},{"location":"material/S1/013/#conceptos-clave_3","title":"Conceptos clave:","text":"<ul> <li>Dividir problemas grandes en subproblemas m\u00e1s peque\u00f1os y manejables.</li> <li>Resolver subproblemas individualmente y combinar resultados.</li> </ul>"},{"location":"material/S1/013/#en-que-consisten_3","title":"\u00bfEn qu\u00e9 consisten?","text":"<ul> <li>Dividir el problema original en subproblemas del mismo tipo m\u00e1s peque\u00f1os.</li> <li>Resolver cada subproblema independientemente y combinarlos eficientemente.</li> </ul>"},{"location":"material/S1/013/#estrategias-de-identificacion_3","title":"Estrategias de identificaci\u00f3n:","text":"<ul> <li>Identificar que el problema se puede partir en partes m\u00e1s peque\u00f1as.</li> <li>Ejemplos cl\u00e1sicos: mergesort, b\u00fasqueda binaria, multiplicaci\u00f3n r\u00e1pida de matrices, problemas de suma con \"encuentro en el medio\".</li> </ul>"},{"location":"material/S1/013/#tecnicas-frecuentes","title":"T\u00e9cnicas frecuentes:","text":"<ul> <li>Encuentro en el medio: reduce complejidad exponencial significativamente.</li> </ul>"},{"location":"material/S1/013/#ejemplo-clave_3","title":"Ejemplo clave:","text":"<p>Algoritmo mergesort: dividir un arreglo, ordenar subarreglos y combinarlos.</p> <p>L\u00f3gica: El algoritmo divide recursivamente el arreglo en mitades hasta obtener subarreglos de un solo elemento. Luego, en la fase de combinaci\u00f3n, fusiona esos subarreglos en orden usando comparaciones. Esta estrategia logra un tiempo de ejecuci\u00f3n de O(n log n) en el peor caso.</p> <pre><code>def merge_sort(arr):\n    if len(arr) &gt; 1:\n        mid = len(arr) // 2\n        L = arr[:mid]\n        R = arr[mid:]\n\n        merge_sort(L)\n        merge_sort(R)\n\n        i = j = k = 0\n        while i &lt; len(L) and j &lt; len(R):\n            if L[i] &lt; R[j]:\n                arr[k] = L[i]\n                i += 1\n            else:\n                arr[k] = R[j]\n                j += 1\n            k += 1\n\n        while i &lt; len(L):\n            arr[k] = L[i]\n            i += 1\n            k += 1\n\n        while j &lt; len(R):\n            arr[k] = R[j]\n            j += 1\n            k += 1\n</code></pre>"},{"location":"material/S1/013/#vuelta-atras-backtracking","title":"Vuelta atr\u00e1s (Backtracking)","text":""},{"location":"material/S1/013/#conceptos-clave_4","title":"Conceptos clave:","text":"<ul> <li>Construcci\u00f3n incremental de soluciones con verificaci\u00f3n temprana de viabilidad.</li> <li>Exploraci\u00f3n profunda de soluciones parciales.</li> </ul>"},{"location":"material/S1/013/#en-que-consisten_4","title":"\u00bfEn qu\u00e9 consisten?","text":"<ul> <li>Explorar soluciones parciales hasta encontrar una completa v\u00e1lida.</li> <li>Se retrocede cuando una soluci\u00f3n parcial es inviable (\"poda\").</li> </ul>"},{"location":"material/S1/013/#estrategias-de-identificacion_4","title":"Estrategias de identificaci\u00f3n:","text":"<ul> <li>Adecuado cuando no se puede asegurar una soluci\u00f3n \u00f3ptima inmediata.</li> <li>Ejemplos t\u00edpicos: Problema de las n-reinas, caminos en cuadr\u00edcula.</li> </ul>"},{"location":"material/S1/013/#optimizacion-mediante-poda","title":"Optimizaci\u00f3n mediante poda:","text":"<ul> <li>Evitar exploraciones in\u00fatiles identificando condiciones que indiquen inviabilidad temprano.</li> </ul>"},{"location":"material/S1/013/#ejemplo-clave_4","title":"Ejemplo clave:","text":"<p>Problema de las 8 reinas en un tablero de ajedrez.</p> <p>L\u00f3gica: El algoritmo intenta colocar una reina en cada fila del tablero asegurando que no haya conflicto con reinas previamente colocadas en columnas o diagonales. Si no es posible, retrocede (backtrack) y prueba otra posici\u00f3n. Esta t\u00e9cnica permite recorrer todo el espacio de soluciones v\u00e1lidas.</p> <pre><code>n = 8\ncount = 0\ncol = [False] * n\ndiag1 = [False] * (2 * n - 1)\ndiag2 = [False] * (2 * n - 1)\n\ndef buscar(y):\n    global count\n    if y == n:\n        count += 1\n        return\n    for x in range(n):\n        if col[x] or diag1[x + y] or diag2[x - y + n - 1]:\n            continue\n        col[x] = diag1[x + y] = diag2[x - y + n - 1] = True\n        buscar(y + 1)\n        col[x] = diag1[x + y] = diag2[x - y + n - 1] = False\n\nbuscar(0)\nprint(\"Soluciones encontradas:\", count)\n</code></pre>"},{"location":"material/S1/013/#programacion-dinamica-dynamic-programming","title":"Programaci\u00f3n Din\u00e1mica (Dynamic Programming)","text":""},{"location":"material/S1/013/#conceptos-clave_5","title":"Conceptos clave:","text":"<ul> <li>Divisi\u00f3n del problema en subproblemas m\u00e1s peque\u00f1os solapados.</li> <li>Almacenamiento de resultados de subproblemas para evitar rec\u00e1lculos (memoizaci\u00f3n).</li> </ul>"},{"location":"material/S1/013/#en-que-consisten_5","title":"\u00bfEn qu\u00e9 consisten?","text":"<ul> <li>Resolver problemas mediante relaciones recursivas y almacenamiento eficiente de resultados.</li> <li>Combina precisi\u00f3n de b\u00fasqueda exhaustiva y eficiencia.</li> </ul>"},{"location":"material/S1/013/#estrategias-de-identificacion_5","title":"Estrategias de identificaci\u00f3n:","text":"<ul> <li>Subproblemas con solapamiento evidente y estructuras recursivas claras.</li> <li>Ejemplos cl\u00e1sicos: Problemas de monedas, subsecuencia creciente m\u00e1s larga, caminos \u00f3ptimos, problemas de mochila, distancia de edici\u00f3n.</li> </ul>"},{"location":"material/S1/013/#tecnicas-clave","title":"T\u00e9cnicas clave:","text":"<ul> <li>Formulaci\u00f3n recursiva clara.</li> <li>Memoizaci\u00f3n y construcci\u00f3n iterativa.</li> <li>Recuperaci\u00f3n de soluciones \u00f3ptimas con rastreo adicional.</li> </ul>"},{"location":"material/S1/013/#ejemplos","title":"Ejemplos:","text":"<ul> <li>Problema de monedas (m\u00ednimo n\u00famero y conteo de formas).</li> <li>Subsecuencia creciente m\u00e1s larga.</li> <li>Caminos \u00f3ptimos en cuadr\u00edcula.</li> <li>Problemas de mochila.</li> <li>Distancia de edici\u00f3n.</li> </ul>"},{"location":"material/S1/013/#ejemplo-clave_5","title":"Ejemplo clave:","text":"<p>Calcular la distancia de edici\u00f3n (distancia de Levenshtein) entre dos palabras.</p> <p>L\u00f3gica: Se usa programaci\u00f3n din\u00e1mica para calcular el n\u00famero m\u00ednimo de operaciones (inserci\u00f3n, eliminaci\u00f3n, sustituci\u00f3n) requeridas para transformar una cadena en otra. Se construye una matriz donde cada celda representa la distancia entre prefijos de las cadenas.</p> <pre><code>a = \"LOVE\"\nb = \"MOVIE\"\ndp = [[0] - (len(b) + 1) for _ in range(len(a) + 1)]\n\nfor i in range(len(a) + 1):\n    dp[i][0] = i\nfor j in range(len(b) + 1):\n    dp[0][j] = j\n\nfor i in range(1, len(a) + 1):\n    for j in range(1, len(b) + 1):\n        costo = 0 if a[i - 1] == b[j - 1] else 1\n        dp[i][j] = min(dp[i - 1][j] + 1,  # eliminar\n                       dp[i][j - 1] + 1,  # insertar\n                       dp[i - 1][j - 1] + costo)  # reemplazar\n\nprint(\"Distancia de edici\u00f3n:\", dp[len(a)][len(b)])\n</code></pre>"},{"location":"material/S1/013/#complejidad-temporal-y-espacial","title":"Complejidad temporal y espacial","text":"<p>La complejidad de un algoritmo es una medida que permite estimar su eficiencia en t\u00e9rminos del tiempo que tarda en ejecutarse (complejidad temporal) y la cantidad de memoria que requiere (complejidad espacial). Estas medidas se expresan habitualmente usando la notaci\u00f3n Big-O ($\\(O\\)$), que describe el comportamiento del algoritmo en funci\u00f3n del tama\u00f1o de la entrada \\(n\\).</p>"},{"location":"material/S1/013/#complejidad-temporal","title":"Complejidad temporal","text":"<p>La complejidad temporal mide cu\u00e1ntas operaciones realiza un algoritmo seg\u00fan el tama\u00f1o de entrada. Es importante especialmente cuando se dise\u00f1an algoritmos que deben ejecutarse en tiempos razonables incluso con entradas grandes. Para algoritmos recursivos, se puede estimar multiplicando el tiempo por llamada por el n\u00famero total de llamadas.</p> <p>F\u00f3rmula general (para recursi\u00f3n):</p> <pre><code>Tiempo por llamada \u00d7 N\u00famero de llamadas\n</code></pre>"},{"location":"material/S1/013/#clases-de-complejidad-temporal","title":"Clases de Complejidad Temporal","text":"<ol> <li> <p>$\\(O(1)\\)$: Tiempo constante.</p> </li> <li> <p>El tiempo no depende del tama\u00f1o de entrada.</p> </li> <li> <p>Ejemplo: acceder al valor de un \u00edndice en una lista: <code>x = arr[5]</code></p> </li> <li> <p>$\\(O(\\log{n})\\)$: Tiempo logar\u00edtmico.</p> </li> <li> <p>Reduce a la mitad la entrada en cada paso.</p> </li> <li> <p>Ejemplo: b\u00fasqueda binaria en una lista ordenada.</p> </li> <li> <p>$\\(O(\\sqrt{n})\\)$: Tiempo ra\u00edz cuadrada.</p> </li> <li> <p>Se usa, por ejemplo, en verificaciones hasta $\\(\\sqrt{n}\\)$, como en tests de primalidad.</p> </li> <li> <p>Ejemplo: comprobar si un n\u00famero es primo dividiendo hasta $\\(\\sqrt{n}\\)$.</p> </li> <li> <p>$\\(O(n)\\)$: Tiempo lineal.</p> </li> <li> <p>Recorre la entrada una vez.</p> </li> <li> <p>Ejemplo: encontrar el m\u00ednimo en un arreglo.</p> </li> <li> <p>$\\(O(n \\log{n})\\)$: Tiempo log-lineal.</p> </li> <li> <p>Algoritmo eficiente de ordenamiento como <code>merge sort</code> o <code>heap sort</code>.</p> </li> <li> <p>$\\(O(n^2)\\)$: Tiempo cuadr\u00e1tico.</p> </li> <li> <p>Dos ciclos anidados.</p> </li> <li> <p>Ejemplo: bubble sort o comprobar todos los pares posibles.</p> </li> <li> <p>$\\(O(n^3)\\)$: Tiempo c\u00fabico.</p> </li> <li> <p>Tres ciclos anidados.</p> </li> <li> <p>Ejemplo: multiplicaci\u00f3n de matrices con triple bucle.</p> </li> <li> <p>$\\(O(2^n)\\)$: Tiempo exponencial.</p> </li> <li> <p>Itera sobre todos los subconjuntos posibles.</p> </li> <li> <p>Ejemplo: resolver el problema de la mochila con backtracking.</p> </li> <li> <p>$\\(O(n!)\\)$*: Tiempo factorial.</p> </li> <li> <p>Considera todas las permutaciones posibles.</p> </li> <li>Ejemplo: resolver el problema del viajante (TSP) por fuerza bruta.</li> </ol>"},{"location":"material/S1/013/#complejidad-espacial","title":"Complejidad Espacial","text":"<p>La complejidad espacial se refiere a la cantidad de memoria adicional que necesita un algoritmo en funci\u00f3n del tama\u00f1o de entrada. Esto incluye estructuras de datos auxiliares, variables temporales, llamadas recursivas, entre otros.</p> <p>Un algoritmo puede ser r\u00e1pido pero utilizar mucha memoria, o puede ser m\u00e1s lento pero m\u00e1s eficiente en espacio. A menudo, hay un compromiso entre tiempo y espacio.</p>"},{"location":"material/S1/013/#clases-de-complejidad-espacial","title":"Clases de Complejidad Espacial","text":"<ol> <li> <p>$\\(O(1)\\)$: Espacio constante.</p> </li> <li> <p>Usa una cantidad fija de memoria, independientemente del tama\u00f1o de entrada.</p> </li> <li> <p>Ejemplo: invertir una cadena en el mismo arreglo sin estructuras auxiliares.</p> </li> <li> <p>$\\(O(\\log{n})\\)$: Espacio logar\u00edtmico.</p> </li> <li> <p>Aparece en recursi\u00f3n como en la b\u00fasqueda binaria recursiva.</p> </li> <li> <p>$\\(O(n)\\)$: Espacio lineal.</p> </li> <li> <p>Almacena datos proporcionales a la entrada.</p> </li> <li> <p>Ejemplo: copiar un arreglo o calcular suma de prefijos.</p> </li> <li> <p>$\\(O(n^2)\\)$: Espacio cuadr\u00e1tico.</p> </li> <li> <p>Utiliza una matriz o tabla de tama\u00f1o $\\(n \\times n\\)$.</p> </li> <li> <p>Ejemplo: algoritmo de programaci\u00f3n din\u00e1mica como distancia de edici\u00f3n o Floyd-Warshall.</p> </li> <li> <p>$\\(O(2^n)\\)$: Espacio exponencial.</p> </li> <li> <p>Guarda todos los subconjuntos o ramas posibles.</p> </li> <li>Ejemplo: resolver problemas de decisi\u00f3n con memoizaci\u00f3n sin poda.</li> </ol>"},{"location":"material/S1/014/","title":"Clase 14: Manejo de archivos, m\u00faltiples archivos, m\u00f3dulos y manejo de errores","text":""},{"location":"material/S1/014/#manejo-de-archivos-en-python","title":"Manejo de Archivos en Python","text":"<p>Python permite trabajar con archivos de texto mediante funciones integradas que permiten abrir, leer, escribir y cerrar archivos. La funci\u00f3n principal para esto es <code>open()</code>.</p>"},{"location":"material/S1/014/#formas-de-abrir-archivos","title":"Formas de abrir archivos","text":""},{"location":"material/S1/014/#usando-open-directamente","title":"Usando <code>open()</code> directamente:","text":"<pre><code>archivo = open('archivo.txt', 'r')\ncontenido = archivo.read()\narchivo.close()\n</code></pre> <p>Es necesario cerrar el archivo manualmente con <code>close()</code>.</p>"},{"location":"material/S1/014/#usando-with-open","title":"Usando <code>with open()</code>:","text":"<pre><code>with open('archivo.txt', 'r') as archivo:\n    contenido = archivo.read()\n</code></pre> <p>La ventaja es que el archivo se cierra autom\u00e1ticamente al finalizar el bloque <code>with</code>.</p>"},{"location":"material/S1/014/#modos-de-apertura","title":"Modos de apertura","text":"Modo Significado 'r' Lectura (por defecto) 'w' Escritura (sobrescribe) 'a' Agregar contenido al final 'x' Crear archivo, error si existe 'b' Binario (ej: 'rb', 'wb') '+' Lectura y escritura"},{"location":"material/S1/014/#lectura-de-archivos","title":"Lectura de archivos","text":"<ul> <li><code>read()</code>: lee todo el contenido como un string.</li> <li><code>readline()</code>: lee solo una l\u00ednea del archivo.</li> <li><code>readlines()</code>: devuelve una lista con todas las l\u00edneas.</li> </ul>"},{"location":"material/S1/014/#ejemplo","title":"Ejemplo:","text":"<pre><code>with open('datos.txt', 'r') as f:\n    todo = f.read()\n    f.seek(0)  # volver al inicio del archivo\n    una_linea = f.readline()\n    f.seek(0)\n    lineas = f.readlines()\n</code></pre>"},{"location":"material/S1/014/#escritura-de-archivos","title":"Escritura de archivos","text":"<ul> <li><code>write(texto)</code>: escribe el texto (sobrescribe si est\u00e1 en modo 'w').</li> <li><code>writelines(lista)</code>: escribe una lista de strings.</li> </ul> <pre><code>with open('salida.txt', 'w') as archivo:\n    archivo.write(\"Hola, mundo\\n\")\n    archivo.writelines([\"L\u00ednea 1\\n\", \"L\u00ednea 2\\n\"])\n</code></pre>"},{"location":"material/S1/014/#crear-o-agregar-archivos","title":"Crear o agregar archivos","text":"<ul> <li>Modo <code>'x'</code>: crea un archivo y lanza error si ya existe.</li> <li>Modo <code>'a'</code>: abre el archivo y agrega contenido al final.</li> <li>Modo <code>'w'</code>: crea el archivo o sobrescribe si ya existe.</li> </ul> <pre><code># Crear\nwith open('nuevo.txt', 'x') as f:\n    f.write(\"Archivo creado\")\n\n# Agregar\nwith open('log.txt', 'a') as f:\n    f.write(\"Nueva entrada\\n\")\n</code></pre>"},{"location":"material/S1/014/#manejo-de-paths-en-python","title":"Manejo de Paths en Python","text":""},{"location":"material/S1/014/#que-es-un-path","title":"\u00bfQu\u00e9 es un path?","text":"<p>En una computadora, un path (ruta) es una cadena de texto que indica la ubicaci\u00f3n de un archivo o carpeta dentro del sistema de archivos.</p> <p>Existen dos tipos principales de rutas:</p> <ul> <li> <p>Ruta absoluta: comienza desde la ra\u00edz del sistema de archivos. Ejemplo en Linux/macOS: <code>/home/usuario/documentos/archivo.txt</code>   o en Windows: <code>C:\\Usuarios\\usuario\\documentos\\archivo.txt</code></p> </li> <li> <p>Ruta relativa: se interpreta en relaci\u00f3n con la carpeta actual desde donde se ejecuta el programa. Ejemplo: <code>documentos/archivo.txt</code></p> </li> </ul> <p>Python permite trabajar con ambas rutas. Para evitar errores de compatibilidad entre sistemas (por ejemplo, separadores <code>/</code> vs <code>\\\\</code>), es importante usar herramientas como <code>os.path</code> o <code>pathlib</code>, que abstraen estas diferencias.</p>"},{"location":"material/S1/014/#usando-ospath","title":"Usando <code>os.path</code>","text":"<p>El m\u00f3dulo <code>os.path</code> proporciona funciones para construir, transformar y analizar rutas de archivos en forma de cadenas (<code>str</code>). Es compatible con versiones anteriores de Python y funciona en todos los sistemas operativos.</p> <pre><code>import os\n\nruta_relativa = \"archivo.txt\"\nruta_absoluta = os.path.abspath(ruta_relativa)  # Devuelve la ruta absoluta\nexiste = os.path.exists(ruta_relativa)          # Verifica si el archivo existe\ncarpeta = os.path.dirname(ruta_absoluta)        # Extrae el directorio\nnombre_archivo = os.path.basename(ruta_absoluta) # Extrae el nombre del archivo\n\nprint(\"Ruta absoluta:\", ruta_absoluta)\nprint(\"\u00bfExiste el archivo?\", existe)\nprint(\"Carpeta contenedora:\", carpeta)\nprint(\"Nombre del archivo:\", nombre_archivo)\n</code></pre>"},{"location":"material/S1/014/#ventajas","title":"Ventajas:","text":"<ul> <li>Compatible con Python 2 y 3</li> <li>Funciones simples para tareas comunes</li> </ul>"},{"location":"material/S1/014/#limitaciones","title":"Limitaciones:","text":"<ul> <li>Todas las operaciones son con cadenas (<code>str</code>)</li> <li>El c\u00f3digo puede ser m\u00e1s dif\u00edcil de leer y componer, especialmente al unir rutas</li> </ul>"},{"location":"material/S1/014/#usando-pathlib-moderno","title":"Usando <code>pathlib</code> (moderno)","text":"<p>El m\u00f3dulo <code>pathlib</code> permite trabajar con rutas como objetos (<code>Path</code>) en lugar de simples cadenas. Esto hace que el c\u00f3digo sea m\u00e1s legible, expresivo y compatible con m\u00faltiples plataformas.</p> <pre><code>from pathlib import Path\n\nruta = Path(\"archivo.txt\")\n\nprint(\"Ruta absoluta:\", ruta.resolve())  # Devuelve un Path absoluto\nprint(\"\u00bfExiste el archivo?\", ruta.exists())\nprint(\"Carpeta padre:\", ruta.parent)\nprint(\"Nombre del archivo:\", ruta.name)\n</code></pre> <p>Tambi\u00e9n se pueden leer y escribir archivos directamente desde objetos <code>Path</code>:</p> <pre><code># Escribir texto en un archivo\nruta.write_text(\"Hola desde pathlib\")\n\n# Leer el contenido del archivo\ncontenido = ruta.read_text()\nprint(\"Contenido:\", contenido)\n</code></pre> <p>Para unir carpetas o navegar directorios se usa <code>/</code>, no <code>+</code> ni <code>os.path.join()</code>:</p> <pre><code>nueva_ruta = Path(\"documentos\") / \"proyectos\" / \"informe.txt\"\nprint(nueva_ruta)  # documentos/proyectos/informe.txt\n</code></pre>"},{"location":"material/S1/014/#ventajas_1","title":"Ventajas:","text":"<ul> <li>Sintaxis moderna, clara y orientada a objetos</li> <li>M\u00e1s expresivo al construir rutas</li> <li>M\u00e9todos integrados para lectura y escritura</li> </ul>"},{"location":"material/S1/014/#limitaciones_1","title":"Limitaciones:","text":"<ul> <li>No est\u00e1 disponible en versiones anteriores a Python 3.4</li> </ul>"},{"location":"material/S1/014/#comparacion-breve","title":"Comparaci\u00f3n breve","text":"Tarea <code>os.path</code> <code>pathlib</code> Unir rutas <code>os.path.join(\"a\", \"b\")</code> <code>Path(\"a\") / \"b\"</code> Obtener nombre del archivo <code>os.path.basename(path)</code> <code>ruta.name</code> Obtener carpeta <code>os.path.dirname(path)</code> <code>ruta.parent</code> Verificar existencia <code>os.path.exists(path)</code> <code>ruta.exists()</code> Ruta absoluta <code>os.path.abspath(path)</code> <code>ruta.resolve()</code> Leer archivo <code>open(path).read()</code> <code>ruta.read_text()</code> Escribir archivo <code>open(path, 'w').write(texto)</code> <code>ruta.write_text(texto)</code>"},{"location":"material/S1/014/#manejo-de-errores-con-try-except","title":"Manejo de Errores con try-except","text":"<p>El bloque <code>try-except</code> permite manejar errores sin que el programa se detenga abruptamente.</p> <pre><code>try:\n    archivo = open('archivo_inexistente.txt')\nexcept FileNotFoundError:\n    print(\"El archivo no fue encontrado.\")\n</code></pre>"},{"location":"material/S1/014/#tabla-de-errores-comunes","title":"Tabla de errores comunes","text":"Error Cu\u00e1ndo ocurre <code>FileNotFoundError</code> Archivo no existe <code>PermissionError</code> Permiso denegado para acceder al archivo <code>IsADirectoryError</code> Se intent\u00f3 abrir un directorio como archivo <code>IOError</code> o <code>OSError</code> Error de E/S general <code>ValueError</code> Operaci\u00f3n inv\u00e1lida en archivos abiertos <code>TypeError</code> Tipo de dato incorrecto usado <code>ZeroDivisionError</code> Divisi\u00f3n entre cero <code>KeyError</code>, <code>IndexError</code> Acceso a clave o \u00edndice inexistente"},{"location":"material/S1/014/#uso-de-multiples-archivos","title":"Uso de M\u00faltiples Archivos","text":"<p>En programas grandes, es com\u00fan dividir el c\u00f3digo en varios archivos para mantener una estructura limpia.</p>"},{"location":"material/S1/014/#ejemplo_1","title":"Ejemplo:","text":"<ul> <li><code>principal.py</code>: archivo principal</li> <li><code>utilidades.py</code>: funciones auxiliares</li> </ul> <p>utilidades.py</p> <pre><code>def saludar(nombre):\n    return f\"Hola, {nombre}\"\n</code></pre> <p>principal.py</p> <pre><code>import utilidades\n\nnombre = input(\"Ingresa tu nombre: \")\nprint(utilidades.saludar(nombre))\n</code></pre>"},{"location":"material/S1/014/#modulos-externos","title":"M\u00f3dulos Externos","text":"<p>Python incluye muchos m\u00f3dulos externos en su biblioteca est\u00e1ndar. Se importan con la palabra <code>import</code>.</p>"},{"location":"material/S1/014/#ejemplo-con-math","title":"Ejemplo con <code>math</code>","text":"<pre><code>import math\n\nprint(math.sqrt(25))      # Ra\u00edz cuadrada\nprint(math.pi)            # Valor de pi\nprint(math.sin(math.pi))  # Seno de pi\n</code></pre> <p>Para instalar m\u00f3dulos externos que no est\u00e1n en la biblioteca est\u00e1ndar:</p> <pre><code>pip install nombre_modulo\n</code></pre>"},{"location":"material/S1/014/#ejercicio","title":"Ejercicio","text":""},{"location":"material/S1/014/#enunciado","title":"Enunciado","text":"<p>Desarrollar un programa de gesti\u00f3n de notas de estudiantes. El sistema debe permitir:</p> <ol> <li>Agregar estudiantes y sus notas (nombre y lista de notas).</li> <li>Guardar la informaci\u00f3n en un archivo <code>notas.txt</code>.</li> <li>Leer el archivo y calcular el promedio de cada estudiante.</li> <li>Mostrar un resumen de estudiantes aprobados y reprobados.</li> </ol> <p>Dividir el programa en dos archivos:</p> <ul> <li><code>main.py</code>: para la interfaz principal</li> <li><code>notas_utils.py</code>: para funciones auxiliares</li> </ul>"},{"location":"material/S1/015/","title":"Clase 15: Repaso para el examen","text":""},{"location":"material/S1/015/#ejercicio-1","title":"Ejercicio 1","text":"<p>Crear un programa que lea un archivo de texto llamado <code>numeros.txt</code> que contiene un n\u00famero por l\u00ednea. El programa debe:</p> <ul> <li>Leer los n\u00fameros.</li> <li>Imprimir la suma total y el promedio.</li> <li>Detectar y manejar errores:</li> <li>Si el archivo no existe, mostrar un mensaje.</li> <li>Si hay contenido no num\u00e9rico, ignorar esas l\u00edneas y continuar.</li> <li>Incluir una funci\u00f3n recursiva que calcule la suma de los n\u00fameros.</li> </ul> <p>Opcional: Si el archivo est\u00e1 vac\u00edo o no existe, generarlo con 10 n\u00fameros aleatorios entre 1 y 100.</p>"},{"location":"material/S1/015/#ejercicio-2","title":"Ejercicio 2","text":"<p>Crear una funci\u00f3n recursiva que determine si una palabra es un pal\u00edndromo. Luego, escribir un programa que:</p> <ul> <li>Lea palabras desde un archivo llamado <code>palabras.txt</code>, una por l\u00ednea.</li> <li>Imprima \u00fanicamente las palabras que son pal\u00edndromos.</li> <li>Use <code>try-except</code> para mostrar un mensaje si el archivo no existe.</li> </ul>"},{"location":"material/S1/015/#ejercicio-3","title":"Ejercicio 3","text":"<p>Desarrollar un peque\u00f1o sistema de tareas. El programa debe guardar y leer la informaci\u00f3n desde un archivo <code>tareas.txt</code>, donde cada l\u00ednea tiene el formato:</p> <pre><code>nombre;prioridad\n</code></pre> <p>El programa debe permitir al usuario:</p> <ol> <li>Ver todas las tareas.</li> <li>Agregar una nueva tarea (solicitar nombre y prioridad).</li> <li>Eliminar una tarea por nombre.</li> <li>Calcular la cantidad de tareas con prioridad alta utilizando una funci\u00f3n recursiva.</li> </ol> <p>Requisitos:</p> <ul> <li>Men\u00fa interactivo con un loop (<code>while</code>).</li> <li>Cada opci\u00f3n debe estar implementada como una funci\u00f3n separada.</li> <li>Manejo de errores con <code>try-except</code> para apertura y lectura del archivo.</li> <li>Validar que las prioridades sean correctas (<code>alta</code>, <code>media</code>, <code>baja</code>).</li> </ul>"},{"location":"material/S2/001/","title":"Clase 1: Clase de Repaso de Python","text":""},{"location":"material/S2/001/#strings","title":"Strings","text":"<p>Los strings (cadenas de texto) son secuencias de caracteres inmutables. Pueden incluir letras, s\u00edmbolos, n\u00fameros y espacios. Se declaran con comillas simples <code>'texto'</code>, dobles <code>\"texto\"</code> o triples <code>'''texto'''</code> para varias l\u00edneas.</p> <p>Se pueden manipular con operaciones como:</p> <ul> <li>Concatenaci\u00f3n: unir dos strings. Ejemplo: <code>\"Hola\" + \" Mundo\"</code></li> <li>Repetici\u00f3n: repetir un string varias veces. Ejemplo: <code>\"a\" * 3</code> \u2192 <code>\"aaa\"</code></li> <li>Acceso a caracteres: con \u00edndices. Ejemplo: <code>\"Hola\"[1] # 'o'</code></li> <li>Slicing: subcadenas. Ejemplo: <code>\"Hola\"[1:3] # \"ol\"</code></li> </ul> May\u00fasculas y min\u00fasculasEspacios y limpiezaBuscar y reemplazarDividir y unir <pre><code>s = \"Hola Mundo\"\nprint(s.upper())   # 'HOLA MUNDO'\nprint(s.lower())   # 'hola mundo'\n</code></pre> <pre><code>s = \"  texto con espacios  \"\nprint(s.strip())  # 'texto con espacios'\nprint(s.lstrip()) # elimina izquierda\nprint(s.rstrip()) # elimina derecha\n</code></pre> <pre><code>s = \"banana\"\nprint(s.replace(\"a\", \"o\"))   # 'bonono'\nprint(\"ana\" in s)            # True\nprint(s.count(\"a\"))          # 3\n</code></pre> <pre><code>s = \"uno,dos,tres\"\npartes = s.split(\",\")       # ['uno', 'dos', 'tres']\nprint(\"-\".join(partes))     # 'uno-dos-tres'\n</code></pre>"},{"location":"material/S2/001/#ejercicio","title":"Ejercicio","text":"<p>Escribir un programa que reciba una frase, elimine los signos de puntuaci\u00f3n, pase todo a min\u00fasculas y cuente cu\u00e1ntas veces aparece cada palabra.</p> <pre><code>frase = \"Hola, hola. \u00bfQu\u00e9 tal? Tal vez s\u00ed, tal vez no.\"\n\n# Resultado esperado:\n# hola -&gt; 2\n# tal -&gt; 2\n# vez -&gt; 2\n# s\u00ed -&gt; 1\n# qu\u00e9 -&gt; 1\n# no -&gt; 1\n</code></pre>"},{"location":"material/S2/001/#listas","title":"Listas","text":"<p>Las listas son estructuras de datos ordenadas, mutables y heterog\u00e9neas, es decir, pueden almacenar elementos de distintos tipos (enteros, strings, booleanos, otras listas, entre otros.). Se definen usando corchetes <code>[]</code> o el constructor <code>list()</code> y los elementos est\u00e1n separados por comas.</p> Agregar elementosEliminar elementosOrdenar y contarOtras operaciones \u00fatiles <pre><code>numeros = [1, 2, 3]\nnumeros.append(4)      # [1, 2, 3, 4]\nnumeros.insert(1, 99)  # [1, 99, 2, 3, 4]\n</code></pre> <pre><code>lista = [1, 2, 3, 2]\nlista.remove(2)    # elimina el primer 2 \u2192 [1, 3, 2]\nlista.pop()        # elimina el \u00faltimo \u2192 [1, 3]\n</code></pre> <pre><code>valores = [4, 1, 3, 2]\nvalores.sort()             # [1, 2, 3, 4]\nvalores.reverse()          # [4, 3, 2, 1]\nprint(valores.count(3))    # 1\n</code></pre> <pre><code>lista = [10, 20, 30]\nsuma = sum(lista)       # 60\nmaximo = max(lista)     # 30\nminimo = min(lista)     # 10\n</code></pre>"},{"location":"material/S2/001/#ejercicio_1","title":"Ejercicio","text":"<p>Convertir una lista de temperaturas en grados Celsius a Fahrenheit. Eliminar duplicados, redondear a un decimal y ordenar de mayor a menor.</p> <pre><code>celsius = [25, 30, 30, 10]\n\n# Resultado esperado:\n# [86.0, 77.0, 50.0]\n</code></pre>"},{"location":"material/S2/001/#estructura-de-control-if","title":"Estructura de control <code>if</code>","text":"<p>La instrucci\u00f3n <code>if</code> permite ejecutar c\u00f3digo s\u00f3lo si se cumple una condici\u00f3n. Puede complementarse con <code>elif</code> (condici\u00f3n alternativa) y <code>else</code> (caso por defecto).</p> <p>Las condiciones se eval\u00faan como valores booleanos (<code>True</code> o <code>False</code>).</p> <p>Ejemplo de sintaxis:</p> <pre><code>x = 15\nif x &lt; 10:\n    print(\"Menor que 10\")\nelif x == 10:\n    print(\"Es 10\")\nelse:\n    print(\"Mayor que 10\")\n</code></pre> Operadores relacionalesOperadores l\u00f3gicosEjemplo combinado <pre><code>==   # Igualdad\n!=   # Diferente\n&gt;    # Mayor que\n&lt;    # Menor que\n&gt;=   # Mayor o igual\n&lt;=   # Menor o igual\n</code></pre> <pre><code>and  # Ambas condiciones deben ser verdaderas\nor   # Al menos una condici\u00f3n debe ser verdadera\nnot  # Niega una condici\u00f3n\n</code></pre> <pre><code>edad = 20\nnota = 85\n\n    if edad &gt;= 18 and nota &gt;= 70:\n        print(\"Aprobado como adulto\")\n    else:\n        print(\"No cumple los requisitos\")\n</code></pre>"},{"location":"material/S2/001/#ejercicio_2","title":"Ejercicio","text":"<p>Escribir un programa que reciba tres notas. El estudiante reprueba si alguna nota es menor que 50 o si el promedio de las tres es menor que 70.</p> <pre><code>Entrada: 80, 45, 90  \u2192 Reprobado\nEntrada: 60, 70, 75  \u2192 Aprobado\n</code></pre>"},{"location":"material/S2/001/#for-loop","title":"<code>for</code> loop","text":"<p>El bucle <code>for</code> permite recorrer secuencias como listas, cadenas o rangos, y ejecutar un bloque de c\u00f3digo para cada elemento. Es una herramienta fundamental para procesar datos en colecciones.</p> Ejemplo b\u00e1sico<pre><code>for letra in \"Hola\":\n    print(letra)\n</code></pre>"},{"location":"material/S2/001/#ejemplos-comunes","title":"Ejemplos comunes","text":"Iterar sobre una lista<pre><code>frutas = [\"manzana\", \"pera\", \"uva\"]\nfor fruta in frutas:\n    print(fruta)\n</code></pre> Usar range()<pre><code>for i in range(3, 8):\n    print(i)  # Imprime del 3 al 7\n</code></pre> Acceder a \u00edndices con enumerate()<pre><code>colores = [\"rojo\", \"verde\", \"azul\"]\nfor indice, color in enumerate(colores):\n    print(f\"{indice}: {color}\")\n</code></pre> Iterar sobre un string<pre><code>nombre = \"python\"\nfor caracter in nombre:\n    print(caracter.upper())\n</code></pre>"},{"location":"material/S2/001/#ejercicio_3","title":"Ejercicio","text":"<p>Construir un histograma textual. Por cada n\u00famero en una lista, imprimir una l\u00ednea con esa cantidad de asteriscos <code>*</code>.</p> <pre><code># Entrada: [3, 7, 1]\n# Salida:\n# ***\n# *******\n# *\n</code></pre>"},{"location":"material/S2/001/#while-loop","title":"<code>while</code> loop","text":"<p>El bucle <code>while</code> permite repetir instrucciones mientras se cumpla una condici\u00f3n l\u00f3gica. Se utiliza cuando no se conoce de antemano cu\u00e1ntas repeticiones se deben realizar.</p> Bucle descendente<pre><code>contador = 3\nwhile contador &gt; 0:\n    print(contador)\n    contador -= 1\n</code></pre>"},{"location":"material/S2/001/#consideraciones-importantes","title":"Consideraciones importantes","text":"<ul> <li>Si la condici\u00f3n nunca deja de cumplirse, el bucle ser\u00e1 infinito.</li> <li>Se puede usar <code>break</code> para salir del bucle en un momento determinado.</li> <li>Tambi\u00e9n se puede usar <code>continue</code> para saltar a la siguiente iteraci\u00f3n sin ejecutar el resto del bloque.</li> </ul> Uso de <code>break</code>Uso de <code>continue</code> <pre><code>while True:\n    entrada = input(\"Escriba 'fin' para salir: \")\n    if entrada == \"fin\":\n        break\n</code></pre> <pre><code>numero = 0\nwhile numero &lt; 5:\n    numero += 1\n    if numero == 3:\n        continue  # salta el 3\n    print(numero)\n</code></pre>"},{"location":"material/S2/001/#ejercicio_4","title":"Ejercicio","text":"<p>Simular una calculadora interactiva. El programa debe permitir al usuario ingresar una operaci\u00f3n (<code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>) y dos n\u00fameros. El ciclo se repite hasta que el usuario escriba <code>\"salir\"</code> como operaci\u00f3n. Debe manejar el caso de divisi\u00f3n por cero.</p> <pre><code>Entrada:\noperaci\u00f3n: +\nn\u00famero1: 5\nn\u00famero2: 3\nResultado: 8\n\noperaci\u00f3n: salir\nFin del programa\n</code></pre>"},{"location":"material/S2/001/#tuplas","title":"Tuplas","text":"<p>Una tupla es una estructura de datos similar a una lista, pero inmutable. Sus elementos no pueden ser modificados una vez creada. Se define con par\u00e9ntesis <code>()</code> o con el constructor <code>tuple()</code>.</p> <p>Las tuplas son \u00fatiles para representar datos agrupados que no deben cambiar, como coordenadas, fechas o pares clave-valor temporales.</p> Ejemplo b\u00e1sico<pre><code>punto = (3, 4) # Inmutable\nx, y = punto\nprint(x)  # 3\nprint(y)  # 4\n</code></pre>"},{"location":"material/S2/001/#propiedades-importantes","title":"Propiedades importantes","text":"Acceso por \u00edndiceInmutabilidadTuplas de un s\u00f3lo elemento <pre><code>tupla = (\"lunes\", \"martes\", \"mi\u00e9rcoles\")\nprint(tupla[0])  # lunes\n</code></pre> <pre><code>dias = (\"lunes\", \"martes\")\n# Error: las tuplas no se pueden modificar\ndias[0] = \"domingo\"\n</code></pre> <pre><code>uno = (5,)  # la coma es necesaria\nprint(type(uno))  # &lt;class 'tuple'&gt;\n</code></pre>"},{"location":"material/S2/001/#ejercicio_5","title":"Ejercicio","text":"<p>Dada una lista de coordenadas (pares <code>(x, y)</code>), determinar cu\u00e1l est\u00e1 m\u00e1s cerca del origen <code>(0, 0)</code>.</p> <pre><code>coordenadas = [(3, 4), (1, 1), (5, 5)]\n\n# Resultado esperado: (1, 1)\n</code></pre>"},{"location":"material/S2/001/#diccionarios","title":"Diccionarios","text":"<p>Un diccionario es una colecci\u00f3n de pares clave-valor. Permite almacenar y acceder a valores usando claves personalizadas, como strings o n\u00fameros.</p> <p>Se define con llaves <code>{}</code>, y cada par clave-valor se separa por <code>:</code>.</p> Ejemplo b\u00e1sico<pre><code>persona = {\n    \"nombre\": \"Ana\",\n    \"edad\": 30\n}\n\nprint(persona[\"edad\"])  # 30\n</code></pre>"},{"location":"material/S2/001/#operaciones-comunes","title":"Operaciones comunes","text":"Agregar o modificar elementosRecorrer claves y valoresVerificar existencia de una claveEliminar elementos <pre><code>persona[\"edad\"] = 31           # Modifica edad\npersona[\"correo\"] = \"a@b.com\"  # Agrega nueva clave\n</code></pre> <pre><code>for clave, valor in persona.items():\n    print(clave, \"-&gt;\", valor)\n</code></pre> <pre><code>if \"nombre\" in persona:\n    print(\"Nombre registrado\")\n</code></pre> <pre><code>del persona[\"edad\"]\n</code></pre>"},{"location":"material/S2/001/#ejercicio_6","title":"Ejercicio","text":"<p>Guardar en un diccionario las calificaciones de varios estudiantes. Cada estudiante tiene una lista de notas. Se debe calcular el promedio de cada uno y mostrar:</p> <ul> <li>El estudiante con el mejor promedio</li> <li>El estudiante con el peor promedio</li> </ul> <pre><code># Entrada:\nnotas = {\n    \"Ana\": [90, 85, 88],\n    \"Luis\": [100, 100, 90],\n    \"Mar\u00eda\": [70, 65, 60]\n}\n\n# Resultado esperado:\n# Mejor promedio: Luis\n# Peor promedio: Mar\u00eda\n</code></pre>"},{"location":"material/S2/001/#funciones","title":"Funciones","text":"<p>Una funci\u00f3n es un bloque de c\u00f3digo reutilizable que realiza una tarea espec\u00edfica. Permite organizar el c\u00f3digo, evitar repeticiones y facilitar la lectura.</p> <p>Se define con la palabra clave <code>def</code>, se le da un nombre, se indican los par\u00e1metros entre par\u00e9ntesis y se coloca el bloque indentado.</p> Definici\u00f3n b\u00e1sica<pre><code>def saludar(nombre):\n    return f\"Hola, {nombre}\"\n\nprint(saludar(\"Luis\"))  # 'Hola, Luis'\n</code></pre>"},{"location":"material/S2/001/#otras-posibilidades","title":"Otras posibilidades","text":"Funci\u00f3n sin par\u00e1metros<pre><code>def mostrar_menu():\n    print(\"1. Iniciar\")\n    print(\"2. Salir\")\n</code></pre> Funci\u00f3n con varios par\u00e1metros<pre><code>def sumar(a, b):\n    return a + b\n</code></pre> Valores por defecto<pre><code>def saludar(nombre=\"invitado\"):\n    return f\"Hola, {nombre}\"\n</code></pre> Funciones que no retornan (procedimientos)<pre><code>def imprimir_saludo(nombre):\n    print(f\"Hola, {nombre}\")\n</code></pre>"},{"location":"material/S2/001/#ejercicio_7","title":"Ejercicio","text":"<p>Escribir una funci\u00f3n que determine si una frase es un pangrama, es decir, si contiene todas las letras del abecedario al menos una vez (no importa el orden).</p> <pre><code>frase = \"El veloz murcielago hindu comia feliz cardillo y kiwi\"\n# Resultado esperado: True\n</code></pre>"},{"location":"material/S2/001/#recursividad","title":"Recursividad","text":"<p>La recursividad es una t\u00e9cnica en la que una funci\u00f3n se llama a s\u00ed misma para resolver un problema dividi\u00e9ndolo en subproblemas m\u00e1s peque\u00f1os. Cada llamada reduce el problema hasta llegar a un caso base, que detiene la recursi\u00f3n.</p> Ejemplo cl\u00e1sico<pre><code>def factorial(n):\n    if n == 0:\n        return 1\n    return n * factorial(n - 1)\n</code></pre>"},{"location":"material/S2/001/#consideraciones-importantes_1","title":"Consideraciones importantes","text":"Caso baseEvitar recursi\u00f3n infinita <pre><code># Toda funci\u00f3n recursiva debe tener una condici\u00f3n de salida\n# que evite llamadas infinitas\n\ndef cuenta_regresiva(n):\n    if n == 0:\n        return\n    print(n)\n    cuenta_regresiva(n - 1)\n</code></pre> <pre><code># Olvidar el caso base puede generar un error por l\u00edmite de recursi\u00f3n\n\ndef infinito():\n    return infinito()  # Error: RecursionError\n</code></pre>"},{"location":"material/S2/001/#ejercicio_8","title":"Ejercicio","text":"<p>Implementar una funci\u00f3n recursiva que reciba un n\u00famero entero <code>n</code> y genere todas las cadenas binarias posibles de longitud <code>n</code>. La funci\u00f3n debe devolver una lista con todas las combinaciones generadas.</p> <pre><code>Entrada: n = 3\nSalida: ['000', '001', '010', '011', '100', '101', '110', '111']\n</code></pre>"},{"location":"material/S2/002/","title":"Clase 2: Introducci\u00f3n a OOP","text":"<p>En esta clase, se introduce el tema de programaci\u00f3n orientada a objetos (OOP por sus siglas en ingl\u00e9s).</p>"},{"location":"material/S2/002/#que-es-la-programacion-orientada-a-objetos","title":"\u00bfQu\u00e9 es la programaci\u00f3n orientada a objetos?","text":"<p>La programaci\u00f3n orientada a objetos corresponde a un paradigma de programaci\u00f3n; es decir, una forma de escribir c\u00f3digo que organiza la l\u00f3gica en objetos.</p> <p>Un objeto:</p> <ul> <li>Representa algo del mundo real o un concepto.</li> <li>Tiene atributos (datos que describen su estado).</li> <li>Tiene m\u00e9todos (acciones que puede realizar).</li> </ul> <p>Ejemplo</p> <p>Un objeto <code>Perro</code> podr\u00eda tener atributos como <code>nombre</code> y <code>edad</code>, y m\u00e9todos como <code>ladrar()</code> o <code>correr()</code>.</p>"},{"location":"material/S2/002/#por-que-usar-oop","title":"\u00bfPor qu\u00e9 usar OOP?","text":"<p>La OOP sirve para:</p> <ol> <li>Modelar problemas de forma m\u00e1s cercana a la realidad.</li> <li>Organizar el c\u00f3digo en bloques reutilizables.</li> <li>Facilitar el mantenimiento y la expansi\u00f3n del programa.</li> </ol>"},{"location":"material/S2/002/#conceptos-clave","title":"Conceptos clave","text":"Concepto Definici\u00f3n Clase Plantilla o molde que define c\u00f3mo ser\u00e1n los objetos (qu\u00e9 datos tendr\u00e1n y qu\u00e9 podr\u00e1n hacer). Objeto Una instancia de una clase. Cada objeto tiene sus propios valores de atributos. Atributo Variable que almacena datos dentro de un objeto. M\u00e9todo Funci\u00f3n que pertenece a un objeto y que puede usar o modificar sus atributos. <code>__init__</code> M\u00e9todo especial de inicializaci\u00f3n; define y da valor inicial a atributos <code>self</code> Referencia a esta instancia; permite acceder a su estado <p>Errores frecuentes</p> <ul> <li>Olvidar <code>self</code> como primer par\u00e1metro en m\u00e9todos de instancia.</li> <li>Declarar atributos fuera de <code>__init__</code> y pretender que existan en todas las instancias.</li> <li>Tratar la clase como si fuera un objeto (p. ej., usar <code>Persona.nombre</code> esperando el nombre de cada persona).</li> </ul>"},{"location":"material/S2/002/#diagrama-conceptual-del-ejemplo-a-realizar","title":"Diagrama conceptual del ejemplo a realizar","text":"<pre><code>classDiagram\n    class Persona {\n      - nombre: str\n      - edad: int\n      + saludar(): void\n    }</code></pre> <pre><code>sequenceDiagram\n    participant Main\n    participant Clase as Clase Persona\n    participant p1 as Objeto p1\n    participant p2 as Objeto p2\n\n    Main-&gt;&gt;Clase: crear(\"Ana\", 21)\n    activate Clase\n    Clase--&gt;&gt;Main: retorna p1\n    deactivate Clase\n\n    Main-&gt;&gt;Clase: crear(\"Luis\", 22)\n    activate Clase\n    Clase--&gt;&gt;Main: retorna p2\n    deactivate Clase\n\n    Main-&gt;&gt;p1: p1.saludar()\n    Main-&gt;&gt;p2: p2.saludar()</code></pre>"},{"location":"material/S2/002/#ejemplo-minimo-en-python","title":"Ejemplo m\u00ednimo en Python","text":"<pre><code>class Persona:\n    def __init__(self, nombre, edad):  # (1)!\n        self.nombre = nombre           # (2)!\n        self.edad = edad\n\n    def saludar(self):                 # (3)!\n        print(f\"Hola, soy {self.nombre} y tengo {self.edad} a\u00f1os.\")  # (4)!\n\n# Crear (instanciar) objetos\np1 = Persona(\"Ana\", 21)                # (5)!\np2 = Persona(\"Luis\", 22)\n\n# Usar m\u00e9todos de instancia\np1.saludar()\np2.saludar()                           # (6)!\n</code></pre> <ol> <li><code>__init__</code> se ejecuta al crear cada objeto; sirve para inicializar atributos.</li> <li><code>self.nombre</code> y <code>self.edad</code> son atributos de instancia; pertenecen a esta persona.</li> <li><code>saludar</code> es un m\u00e9todo de instancia: siempre define <code>self</code> como primer par\u00e1metro.</li> <li>Dentro del m\u00e9todo, <code>self</code> permite acceder al estado de esta instancia.</li> <li><code>p1</code> es un objeto con <code>nombre=\"Ana\"</code>, <code>edad=21</code>.</li> <li>La llamada <code>obj.metodo()</code> ejecuta el comportamiento en ese objeto.</li> </ol>"},{"location":"material/S2/002/#estado-independiente-por-objeto","title":"Estado independiente por objeto","text":"<pre><code>class Contador:\n    def __init__(self, valor_inicial=0):\n        self.valor = valor_inicial\n\nc1 = Contador()\nc2 = Contador(10)\n\nc1.valor += 5\nc2.valor += 1\n\nprint(c1.valor)  # (1)!\nprint(c2.valor)  # (2)!\nprint(id(c1) != id(c2))  # (3)!\n</code></pre> <ol> <li>5</li> <li>11</li> <li><code>True</code>: objetos distintos</li> </ol> <p>Concepto clave</p> <p>Aunque <code>c1</code> y <code>c2</code> provienen de la misma clase, cada objeto almacena su propio estado.  Cambiar <code>c1.valor</code> no afecta <code>c2.valor</code>, y viceversa.</p>"},{"location":"material/S2/002/#metodos-de-instancia-consultar-y-mutar","title":"M\u00e9todos de instancia: consultar y mutar","text":"<p>Los m\u00e9todos se suelen dividir en estos dos tipos por funcoinalidad.</p> Consultar (no cambia estado)Mutar (cambia estado) <pre><code>class Rectangulo:\n    def __init__(self, base, altura):\n        self.base = base\n        self.altura = altura\n\n    def area(self):                # consulta\n        return self.base * self.altura\n\nr = Rectangulo(3, 4)\nprint(r.area())  # (1)!\n</code></pre> <ol> <li>12</li> </ol> <pre><code>class Rectangulo:\n    def __init__(self, base, altura):\n        self.base = base\n        self.altura = altura\n\n    def escalar(self, factor):     # mutaci\u00f3n\n        self.base *= factor\n        self.altura *= factor\n\nr = Rectangulo(3, 4)\nr.escalar(2)\nprint(r.base, r.altura)  # 6 8\n</code></pre> <p>Buenas pr\u00e1cticas con m\u00e9todos</p> <ul> <li>Un m\u00e9todo, una responsabilidad clara.</li> <li>Nombres descriptivos (verbos para acciones).</li> <li>Evitar efectos secundarios en m\u00e9todos que aparentan consultar.</li> </ul>"},{"location":"material/S2/002/#ejemplo-de-metodos-de-instancia","title":"Ejemplo de m\u00e9todos de instancia","text":"<pre><code>class Producto:\n    def __init__(self, nombre: str, precio: float, stock: int = 0):\n        self.nombre = nombre\n        self.precio = precio\n        self.stock = stock\n\n    def disponible(self) -&gt; bool:\n        return self.stock &gt; 0\n\n    def reponer(self, cantidad: int) -&gt; None:\n        self.stock += cantidad\n\n    def vender(self, cantidad: int) -&gt; bool:\n        if cantidad &lt;= self.stock:\n            self.stock -= cantidad\n            return True\n        return False\n\na = Producto(\"Cuaderno\", 900.0, 5)\nb = Producto(\"Bol\u00edgrafo\", 350.0)\n\nprint(a.disponible(), b.disponible()) # (1)!\nb.reponer(10)\nprint(b.disponible())                 # (2)!\n</code></pre> <ol> <li><code>True</code>, <code>False</code></li> <li><code>True</code></li> </ol> <p>Preguntas r\u00e1pidas</p> <ol> <li>\u00bfQu\u00e9 rol cumple <code>__init__</code> en la creaci\u00f3n de objetos?</li> <li>\u00bfC\u00f3mo accede un m\u00e9todo al estado de su propia instancia?</li> <li>\u00bfQu\u00e9 diferencia hay entre un m\u00e9todo que consulta y uno que muta?</li> </ol>"},{"location":"material/S2/002/#errores-tipicos-y-como-evitarlos","title":"Errores t\u00edpicos y c\u00f3mo evitarlos","text":"Olvidar <code>self</code>Atributos fuera de <code>__init__</code>No colocar <code>self</code> en la definici\u00f3n de atributos <pre><code>class A:\n    def f():           # Falta `self`\n        print(\"hola\")\n</code></pre> <p>Soluci\u00f3n: <code>def f(self): ...</code></p> <pre><code>class A:\n    def set_x(self, x):\n        self.x = x  # si no se llama, otras rutas podr\u00edan no crear\n</code></pre> <p>Mejor: crear <code>self.x</code> en <code>__init__</code>, y luego modificarlo en m\u00e9todos.</p> <pre><code>class A:\n    def __init__(self, x):\n        x = x  # asigna a una variable local, no al atributo\n</code></pre> <p>Correcto: <code>self.x = x</code></p>"},{"location":"material/S2/002/#ejercicios-guiados","title":"Ejercicios guiados","text":""},{"location":"material/S2/002/#ejercicio-1","title":"Ejercicio 1","text":"Enunciado: LibroSoluci\u00f3n <p>Cree una clase <code>Libro</code> con atributos de instancia <code>titulo</code> (str) y <code>paginas</code> (int).</p> <p>A\u00f1ada:</p> <ul> <li><code>descripcion()</code>: consultor que retorna <code>\"&lt;titulo&gt; (&lt;paginas&gt; p\u00e1gs.)\"</code>.</li> <li><code>agregar_paginas(n)</code>: mutador que suma <code>n</code> si <code>n &gt; 0</code>.</li> </ul> <p>Instancie dos libros y demuestre que sus estados son independientes.</p> <pre><code>class Libro:\n    def __init__(self, titulo: str, paginas: int):\n        self.titulo = titulo\n        self.paginas = paginas\n\n    def descripcion(self) -&gt; str:           # consultor\n        return f\"{self.titulo} ({self.paginas} p\u00e1gs.)\"\n\n    def agregar_paginas(self, n: int) -&gt; None:  # mutador\n        if n &gt; 0:\n            self.paginas += n\n\nl1 = Libro(\"POO en Python\", 180)\nl2 = Libro(\"Algoritmos\", 250)\n\nl1.agregar_paginas(20)\n\nprint(l1.descripcion()) # (1)!\nprint(l2.descripcion()) # (2)!\n</code></pre> <ol> <li>POO en Python (200 p\u00e1gs.)</li> <li>Algoritmos (250 p\u00e1gs.)</li> </ol>"},{"location":"material/S2/002/#ejercicio-2","title":"Ejercicio 2","text":"Enunciado: Term\u00f3metroSoluci\u00f3n <p>Cree <code>Termometro</code> con atributo <code>celsius</code> (float).</p> <p>A\u00f1ada:</p> <ul> <li><code>a_fahrenheit()</code>: consultor que retorna la conversi\u00f3n.</li> <li><code>ajustar(delta)</code>: mutador que suma <code>delta</code> al valor en \u00b0C. Instancie dos term\u00f3metros y evidencie que mutar uno no afecta el otro.</li> </ul> <pre><code>class Termometro:\n    def __init__(self, celsius: float):\n        self.celsius = celsius\n\n    def a_fahrenheit(self) -&gt; float:    # consultor\n        return self.celsius * 9/5 + 32\n\n    def ajustar(self, delta: float) -&gt; None:  # mutador\n        self.celsius += delta\n\nt1 = Termometro(20.0)\nt2 = Termometro(30.0)\n\nt1.ajustar(5.0)\n\nprint(t1.celsius, t1.a_fahrenheit()) # (1)!\nprint(t2.celsius, t2.a_fahrenheit()) # (2)!\n</code></pre> <ol> <li><code>25.0 77.0</code></li> <li><code>30.0 86.0</code></li> </ol>"},{"location":"material/S2/003/","title":"Clase 3: Encapsulamiento de datos y Herencia en Python","text":"<p>En esta clase, se van a cubrir los temas de encapsulamiento de datos y herencia en la programaci\u00f3n orientada a objetos (OOP) en el lenguaje de programaci\u00f3n Python.</p>"},{"location":"material/S2/003/#que-es-el-encapsulamiento","title":"\u00bfQu\u00e9 es el encapsulamiento?","text":"<p>El encapsulamiento es un principio de la programaci\u00f3n orientada a objetos que busca ocultar los detalles internos de una clase y exponer \u00fanicamente una interfaz p\u00fablica para interactuar con ella.</p> <p>Esto permite:</p> <ul> <li>Proteger la integridad de los datos.</li> <li>Validar valores antes de asignarlos.</li> <li>Facilitar cambios internos sin afectar a quien usa la clase.</li> </ul>"},{"location":"material/S2/003/#convenciones-de-acceso-en-python","title":"Convenciones de acceso en Python","text":"<p>Aunque Python no impone privacidad estricta, existen convenciones para indicar la intenci\u00f3n de uso de un atributo:</p> Tipo de acceso Sintaxis Significado P\u00fablico <code>atributo</code> Se puede acceder desde fuera de la clase. Privado <code>_atributo</code> Convenci\u00f3n: uso interno o en subclases, no deber\u00eda usarse fuera directamente. <p>Aclaraci\u00f3n sobre su uso</p> <p>En Python, el encapsulamiento es por convenci\u00f3n, no por restricci\u00f3n estricta. Es responsabilidad del programador respetar estas reglas. En el curso NO es obligatorio el uso de estas convenciones.</p>"},{"location":"material/S2/003/#uso-basico-de-property-y-atributosetter","title":"Uso b\u00e1sico de <code>@property</code> y <code>@atributo.setter</code>","text":"<p>En Python, <code>@property</code> permite definir un getter (lectura controlada) para un atributo, mientras que <code>@atributo.setter</code> a\u00f1ade un setter (asignaci\u00f3n controlada con validaci\u00f3n).</p> <pre><code>class Persona:\n    def __init__(self, nombre: str, edad: int):\n        self._nombre = nombre\n        self._edad = 0\n        self.edad = edad # (1)!\n\n    @property            # (2)!\n    def edad(self) -&gt; int:\n        return self._edad\n\n    @edad.setter         # (3)!\n    def edad(self, valor: int):\n        if valor &lt; 0:\n            raise ValueError(\"La edad no puede ser negativa\")\n        self._edad = valor\n</code></pre> <ol> <li>Usa el setter que se cre\u00f3 (<code>@edad.setter</code>) para asignar el valor inicial.</li> <li>Getter: devuelve el valor encapsulado (<code>self._edad</code>) cuando se accede con <code>persona.edad</code>.</li> <li>Setter: valida antes de asignar, cuando se hace <code>self.edad = valor</code>.</li> </ol> <p>Acceso al atributo</p> <pre><code>p = Persona(\"Ana\", 20)\nprint(p.edad)   # (1)!\np.edad = 25     # (2)!\n</code></pre> <ol> <li>Llama autom\u00e1ticamente al getter.</li> <li>Llama autom\u00e1ticamente al setter.</li> </ol> <p>En el diagrama a continuaci\u00f3n se ilustra el funcionamiento del getter y setter.</p> <pre><code>flowchart LR\n  A[p.edad] --&gt;|lectura| B[getter edad]\n  B --&gt; C[_edad]\n  D[p.edad = x] --&gt;|escritura| E[setter edad]\n  E --&gt; C</code></pre> <p>Aclaraci\u00f3n importante</p> <ul> <li>Aqu\u00ed existen dos cosas distintas:<ul> <li><code>self._edad</code>: el atributo real donde se guarda el valor.</li> <li><code>edad</code>: una propiedad (getter/setter) que act\u00faa como \u201cinterfaz p\u00fablica\u201d.</li> </ul> </li> <li>Cuando se escribe <code>persona.edad</code>, Python llama al getter.</li> <li>Cuando se escribe <code>persona.edad = 30</code>, Python llama al setter que valida y luego asigna en <code>self._edad</code>.</li> <li>Es decir: <code>edad</code> no es una variable nueva, sino un \u201cpuente\u201d controlado hacia <code>_edad</code>.</li> </ul> <p>Ideas clave</p> <ul> <li>Usar <code>@property</code> para exponer atributos de solo lectura.</li> <li>Evitar exponer atributos internos directamente.</li> </ul>"},{"location":"material/S2/003/#comparacion-con-getters-y-setters-clasicos","title":"Comparaci\u00f3n con getters y setters cl\u00e1sicos","text":"Con @propertyCon getters/setters tradicionales <pre><code>class Persona:\n    def __init__(self, nombre: str):\n        self._nombre = nombre\n\n    @property      # (1)!\n    def nombre(self) -&gt; str:\n        return self._nombre\n\n    @nombre.setter # (2)!\n    def nombre(self, nuevo: str):\n        if not nuevo:\n            raise ValueError(\"El nombre no puede ser vac\u00edo\")\n        self._nombre = nuevo\n</code></pre> <ol> <li><code>@property</code> indica que es un m\u00e9todo para exponer el atributo privado <code>_nombre</code>.</li> <li>Permite cambiar el atributo privado <code>_nombre</code>.</li> </ol> <pre><code>class Persona:\n    def __init__(self, nombre: str):\n        self._nombre = nombre\n\n    def get_nombre(self):\n        return self._nombre\n\n    def set_nombre(self, nuevo):\n        self._nombre = nuevo\n</code></pre> <p>Uso en el curso</p> <p>Pueden utilizar cualquiera de las dos formas para crear m\u00e9todos getters/setters. Los puristas de Python prefieren usar <code>@property</code> y <code>@atributo.setter</code> por su simplicidad a la hora de asignar.</p>"},{"location":"material/S2/003/#ejercicio-guiado","title":"Ejercicio guiado","text":"EnunciadoSoluci\u00f3n <p>Cree una clase <code>Producto</code> que tenga:</p> <ul> <li>Atributo <code>nombre</code> (string).</li> <li>Atributo privado <code>_precio</code> (float).</li> </ul> <p>Implemente:</p> <ul> <li><code>@property precio</code> con validaci\u00f3n para que no pueda ser negativo.</li> <li>M\u00e9todo <code>aplicar_descuento(porcentaje)</code> que reduzca el precio.</li> </ul> <pre><code>class Producto:\n    def __init__(self, nombre: str, precio: float):\n        self.nombre = nombre\n        self._precio = 0\n        self.precio = precio   # usa el setter\n\n    @property\n    def precio(self) -&gt; float:\n        return self._precio\n\n    @precio.setter\n    def precio(self, valor: float):\n        if valor &lt; 0:\n            raise ValueError(\"El precio no puede ser negativo\")\n        self._precio = valor\n\n    def aplicar_descuento(self, porcentaje: float) -&gt; None:\n        self.precio = self.precio * (1 - porcentaje/100)\n\np = Producto(\"Libro\", 100)\np.aplicar_descuento(10)\nprint(p.precio)  # 90.0\n</code></pre> <p>Pregunta r\u00e1pida</p> <p>\u00bfPor qu\u00e9 se recomienda usar <code>@property</code> y <code>@atributo.setter</code> en lugar de exponer directamente atributos internos?</p>"},{"location":"material/S2/003/#que-es-herencia","title":"\u00bfQu\u00e9 es herencia?","text":"<p>La herencia permite definir una clase nueva a partir de otra existente para reutilizar atributos y m\u00e9todos, as\u00ed como especializar comportamientos donde sea necesario.</p>"},{"location":"material/S2/003/#concepto-y-sintaxis-basica","title":"Concepto y sintaxis b\u00e1sica","text":"<p>La herencia define una relaci\u00f3n entre una clase hija y una clase padre. La clase hija recibe atributos y m\u00e9todos de la clase padre y puede a\u00f1adir nuevos o modificarlos.</p> <pre><code>classDiagram\n    class Animal {\n      +nombre: str\n      +__init__(nombre)\n      +info() str\n    }\n    class Perro {\n      +nombre: str\n      +raza: str\n      +__init__(nombre, raza)\n      +info() str\n      +ladrar() str\n    }\n    Animal --&gt; Perro</code></pre> Ejemplo b\u00e1sico<pre><code>class Animal:\n    def __init__(self, nombre: str):      # (1)!\n        self.nombre = nombre\n\n    def info(self) -&gt; str:                # (2)!\n        return f\"Animal: {self.nombre}\"\n\nclass Perro(Animal):                      # (3)!\n    def __init__(self, nombre: str, raza: str):\n        super().__init__(nombre)          # (4)!\n        self.raza = raza\n\n    def ladrar(self) -&gt; str:\n        return \"Guau!\"\n\np = Perro(\"Luna\", \"Border Collie\")\nprint(p.info())                           # (5)!\nprint(p.ladrar())                         # (6)!\n</code></pre> <ol> <li>Constructor del padre con estado com\u00fan.</li> <li>M\u00e9todo disponible para todas las subclases.</li> <li>Declaraci\u00f3n de herencia: <code>Perro(Animal)</code>.</li> <li><code>super()</code> asegura la inicializaci\u00f3n del padre.</li> <li>Usa m\u00e9todo heredado</li> <li>M\u00e9todo propio</li> </ol>"},{"location":"material/S2/003/#acceso-a-atributos-y-metodos-del-padre","title":"Acceso a atributos y m\u00e9todos del padre","text":"<p>Una subclase accede a los atributos inicializados por el padre y a sus m\u00e9todos p\u00fablicos. Es importante mantener invariantes del padre al extender la clase hija.</p> <pre><code>class Animal:\n    def __init__(self, nombre: str):\n        self.nombre = nombre              # (1)!\n        self._salud = 100                 # (2)!\n\n    def info(self) -&gt; str:\n        return f\"{self.nombre} (salud={self._salud})\"\n\nclass Gato(Animal):\n    def curar(self, puntos: int) -&gt; None: # (3)!\n        self._salud = min(100, self._salud + puntos)\n\ng = Gato(\"Garfield\")\nprint(g.info())   # lee estado definido en el padre\ng.curar(5)\nprint(g.info())   # modifica estado protegido del padre\n</code></pre> <ol> <li>Atributo p\u00fablico accesible desde la hija.</li> <li>Atributo \u201cprotegido\u201d por convenci\u00f3n (<code>_salud</code>).</li> <li>La subclase agrega comportamiento sin romper la interfaz del padre.</li> </ol>"},{"location":"material/S2/003/#sobrescritura-de-metodos","title":"Sobrescritura de m\u00e9todos","text":"<p>La subclase puede redefinir m\u00e9todos del padre para especializar el comportamiento. Conviene mantener la misma firma y, si corresponde, extender el comportamiento con <code>super()</code>.</p> Reemplazo completoExtensi\u00f3n con <code>super()</code> <pre><code>class Animal:\n    def descripcion(self) -&gt; str:\n        return \"Ser vivo del reino Animal\"\n\nclass Ave(Animal):\n    def descripcion(self) -&gt; str:             # (1)!\n        return \"Ave: vertebrado con plumas\"\n</code></pre> <ol> <li>Sobrescritura que reemplaza el comportamiento.</li> </ol> <pre><code>class Animal:\n    def descripcion(self) -&gt; str:\n        return \"Ser vivo del reino Animal\"\n\nclass Murcielago(Animal):\n    def descripcion(self) -&gt; str:             # (1)!\n        base = super().descripcion()          # (2)!\n        return f\"{base}. Es un mam\u00edfero que vuela\"\n</code></pre> <ol> <li>Mismo nombre para coherencia.</li> <li>Extiende el comportamiento sin descartarlo.</li> </ol> <p>Buena pr\u00e1ctica</p> <p>Evitar cambiar par\u00e1metros, tipos de datos y significado del m\u00e9todo sobrescrito.</p>"},{"location":"material/S2/003/#uso-de-super","title":"Uso de <code>super()</code>","text":"<p><code>super()</code> permite invocar m\u00e9todos del padre (t\u00edpicamente <code>__init__</code>) para evitar duplicaci\u00f3n y garantizar inicializaci\u00f3n y l\u00f3gica com\u00fan.</p> <pre><code>sequenceDiagram\n    participant Main\n    participant Hija as Perro.__init__\n    participant Padre as Animal.__init__\n\n    Main-&gt;&gt;Hija: crear Perro(\"Luna\",\"Border\")\n    Hija-&gt;&gt;Padre: super().__init__(\"Luna\")\n    Padre--&gt;&gt;Hija: estado base inicializado\n    Hija--&gt;&gt;Main: objeto Perro listo</code></pre> Constructor encadenadoExtender l\u00f3gica del padre <pre><code>class Animal:\n    def __init__(self, nombre: str):\n        self.nombre = nombre\n        self._salud = 100\n\nclass Perro(Animal):\n    def __init__(self, nombre: str, raza: str):\n        super().__init__(nombre)      # (1)!\n        self.raza = raza              # (2)!\n</code></pre> <ol> <li>Inicializa el estado com\u00fan.</li> <li>Completa el estado espec\u00edfico de la subclase.</li> </ol> <pre><code>class Sensor:\n    def __init__(self):\n        self._calibrado = False\n\n    def calibrar(self):\n        self._calibrado = True\n\nclass SensorTemperatura(Sensor):\n    def __init__(self):\n        super().__init__()\n        self._offset = None\n\n    def calibrar(self):\n        super().calibrar()             # (1)!\n        self._offset = 0.05            # (2)!\n</code></pre> <ol> <li>Conserva la l\u00f3gica original.</li> <li>A\u00f1ade detalles propios de la subclase.</li> </ol> <p>Consejo</p> <p>Llamar a <code>super().__init__()</code> al inicio del constructor de la subclase para asegurar que el objeto queda en estado v\u00e1lido antes de a\u00f1adir campos propios.</p>"},{"location":"material/S2/003/#herencia-multiple-y-mro-method-resolution-order","title":"Herencia m\u00faltiple y MRO (Method Resolution Order)","text":"<p>Python permite que una clase herede de m\u00faltiples padres. En estos casos, es necesario definir un orden de resoluci\u00f3n de m\u00e9todos (MRO, Method Resolution Order), que indica en qu\u00e9 orden se buscan los atributos y m\u00e9todos.</p> Ejemplo b\u00e1sico con MRO<pre><code>class RastreableMixin:\n    def etiqueta(self) -&gt; str:\n        return \"[Rastreable]\"\n\nclass Animal:\n    def etiqueta(self) -&gt; str:\n        return \"[Animal]\"\n\nclass PerroRastreador(RastreableMixin, Animal):   # (1)!\n    pass\n\nobj = PerroRastreador()\nprint(obj.etiqueta())                 # (2)!\nprint(PerroRastreador.__mro__)        # (3)!\n</code></pre> <ol> <li>El orden de herencia importa: primero <code>RastreableMixin</code>, luego <code>Animal</code>.</li> <li>Python busca <code>etiqueta</code> en <code>RastreableMixin</code> antes que en <code>Animal</code>.</li> <li>El MRO se muestra como:    <code>(PerroRastreador, RastreableMixin, Animal, object)</code>.</li> </ol> <p>Definici\u00f3n de MRO</p> <p>El MRO es la ruta que sigue Python para buscar atributos y m\u00e9todos en una jerarqu\u00eda. Se calcula usando el algoritmo C3 linearization, que garantiza orden consistente.</p>"},{"location":"material/S2/003/#uso-cooperativo-de-super","title":"Uso cooperativo de <code>super()</code>","text":"<p>El problema t\u00edpico ocurre cuando varias clases heredan de un mismo ancestro y se busca resolver todas las referencias.</p> Versi\u00f3n no cooperativaVersi\u00f3n cooperativa <pre><code>class A:\n    def saludar(self): print(\"Soy A\")\n\nclass B(A):\n    def saludar(self):\n        print(\"Soy B\")\n\nclass C(A):\n    def saludar(self):\n        print(\"Soy C\")\n\nclass D(B, C):\n    pass\n\nd = D()\nd.saludar()\nprint(D.__mro__)\n</code></pre> <ul> <li>El MRO es: <code>(D, B, C, A, object)</code>.</li> <li><code>D().saludar()</code> llama primero a <code>B.saludar</code>.</li> <li>Si <code>B</code> no llama a <code>super()</code>, nunca se ejecutar\u00e1 <code>C.saludar</code> ni <code>A.saludar</code>.</li> </ul> <p>Para que todos los m\u00e9todos en la jerarqu\u00eda se ejecuten una sola vez, cada clase debe llamar a <code>super()</code>.</p> <pre><code>class B(A):\n    def saludar(self):\n        print(\"Soy B\")\n        super().saludar()   # Coopera\n\nclass C(A):\n    def saludar(self):\n        print(\"Soy C\")\n        super().saludar()   # Coopera\n\nclass D(B, C):\n    def saludar(self):\n        print(\"Soy D\")\n        super().saludar()   # Coopera\n\nd = D()\nd.saludar()\n</code></pre> <p>Salida:</p> <pre><code>Soy D\nSoy B\nSoy C\nSoy A\n</code></pre> <p>Si no se usa <code>super()</code></p> <ul> <li>El flujo puede cortar la cadena de llamadas, y algunas clases nunca se ejecutan.</li> <li>Especialmente \u00fatil en resoluci\u00f3n de atributos.</li> <li>Esto rompe el principio de inicializaci\u00f3n cooperativa.</li> <li>En jerarqu\u00edas complejas, el error es dif\u00edcil de detectar.</li> </ul>"},{"location":"material/S2/003/#ejercicio-guiado_1","title":"Ejercicio guiado","text":"EnunciadoSoluci\u00f3n <p>Crear una jerarqu\u00eda de clases para representar empleados:</p> <ul> <li><code>Persona</code> con m\u00e9todo <code>presentar</code>.</li> <li><code>Empleado</code> (hereda de <code>Persona</code>) que redefine <code>presentar</code>.</li> <li><code>Profesor</code> y <code>Investigador</code> (ambos heredan de <code>Empleado</code>) con su propia versi\u00f3n de <code>presentar</code>.</li> <li><code>ProfesorInvestigador</code> (hereda de <code>Profesor</code> y <code>Investigador</code>).</li> </ul> <p>Analizar:</p> <ol> <li>\u00bfCu\u00e1l es el MRO de <code>ProfesorInvestigador</code>?</li> <li>\u00bfQu\u00e9 salida se obtiene al llamar <code>presentar()</code> con y sin <code>super()</code> en cada clase?</li> </ol> <pre><code>class Persona:\n    def presentar(self): print(\"Soy una persona\")\n\nclass Empleado(Persona):\n    def presentar(self):\n        print(\"Soy empleado\")\n        super().presentar()\n\nclass Profesor(Empleado):\n    def presentar(self):\n        print(\"Soy profesor\")\n        super().presentar()\n\nclass Investigador(Empleado):\n    def presentar(self):\n        print(\"Soy investigador\")\n        super().presentar()\n\nclass ProfesorInvestigador(Profesor, Investigador):\n    def presentar(self):\n        print(\"Soy profesor-investigador\")\n        super().presentar()\n\npi = ProfesorInvestigador()\npi.presentar()\nprint(ProfesorInvestigador.__mro__)\n</code></pre> <p>Salida:</p> <pre><code>Soy profesor-investigador\nSoy profesor\nSoy investigador\nSoy empleado\nSoy una persona\n</code></pre> <p>MRO:</p> <pre><code>(ProfesorInvestigador, Profesor, Investigador, Empleado, Persona, object)\n</code></pre>"},{"location":"material/S2/003/#mixins","title":"Mixins","text":"<p>Un Mixin es una clase que aporta funcionalidades espec\u00edficas y peque\u00f1as que se a\u00f1aden a otra clase por medio de herencia m\u00faltiple. No representan relaciones jer\u00e1rquicas, sino capacidades adicionales.</p> <pre><code>class ConLogMixin:\n    def log(self, msg: str) -&gt; None:\n        print(f\"[LOG] {msg}\")\n\nclass Pedido(ConLogMixin):\n    def procesar(self):\n        self.log(\"Procesando pedido\u2026\")\n</code></pre> <p>Uso recomendado</p> <ul> <li>Que el nombre termine con <code>Mixin</code> para reconocerlo f\u00e1cilmente.</li> <li>Dise\u00f1ar Mixins con una sola responsabilidad.</li> <li>Evitar l\u00f3gica de inicializaci\u00f3n compleja en Mixins.</li> </ul>"},{"location":"material/S2/003/#composicion-vs-herencia","title":"Composici\u00f3n vs. Herencia","text":"<p>En muchos casos conviene usar composici\u00f3n en lugar de herencia.</p> <pre><code>flowchart LR\n  A[CarritoCompra] --&gt;|tiene| B[Lista de Productos]\n  C[Rectangulo] --&gt;|es| D[Figura]</code></pre> <ul> <li>Herencia: Un <code>Rectangulo</code> es una <code>Figura</code>.</li> <li>Composici\u00f3n: Un <code>CarritoCompra</code> tiene una lista de productos.</li> </ul>"},{"location":"material/S2/004/","title":"Clase 4: Ejercicio de OOP","text":"<p>En esta clase, se va a realizar un ejercicio amplio de programaci\u00f3n orientada a objetos, donde se implementen los conceptos vistos en las semanas anteriores en una soluci\u00f3n al enunciado a continuaci\u00f3n.</p>"},{"location":"material/S2/004/#descripcion","title":"Descripci\u00f3n","text":"<p>Desarrollar un programa en Python que simule un sistema de gesti\u00f3n de biblioteca, aplicando:</p> <ul> <li>Clases y objetos</li> <li>Herencia: <code>Material</code> \u2192 <code>Libro</code>, <code>Revista</code></li> <li>Encapsulamiento con <code>@property</code> y validaciones</li> <li>Composici\u00f3n: una <code>Biblioteca</code> tiene materiales y pr\u00e9stamos</li> <li>Men\u00fa interactivo que opera sobre un repositorio interno de materiales</li> </ul> <p>Estructura del proyecto</p> <ul> <li><code>modelos.py</code>: definiciones de clases (<code>Material</code>, <code>Libro</code>, <code>Revista</code>, <code>Biblioteca</code>).</li> <li><code>main.py</code>: interacci\u00f3n con la persona usuaria (men\u00fa), validaciones de entrada y llamadas a m\u00e9todos.</li> </ul>"},{"location":"material/S2/004/#requisitos-de-diseno","title":"Requisitos de dise\u00f1o","text":""},{"location":"material/S2/004/#clase-material-base","title":"Clase <code>Material</code> (base)","text":"Elemento Detalle Atributos - <code>_titulo: str</code>- <code>_codigo: str</code> M\u00e9todos <code>info() \u2192 str</code>: Retorna <code>\"{_titulo} ({_codigo})\"</code> Validaci\u00f3n <code>_titulo</code> y <code>_codigo</code> no pueden ser vac\u00edos (setter)"},{"location":"material/S2/004/#clase-libro-hereda-de-material","title":"Clase <code>Libro</code> (hereda de <code>Material</code>)","text":"Elemento Detalle Atributos <code>_autor: str</code> (encapsulado con <code>@property</code>) M\u00e9todos <code>info()</code> sobrescribe para incluir autor Validaci\u00f3n <code>autor</code> no puede ser vac\u00edo"},{"location":"material/S2/004/#clase-revista-hereda-de-material","title":"Clase <code>Revista</code> (hereda de <code>Material</code>)","text":"Elemento Detalle Atributos <code>_editorial: str</code> (encapsulado con <code>@property</code>) M\u00e9todos <code>info()</code> sobrescribe para incluir editorial Validaci\u00f3n <code>editorial</code> no puede ser vac\u00eda"},{"location":"material/S2/004/#clase-biblioteca","title":"Clase <code>Biblioteca</code>","text":"Elemento Detalle Atributos - <code>materiales: dict[str, Material]</code>- <code>_prestamos: dict[str, str]</code> (clave: c\u00f3digo, valor: usuario) M\u00e9todos - <code>agregar_material(material)</code> (sin c\u00f3digos duplicados)- <code>listar_materiales() \u2192 list[Material]</code>- <code>obtener_material(codigo) \u2192 Material or None</code>- <code>prestar(codigo, usuario) \u2192 bool</code> (verifica existencia y disponibilidad)- <code>devolver(codigo) \u2192 bool</code>- <code>prestamos_activos() \u2192 list[tuple[codigo, Material, usuario]]</code>"},{"location":"material/S2/004/#menu-interactivo","title":"Men\u00fa interactivo","text":"Opci\u00f3n Acci\u00f3n 1 Registrar libro 2 Registrar revista 3 Ver materiales 4 Prestar material 5 Devolver material 6 Ver pr\u00e9stamos activos 7 Salir Ejemplo de uso esperado <pre><code>--- Men\u00fa ---\n1. Registrar libro\n2. Registrar revista\n3. Ver materiales disponibles\n4. Prestar material\n5. Devolver material\n6. Ver pr\u00e9stamos activos\n7. Salir\n\nOpci\u00f3n: 1\nT\u00edtulo: Cien a\u00f1os de soledad\nC\u00f3digo: L001\nAutor: Gabriel Garc\u00eda M\u00e1rquez\nLibro registrado con \u00e9xito.\n\nOpci\u00f3n: 4\nC\u00f3digo del material: L001\nUsuario: Ana\nPr\u00e9stamo realizado.\n\nOpci\u00f3n: 6\nPr\u00e9stamos:\n - L001 \u2192 Cien a\u00f1os de soledad (L001) | Usuario: Ana\n</code></pre>"},{"location":"material/S2/004/#diagrama-de-clases","title":"Diagrama de clases","text":"<pre><code>classDiagram\n  class Material {\n    _titulo: str\n    _codigo: str\n    titulo: str\n    codigo: str\n    info() str\n  }\n\n  class Libro {\n    _autor: str\n    autor: str\n    info() str\n  }\n\n  class Revista {\n    _editorial: str\n    editorial: str\n    info() str\n  }\n\n  class Biblioteca {\n    materiales: dict[str, Material]\n    _prestamos: dict[str, str]\n    agregar_material(m: Material) bool\n    listar_materiales() list[Material]\n    obtener_material(codigo: str) Material | None\n    prestar(codigo: str, usuario: str) bool\n    devolver(codigo: str) bool\n    prestamos_activos() list[(str, Material, str)]\n  }\n\n  Material &lt;|-- Libro\n  Material &lt;|-- Revista\n  Biblioteca \"1\" o-- \"*\" Material</code></pre>"},{"location":"material/S2/004/#solucion","title":"Soluci\u00f3n","text":"<code>modelos.py</code><code>main.py</code> <pre><code>\"\"\"\nM\u00f3dulo de modelos para el sistema de biblioteca.\nContiene:\n    - Material (base),\n    - Libro\n    - Revista\n    - Biblioteca\n\"\"\"\n\nfrom typing import Dict, List, Optional, Tuple\n\n\nclass Material:\n    \"\"\"Clase base para materiales bibliogr\u00e1ficos.\"\"\"\n\n    def __init__(self, titulo: str, codigo: str) -&gt; None:\n        self._titulo = \"\"\n        self._codigo = \"\"\n        self.titulo = titulo\n        self.codigo = codigo\n\n    # Titulo\n    @property\n    def titulo(self) -&gt; str:\n        return self._titulo\n\n    @titulo.setter\n    def titulo(self, valor: str) -&gt; None:\n        if not isinstance(valor, str) or not valor.strip():\n            raise ValueError(\"El t\u00edtulo no puede ser vac\u00edo.\")\n        self._titulo = valor.strip()\n\n    # C\u00f3digo\n    @property\n    def codigo(self) -&gt; str:\n        return self._codigo\n\n    @codigo.setter\n    def codigo(self, valor: str) -&gt; None:\n        if not isinstance(valor, str) or not valor.strip():\n            raise ValueError(\"El c\u00f3digo no puede ser vac\u00edo.\")\n        self._codigo = valor.strip()\n\n    def info(self) -&gt; str:\n        \"\"\"Retorna una representaci\u00f3n corta del material.\"\"\"\n        return f\"{self.titulo} ({self.codigo})\"\n\n\nclass Libro(Material):\n    \"\"\"Representa un libro con autor.\"\"\"\n\n    def __init__(self, titulo: str, codigo: str, autor: str) -&gt; None:\n        super().__init__(titulo, codigo)\n        self._autor = \"\"\n        self.autor = autor\n\n    @property\n    def autor(self) -&gt; str:\n        return self._autor\n\n    @autor.setter\n    def autor(self, valor: str) -&gt; None:\n        if not isinstance(valor, str) or not valor.strip():\n            raise ValueError(\"El autor no puede ser vac\u00edo.\")\n        self._autor = valor.strip()\n\n    def info(self) -&gt; str:\n        return f\"{self.titulo} ({self.codigo}) \u2014 Autor: {self.autor}\"\n\n\nclass Revista(Material):\n    \"\"\"Representa una revista con editorial.\"\"\"\n\n    def __init__(self, titulo: str, codigo: str, editorial: str) -&gt; None:\n        super().__init__(titulo, codigo)\n        self._editorial = \"\"\n        self.editorial = editorial        # setter valida\n\n    @property\n    def editorial(self) -&gt; str:\n        return self._editorial\n\n    @editorial.setter\n    def editorial(self, valor: str) -&gt; None:\n        if not isinstance(valor, str) or not valor.strip():\n            raise ValueError(\"La editorial no puede ser vac\u00eda.\")\n        self._editorial = valor.strip()\n\n    def info(self) -&gt; str:\n        return f\"{self.titulo} ({self.codigo}) \u2014 Editorial: {self.editorial}\"\n\n\nclass Biblioteca:\n    \"\"\"\n    Repositorio de materiales + control de pr\u00e9stamos.\n    Composici\u00f3n: la biblioteca 'tiene' materiales y pr\u00e9stamos.\n    \"\"\"\n\n    def __init__(self) -&gt; None:\n        # Diccionario por c\u00f3digo \u2192 Material para b\u00fasquedas O(1).\n        self.materiales: Dict[str, Material] = {}\n        # Tabla de pr\u00e9stamos: c\u00f3digo \u2192 usuario.\n        self._prestamos: Dict[str, str] = {}\n\n    # --- Gesti\u00f3n de materiales ---\n\n    def agregar_material(self, material: Material) -&gt; bool:\n        \"\"\"Agrega un material si el c\u00f3digo no existe. Retorna True si se agreg\u00f3.\"\"\"\n        if not isinstance(material, Material):\n            raise TypeError(\"Se requiere una instancia de Material o subclase.\")\n        if material.codigo in self.materiales:\n            return False                     # Evita duplicados.\n        self.materiales[material.codigo] = material\n        return True\n\n    def listar_materiales(self) -&gt; List[Material]:\n        \"\"\"Lista de materiales (no ordenada).\"\"\"\n        return list(self.materiales.values())\n\n    def obtener_material(self, codigo: str) -&gt; Optional[Material]:\n        \"\"\"Obtiene un material por c\u00f3digo, o None si no existe.\"\"\"\n        return self.materiales.get((codigo or \"\").strip())\n\n    # --- Gesti\u00f3n de pr\u00e9stamos ---\n\n    def prestar(self, codigo: str, usuario: str) -&gt; bool:\n        \"\"\"\n        Intenta prestar el material 'codigo' a 'usuario'.\n        Reglas: debe existir y no estar ya prestado.\n        \"\"\"\n        if not isinstance(usuario, str) or not usuario.strip():\n            raise ValueError(\"El usuario no puede ser vac\u00edo.\")\n        codigo = (codigo or \"\").strip()\n        if codigo not in self.materiales:\n            return False                  # No existe.\n        if codigo in self._prestamos:\n            return False                  # Ya prestado.\n        self._prestamos[codigo] = usuario.strip()\n        return True\n\n    def devolver(self, codigo: str) -&gt; bool:\n        \"\"\"Devuelve un material; True si se encontraba prestado.\"\"\"\n        codigo = (codigo or \"\").strip()\n        if codigo in self._prestamos:\n            del self._prestamos[codigo]\n            return True\n        return False\n\n    def prestamos_activos(self) -&gt; List[Tuple[str, Material, str]]:\n        \"\"\"\n        Retorna tuplas (codigo, material, usuario) para cada pr\u00e9stamo activo.\n        \"\"\"\n        salida: List[Tuple[str, Material, str]] = []\n        for codigo, usuario in self._prestamos.items():\n            mat = self.materiales.get(codigo)\n            if mat is not None:           # Verificaci\u00f3n por robustez.\n                salida.append((codigo, mat, usuario))\n        return salida\n\n    # --- Operaci\u00f3n segura de cambio de c\u00f3digo ---\n\n    def actualizar_codigo(self, codigo_actual: str, nuevo_codigo: str) -&gt; bool:\n        \"\"\"\n        Actualiza el **c\u00f3digo** de un material ya registrado y re-indexa todas las estructuras.\n        - Falla si `codigo_actual` no existe o `nuevo_codigo` ya est\u00e1 en uso.\n        - Si el material estaba prestado, migra el pr\u00e9stamo al nuevo c\u00f3digo.\n        \"\"\"\n        ca = (codigo_actual or \"\").strip()\n        nc = (nuevo_codigo or \"\").strip()\n        if not ca or not nc:\n            return False\n        if ca not in self.materiales:\n            return False\n        if nc in self.materiales:\n            return False\n\n        material = self.materiales.pop(ca)\n        material.codigo = nc\n        self.materiales[nc] = material\n\n        if ca in self._prestamos:\n            self._prestamos[nc] = self._prestamos.pop(ca)\n\n        return True\n</code></pre> <pre><code>\"\"\"\nPunto de entrada del sistema de biblioteca.\nMen\u00fa textual para registrar materiales (libros, revistas), prestar, devolver y listar.\n\"\"\"\n\nfrom modelos import Biblioteca, Libro, Revista\n\n# Instancia \u00fanica de la biblioteca para toda la sesi\u00f3n.\nbib = Biblioteca()\n\n\n# -------------------- utilidades de entrada --------------------\n\ndef leer_no_vacio(mensaje: str) -&gt; str:\n    \"\"\"Lee una cadena no vac\u00eda desde consola.\"\"\"\n    while True:\n        texto = input(mensaje).strip()\n        if texto:\n            return texto\n        print(\"La entrada no puede ser vac\u00eda.\")\n\n\ndef leer_opcion(mensaje: str, minimo: int, maximo: int) -&gt; int:\n    \"\"\"Lee una opci\u00f3n entera dentro de un rango [minimo, maximo].\"\"\"\n    while True:\n        try:\n            op = int(input(mensaje))\n            if minimo &lt;= op &lt;= maximo:\n                return op\n            print(f\"Ingrese una opci\u00f3n entre {minimo} y {maximo}.\")\n        except ValueError:\n            print(\"Entrada inv\u00e1lida: se esperaba un n\u00famero entero.\")\n\n\n# -------------------- acciones del men\u00fa --------------------\n\ndef registrar_libro() -&gt; None:\n    \"\"\"Crea y registra un libro en la biblioteca.\"\"\"\n    titulo = leer_no_vacio(\"T\u00edtulo: \")\n    codigo = leer_no_vacio(\"C\u00f3digo: \")\n    autor = leer_no_vacio(\"Autor: \")\n    try:\n        ok = bib.agregar_material(Libro(titulo, codigo, autor))\n        print(\"Libro registrado con \u00e9xito.\" if ok else \"Ya existe un material con ese c\u00f3digo.\")\n    except ValueError as e:\n        print(f\"Error: {e}\")\n\n\ndef registrar_revista() -&gt; None:\n    \"\"\"Crea y registra una revista en la biblioteca.\"\"\"\n    titulo = leer_no_vacio(\"T\u00edtulo: \")\n    codigo = leer_no_vacio(\"C\u00f3digo: \")\n    editorial = leer_no_vacio(\"Editorial: \")\n    try:\n        ok = bib.agregar_material(Revista(titulo, codigo, editorial))\n        print(\"Revista registrada con \u00e9xito.\" if ok else \"Ya existe un material con ese c\u00f3digo.\")\n    except ValueError as e:\n        print(f\"Error: {e}\")\n\n\ndef ver_materiales() -&gt; None:\n    \"\"\"Lista todos los materiales registrados.\"\"\"\n    mats = bib.listar_materiales()\n    if not mats:\n        print(\"No hay materiales registrados.\")\n        return\n    print(\"Materiales:\")\n    for m in mats:\n        print(f\" - {m.info()}\")\n\n\ndef prestar_material() -&gt; None:\n    \"\"\"Solicita pr\u00e9stamo de un material por c\u00f3digo.\"\"\"\n    codigo = leer_no_vacio(\"C\u00f3digo del material: \")\n    usuario = leer_no_vacio(\"Usuario: \")\n    ok = bib.prestar(codigo, usuario)\n    if ok:\n        print(\"Pr\u00e9stamo realizado.\")\n    else:\n        existe = bib.obtener_material(codigo) is not None\n        print(\"Ya est\u00e1 prestado.\" if existe else \"No existe un material con ese c\u00f3digo.\")\n\n\ndef devolver_material() -&gt; None:\n    \"\"\"Devuelve un material por c\u00f3digo.\"\"\"\n    codigo = leer_no_vacio(\"C\u00f3digo del material: \")\n    ok = bib.devolver(codigo)\n    print(\"Devoluci\u00f3n realizada.\" if ok else \"Ese material no estaba prestado.\")\n\n\ndef ver_prestamos_activos() -&gt; None:\n    \"\"\"Muestra todos los pr\u00e9stamos activos (c\u00f3digo, material, usuario).\"\"\"\n    prs = bib.prestamos_activos()\n    if not prs:\n        print(\"No hay pr\u00e9stamos activos.\")\n        return\n    print(\"Pr\u00e9stamos:\")\n    for codigo, material, usuario in prs:\n        print(f\" - {codigo} \u2192 {material.info()} | Usuario: {usuario}\")\n\n\n# -------------------- men\u00fa --------------------\n\ndef mostrar_menu() -&gt; None:\n    \"\"\"Imprime el men\u00fa principal.\"\"\"\n    print(\"\"\"\n--- Men\u00fa ---\n1. Registrar libro\n2. Registrar revista\n3. Ver materiales disponibles\n4. Prestar material\n5. Devolver material\n6. Ver pr\u00e9stamos activos\n7. Salir\n\"\"\")\n\n\ndef main() -&gt; None:\n    \"\"\"Bucle principal de la aplicaci\u00f3n.\"\"\"\n    while True:\n        mostrar_menu()\n        opcion = leer_opcion(\"Opci\u00f3n: \", 1, 7)\n        if opcion == 1:\n            registrar_libro()\n        elif opcion == 2:\n            registrar_revista()\n        elif opcion == 3:\n            ver_materiales()\n        elif opcion == 4:\n            prestar_material()\n        elif opcion == 5:\n            devolver_material()\n        elif opcion == 6:\n            ver_prestamos_activos()\n        elif opcion == 7:\n            print(\"\u00a1Hasta luego!\")\n            break\n\n\nif __name__ == \"__main__\":\n    main()\n</code></pre>"},{"location":"material/S2/005/","title":"Clase 5: Polimorfismo, decoradores y sobrecarga de operadores","text":"<p>En esta clase, se van a estudiar los conceptos de polimorfismo en la OOP, el uso de decoradores <code>@staticmethod</code> y <code>@classmethod</code> en la definici\u00f3n de m\u00e9todos y finalmente, la sobrecarga de operadores.</p>"},{"location":"material/S2/005/#polimorfismo-y-redefinicion-de-metodos","title":"Polimorfismo y redefinici\u00f3n de m\u00e9todos","text":"<p>La programaci\u00f3n orientada a objetos (POO) permite que diferentes clases puedan compartir el mismo nombre de m\u00e9todo, pero con un comportamiento adaptado a cada una. A esto se le conoce como polimorfismo.</p> <p>Definici\u00f3n</p> <p>El polimorfismo es la capacidad que tienen los objetos de diferentes clases de responder de manera distinta a la misma llamada de m\u00e9todo.</p>"},{"location":"material/S2/005/#redefinicion-de-metodos","title":"Redefinici\u00f3n de M\u00e9todos","text":"<p>Cuando una clase hija hereda de una clase padre, puede redefinir (sobrescribir) un m\u00e9todo para adaptarlo a su propio comportamiento. Esto se logra simplemente volviendo a declarar el m\u00e9todo en la subclase, como se ha visto anteriormente.</p> EjemploSalida esperada <pre><code>class Animal:\n    def hacer_sonido(self):\n        return \"Sonido gen\u00e9rico\"\n\nclass Perro(Animal):\n    def hacer_sonido(self):   # (1)!\n        return \"Guau\"\n\nclass Gato(Animal):\n    def hacer_sonido(self):   # (2)!\n        return \"Miau\"\n\n# Demostraci\u00f3n de polimorfismo\nanimales = [Perro(), Gato(), Animal()]\nfor animal in animales:\n    print(animal.hacer_sonido())\n</code></pre> <ol> <li>Redefinici\u00f3n del m\u00e9todo.</li> <li>Redefinici\u00f3n del m\u00e9todo.</li> </ol> <pre><code>Guau             # (1)!\nMiau             # (2)!\nSonido gen\u00e9rico  # (3)!\n</code></pre> <ol> <li>Para la instancia de <code>Perro</code>.</li> <li>Para la instancia de <code>Gato</code>.</li> <li>Para la instancia de <code>Animal</code>.</li> </ol> <ol> <li><code>Animal</code> define un m\u00e9todo gen\u00e9rico <code>hacer_sonido()</code>.</li> <li><code>Perro</code> y <code>Gato</code> heredan de <code>Animal</code>, pero redefinen (<code>override</code>) el m\u00e9todo.</li> <li>Cuando recorremos la lista <code>animales</code>, cada objeto ejecuta su propia versi\u00f3n del m\u00e9todo.</li> </ol> <p>Ventaja del polimorfismo</p> <p>Permite escribir c\u00f3digo gen\u00e9rico que funciona con m\u00faltiples tipos de objetos, sin necesidad de conocer de antemano la clase exacta.</p>"},{"location":"material/S2/005/#ejemplo-polimorfismo-en-una-jerarquia-de-figuras","title":"Ejemplo: Polimorfismo en una jerarqu\u00eda de figuras","text":"EjemploSalida esperada <pre><code>class Figura:\n    def area(self):  # (1)!\n        raise NotImplementedError(\"Este m\u00e9todo debe ser redefinido en la subclase\")\n\nclass Rectangulo(Figura):\n    def __init__(self, base, altura):\n        self.base = base\n        self.altura = altura\n\n    def area(self):   # (2)!\n        return self.base * self.altura\n\nclass Circulo(Figura):\n    def __init__(self, radio):\n        self.radio = radio\n\n    def area(self):   # (3)!\n        return 3.14 * self.radio ** 2\n\nfiguras = [Rectangulo(4, 5), Circulo(3)] # (4)!\nfor f in figuras:\n    print(f\"\u00c1rea: {f.area()}\")\n</code></pre> <ol> <li>Clase abstracta: No se va a cubrir espec\u00edficamente.</li> <li>Redefinici\u00f3n del \u00e1rea para un rect\u00e1ngulo.</li> <li>Redefinici\u00f3n del \u00e1rea para un c\u00edrculo.</li> <li>Se aplica el m\u00e9todo a las instancias de la lista.</li> </ol> <pre><code>\u00c1rea: 20\n\u00c1rea: 28.26\n</code></pre> <p>Observaci\u00f3n</p> <p>Cada subclase (<code>Rectangulo</code>, <code>Circulo</code>) redefine el m\u00e9todo <code>.area()</code> de forma diferente. Gracias al polimorfismo, se recorre una lista heterog\u00e9nea de figuras y se tratan a todas por igual.</p>"},{"location":"material/S2/005/#decoradores-en-clases-staticmethod-y-classmethod","title":"Decoradores en clases: <code>@staticmethod</code> y <code>@classmethod</code>","text":"<p>En Python, los decoradores en clases permiten cambiar la forma en que se comportan los m\u00e9todos. Ya se cubrieron <code>@property</code> y <code>@setter</code>, ahora se va a enfocar en:</p> <ul> <li><code>@staticmethod</code></li> <li><code>@classmethod</code></li> </ul>"},{"location":"material/S2/005/#staticmethod","title":"<code>@staticmethod</code>","text":"<p>Un m\u00e9todo est\u00e1tico es aquel que no recibe ni <code>self</code> ni <code>cls</code> como primer argumento. Es \u00fatil cuando se necesita una funci\u00f3n relacionada con la clase, pero que no depende de la instancia ni de la clase en s\u00ed.</p> Ejemplo de m\u00e9todo est\u00e1tico<pre><code>class Calculadora:\n    @staticmethod  # (1)!\n    def suma(a, b):\n        return a + b\n\n# Se puede llamar sin crear un objeto\nprint(Calculara.suma(5, 3))  # (2)!\n\n# Tambi\u00e9n funciona desde una instancia\nm = Matematica()\nprint(m.suma(10, 7))  # (3)!\n</code></pre> <ol> <li>M\u00e9todo est\u00e1tico asociado a la clase.</li> <li><code>8</code></li> <li><code>17</code></li> </ol> <p>Uso t\u00edpico</p> <p>Se emplea para m\u00e9todos utilitarios o funciones auxiliares que tienen sentido en la clase, pero que no dependen de sus atributos.</p>"},{"location":"material/S2/005/#classmethod","title":"<code>@classmethod</code>","text":"<p>Un m\u00e9todo de clase recibe la clase como primer par\u00e1metro (en lugar de <code>self</code>), normalmente llamado <code>cls</code>. Se usa cuando el m\u00e9todo necesita acceder o modificar atributos compartidos por todas las instancias.</p> EjemploSalida esperada <pre><code>class Persona:\n    cantidad = 0  # (1)!\n\n    def __init__(self, nombre): # (2)!\n        self.nombre = nombre\n        Persona.cantidad += 1   # (3)!\n\n    @classmethod\n    def contar_personas(cls):   # (4)!\n        return f\"Se han creado {cls.cantidad} personas.\"  # (5)!\n\n# Crear instancias\np1 = Persona(\"Ana\")\np2 = Persona(\"Luis\")\n\n# Llamar al m\u00e9todo de clase\nprint(Persona.contar_personas())\n</code></pre> <ol> <li>Atributo de clase: fuera del <code>__init__</code>.</li> <li>Definici\u00f3n de atributos de instancia.</li> <li>Se incrementa <code>cantidad</code> (atributo de clase).</li> <li>M\u00e9todo de clase recibe <code>cls</code> como primer par\u00e1metro.</li> <li>Imprime el atributo de clase.</li> </ol> <pre><code>Se han creado 2 personas.\n</code></pre> <p>Diferencia con m\u00e9todos est\u00e1ticos</p> <ul> <li>M\u00e9todo de instancia: recibe <code>self</code> y puede acceder a los atributos de instancia.</li> <li><code>@staticmethod</code>: no recibe ni <code>self</code> ni <code>cls</code>, est\u00e1 agrupado con la clase pero no puede acceder a atributos.</li> <li><code>@classmethod</code>: recibe la clase (<code>cls</code>) como primer par\u00e1metro, puede acceder/modificar los atributos de clase.</li> </ul>"},{"location":"material/S2/005/#ejemplo-de-staticmethod-y-classmethod","title":"Ejemplo de <code>@staticmethod</code> y <code>@classmethod</code>","text":"Implementaci\u00f3n de m\u00e9todos de est\u00e1ticos y de clase en Producto<pre><code>class Producto:\n    tasa_impuesto = 0.13                  # (1)!\n\n    def __init__(self, nombre, precio):\n        self.nombre = nombre\n        self.precio = precio\n\n    @staticmethod\n    def es_valido(precio):                # (2)!\n        \"\"\"Un precio es v\u00e1lido si es positivo\"\"\"\n        return precio &gt; 0\n\n    @classmethod\n    def cambiar_impuesto(cls, nuevo):     # (3)!\n        cls.tasa_impuesto = nuevo\n\n    def precio_final(self):\n        return self.precio * (1 + Producto.tasa_impuesto)\n\n# Uso\nprint(Producto.es_valido(50))     # (4)!\nprint(Producto.es_valido(-20))    # (5)!\n\np1 = Producto(\"Camisa\", 10000)\nprint(p1.precio_final())          # (6)!\n\nProducto.cambiar_impuesto(0.2)\nprint(p1.precio_final())          # (7)!\n</code></pre> <ol> <li>Atributo de clase: Compartido por todas las instancias de la clase.</li> <li>No recibe ni <code>self</code> ni <code>cls</code>.</li> <li>Modifica el atributo de clase. Puede llamarse sin necesidad de existir una instancia (con la clase propiamente).</li> <li>True</li> <li>False</li> <li><code>11300.0</code></li> <li><code>12000.0</code></li> </ol>"},{"location":"material/S2/005/#sobrecarga-de-operadores-en-clases-personalizadas","title":"Sobrecarga de Operadores en Clases Personalizadas","text":"<p>En Python, las clases pueden definir c\u00f3mo deben comportarse los operadores (<code>+</code>, <code>-</code>, <code>==</code>, entre otros) cuando se aplican a sus objetos. Esto se logra implementando m\u00e9todos especiales.</p> <p>Definici\u00f3n</p> <p>La sobrecarga de operadores consiste en redefinir los operadores para que funcionen con objetos creados por el usuario, haciendo el c\u00f3digo m\u00e1s natural y legible.</p>"},{"location":"material/S2/005/#metodos-comunes","title":"M\u00e9todos comunes","text":"Operador M\u00e9todo especial Uso <code>+</code> <code>__add__</code> Suma de objetos <code>-</code> <code>__sub__</code> Resta de objetos <code>==</code> <code>__eq__</code> Comparaci\u00f3n de igualdad <code>str()</code> <code>__str__</code> Representaci\u00f3n en texto legible <code>len()</code> <code>__len__</code> Longitud de un objeto"},{"location":"material/S2/005/#ejemplo-clase-vector","title":"Ejemplo: Clase <code>Vector</code>","text":"Sobrecarga de operadores en clase Vector<pre><code>class Vector:\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n\n    def __add__(self, other):\n        return Vector(self.x + other.x, self.y + other.y)\n\n    def __eq__(self, other):\n        return self.x == other.x and self.y == other.y\n\n    def __str__(self):\n        return f\"({self.x}, {self.y})\"\n\n# Uso de la clase\nv1 = Vector(2, 3)\nv2 = Vector(5, 7)\nv3 = v1 + v2     # (1)!\nprint(v3)        # (2)!\nprint(v1 == v2)  # (3)!\n</code></pre> <ol> <li>Llama a <code>__add__</code></li> <li>Llama a <code>__str__</code>: <code>(7, 10)</code></li> <li>Llama a <code>__eq__</code>: <code>False</code></li> </ol> <p>Ventaja</p> <p>Gracias a la sobrecarga de operadores, podemos trabajar con objetos de manera intuitiva y expresiva, en lugar de definir m\u00e9todos como <code>sumar(v1, v2)</code>.</p>"},{"location":"material/S2/005/#ejemplo-clase-fraccion","title":"Ejemplo: Clase <code>Fraccion</code>","text":"Sobrecarga de operadores en clase Fraccion<pre><code>from math import gcd\n\nclass Fraccion:\n    def __init__(self, num, den):\n        if den == 0:\n            raise ValueError(\"El denominador no puede ser cero\")\n        self.num = num\n        self.den = den\n        self.simplificar()\n\n    def simplificar(self):\n        divisor = gcd(self.num, self.den) # M\u00e1ximo com\u00fan divisor\n        self.num //= divisor\n        self.den //= divisor\n\n    def __add__(self, other):\n        nuevo_num = self.num * other.den + other.num * self.den\n        nuevo_den = self.den * other.den\n        return Fraccion(nuevo_num, nuevo_den)\n\n    def __eq__(self, other):\n        return self.num == other.num and self.den == other.den\n\n    def __str__(self):\n        return f\"{self.num}/{self.den}\"\n\n# Uso\nf1 = Fraccion(1, 2)\nf2 = Fraccion(1, 3)\nprint(f1 + f2)     # (1)!\nprint(f1 == f2)    # (2)!\n</code></pre> <ol> <li><code>5/6</code></li> <li><code>False</code></li> </ol>"},{"location":"material/S2/006/","title":"Clase 6: Programaci\u00f3n funcional","text":"<p>En esta clase, se van a introducir los principios fundamentales de la programaci\u00f3n funcional en Python, el uso de las funciones integradas <code>map()</code>, <code>filter()</code>, y <code>sorted()</code>, junto con el uso de expresiones <code>lambda</code>, compresiones de listas y expresiones generadoras.</p>"},{"location":"material/S2/006/#introduccion","title":"Introducci\u00f3n","text":"<p>La programaci\u00f3n funcional es un paradigma de programaci\u00f3n que se centra en el uso de funciones como bloques fundamentales de construcci\u00f3n. A diferencia de la programaci\u00f3n imperativa, que describe una secuencia de pasos a ejecutar, la programaci\u00f3n funcional busca describir el qu\u00e9 se quiere obtener, en lugar de detallar c\u00f3mo llegar a ese resultado.</p> <p>Una de sus ideas principales es evitar modificar estados o variables en el tiempo (inmutabilidad), por medio de que las funciones siempre produzcan el mismo resultado ante los mismos par\u00e1metros de entrada (funciones puras).</p>"},{"location":"material/S2/006/#que-es-la-programacion-funcional","title":"\u00bfQu\u00e9 es la programaci\u00f3n funcional?","text":"<p>Definici\u00f3n general</p> <p>La programaci\u00f3n funcional es un estilo de programaci\u00f3n que trata la computaci\u00f3n como la evaluaci\u00f3n de funciones matem\u00e1ticas. Se evitan cambios de estado y datos mutables.</p>"},{"location":"material/S2/006/#diferencia-con-otros-paradigmas","title":"Diferencia con otros paradigmas","text":"<ul> <li>La programaci\u00f3n funcional suele usarse para procesar colecciones de datos de forma concisa (por ejemplo, transformar listas, filtrar elementos o combinar resultados).</li> <li>La OOP resulta m\u00e1s \u00fatil cuando queremos modelar entidades del mundo real con atributos y comportamientos.</li> </ul>"},{"location":"material/S2/006/#funciones-de-orden-superior-y-programacion-declarativa","title":"Funciones de orden superior y programaci\u00f3n declarativa","text":"<p>Las funciones de orden superior son un concepto fundamental en la programaci\u00f3n funcional. Es una funci\u00f3n que recibe otras funciones como par\u00e1metros, o devuelve una funci\u00f3n como resultado.</p> <p>Hasta el momento, se ha recibido/retornado datos por las funciones, pero Python tambi\u00e9n permite recibir/retornar funciones. Esto permite escribir programas donde la l\u00f3gica se construye por la composici\u00f3n de funciones.</p>"},{"location":"material/S2/006/#definicion-de-funciones-de-orden-superior","title":"Definici\u00f3n de funciones de orden superior","text":"<p>Definici\u00f3n</p> <p>Una funci\u00f3n de orden superior es aquella que recibe una funci\u00f3n como argumento y/o devuelve otra funci\u00f3n.</p> <p>A continuaci\u00f3n, se presenta un ejemplo para introducir el concepto:</p> <pre><code>def aplicar_operacion(funcion, numeros):  # (1)!\n    return [funcion(x) for x in numeros]\n\n# Funci\u00f3n normal\ndef cuadrado(n):  # (2)!\n    return n ** 2\n\n# Uso\nresultado = aplicar_operacion(cuadrado, [1, 2, 3, 4])\nprint(resultado)  # [1, 4, 9, 16]\n</code></pre> <ol> <li><code>aplicar_operacion</code> es de orden superior porque recibe <code>funcion</code> como par\u00e1metro.</li> <li><code>cuadrado</code> es una funci\u00f3n normal que se pasa como argumento.</li> </ol>"},{"location":"material/S2/006/#ejemplos-de-funciones-que-reciben-otras-funciones","title":"Ejemplos de funciones que reciben otras funciones","text":"<p>Python incluye funciones integradas que son de orden superior, como <code>map()</code>, <code>filter()</code> y <code>sorted()</code> con su argumento <code>key</code>.</p> Ejemplo con sorted y una funci\u00f3n como par\u00e1metro<pre><code>palabras = [\"python\", \"java\", \"c\", \"javascript\"]\n\nordenadas = sorted(palabras, key=len) # (1)!\nprint(ordenadas)  # (2)!\n</code></pre> <ol> <li>Ordena las palabras seg\u00fan su longitud</li> <li><code>['c', 'java', 'python', 'javascript']</code></li> </ol> <p>Aqu\u00ed:</p> <ul> <li><code>sorted</code> es una funci\u00f3n de orden superior.</li> <li><code>len</code> es otra funci\u00f3n que se pasa como argumento para definir el criterio de ordenamiento.</li> </ul> <p>En el ejemplo anterior, es importante observar que <code>len</code> es una funci\u00f3n que devuelve un n\u00famero entero (la cantidad de caracteres de un string). Por esta raz\u00f3n, es que puede ser un <code>key</code> de la funci\u00f3n <code>sorted</code>.</p>"},{"location":"material/S2/006/#programacion-declarativa-expresar-que-en-lugar-de-como","title":"Programaci\u00f3n declarativa: expresar qu\u00e9 en lugar de c\u00f3mo","text":"<p>La programaci\u00f3n imperativa obliga a detallar paso a paso c\u00f3mo se resuelve un problema. La programaci\u00f3n declarativa, en cambio, se centra en expresar qu\u00e9 se quiere lograr, dejando que el lenguaje o las funciones integradas gestionen los detalles.</p> Estilo imperativoEstilo declarativo <pre><code>numeros = [1, 2, 3, 4, 5]\ncuadrados = []\nfor n in numeros:\n    cuadrados.append(n**2)\n</code></pre> <pre><code>numeros = [1, 2, 3, 4, 5]\ncuadrados = list(map(lambda x: x**2, numeros))\n</code></pre> <p>Tip</p> <p>En el ejemplo anterior, el enfoque imperativo describe c\u00f3mo construir la lista paso a paso. El enfoque declarativo con <code>map</code> describe qu\u00e9 se desea obtener: aplicar una operaci\u00f3n de cuadrado a cada elemento.</p>"},{"location":"material/S2/006/#diagrama-comparativo","title":"Diagrama comparativo","text":"<pre><code>flowchart LR\n    A[Imperativo] --&gt; B[Inicializar lista vac\u00eda]\n    B --&gt; C[Iterar elementos]\n    C --&gt; D[Aplicar operaci\u00f3n]\n    D --&gt; E[Agregar a lista final]\n\n    F[Declarativo] --&gt; G[Definir operaci\u00f3n]\n    G --&gt; H[Aplicar map]\n    H --&gt; I[Obtener lista resultante]</code></pre> <p>Preguntas para reforzar</p> <ul> <li>\u00bfQu\u00e9 condiciones debe cumplir una funci\u00f3n para considerarse de orden superior?</li> <li>\u00bfQu\u00e9 ventajas aporta el estilo declarativo en comparaci\u00f3n con el imperativo?</li> </ul>"},{"location":"material/S2/006/#expresiones-lambda","title":"Expresiones lambda","text":"<p>Las expresiones lambda en Python permiten definir funciones de manera r\u00e1pida y concisa, sin necesidad de usar la palabra clave <code>def</code>. Se les conoce tambi\u00e9n como funciones an\u00f3nimas, porque no requieren un nombre expl\u00edcito.</p> <p>Son especialmente \u00fatiles en contextos donde necesitamos pasar una funci\u00f3n corta como argumento a otra funci\u00f3n de orden superior (<code>map</code>, <code>filter</code>, <code>sorted</code>, entre otros).</p>"},{"location":"material/S2/006/#definicion-y-sintaxis-de-lambda","title":"Definici\u00f3n y sintaxis de <code>lambda</code>","text":"<p>La sintaxis general es:</p> Sintaxis<pre><code>lambda argumentos: expresi\u00f3n\n</code></pre> <ul> <li><code>lambda</code> es la palabra clave.</li> <li>Los argumentos funcionan igual que en una funci\u00f3n normal.</li> <li>La expresi\u00f3n es lo que se eval\u00faa y se devuelve.</li> </ul> <p>A continuaci\u00f3n se muestra un ejemplo sencillo para la suma de dos n\u00fameros:</p> Funci\u00f3n lambda para sumar dos n\u00fameros<pre><code>suma = lambda x, y: x + y  # (1)!\nprint(suma(3, 5))  # (2)!\n</code></pre> <ol> <li>Se almacena la funci\u00f3n creada con lambda en la variable <code>suma</code></li> <li><code>8</code></li> </ol>"},{"location":"material/S2/006/#comparacion-con-funciones-definidas-con-def","title":"Comparaci\u00f3n con funciones definidas con <code>def</code>","text":"<p>Veamos c\u00f3mo una misma operaci\u00f3n puede escribirse con <code>def</code> y con <code>lambda</code>:</p> Funci\u00f3n definida con <code>def</code>Funci\u00f3n definida con <code>lambda</code> <pre><code>def cuadrado(n):\n    return n ** 2\n</code></pre> <pre><code>cuadrado = lambda n: n ** 2\n</code></pre> <p>Info</p> <ul> <li>Una funci\u00f3n definida con <code>def</code> permite escribir m\u00faltiples l\u00edneas, incluir docstrings y ser reutilizada ampliamente.</li> <li>Una funci\u00f3n <code>lambda</code>, en cambio, se limita a una sola expresi\u00f3n, lo que la hace pr\u00e1ctica pero menos flexible.</li> </ul>"},{"location":"material/S2/006/#casos-de-uso-tipicos","title":"Casos de uso t\u00edpicos","text":"<p>Las expresiones lambda se suelen usar en:</p> <ol> <li>Funciones de orden superior:    <pre><code>numeros = [1, 2, 3, 4]\ncuadrados = list(map(lambda x: x**2, numeros))\nprint(cuadrados)  # [1, 4, 9, 16]\n</code></pre></li> <li>Filtrado de elementos:    <pre><code>pares = list(filter(lambda x: x % 2 == 0, numeros))\nprint(pares)  # [2, 4]\n</code></pre></li> <li>Ordenamiento con criterios personalizados:    <pre><code>palabras = [\"python\", \"java\", \"c\", \"javascript\"]\nordenadas = sorted(palabras, key=lambda s: len(s))\nprint(ordenadas)  # ['c', 'java', 'python', 'javascript']\n</code></pre></li> </ol> <p>Preguntas para reflexionar</p> <ul> <li>\u00bfCu\u00e1l es la diferencia m\u00e1s importante entre una funci\u00f3n definida con <code>def</code> y una funci\u00f3n <code>lambda</code>?</li> </ul>"},{"location":"material/S2/006/#funciones-integradas-para-programacion-funcional","title":"Funciones integradas para programaci\u00f3n funcional","text":"<p>Python incluye varias funciones integradas que permiten aplicar el paradigma funcional de manera natural. Entre las m\u00e1s usadas est\u00e1n <code>map()</code>, <code>filter()</code> y <code>sorted()</code>. Estas funciones son ejemplos claros de funciones de orden superior, porque reciben otra funci\u00f3n como argumento.</p>"},{"location":"material/S2/006/#map","title":"<code>map()</code>","text":"<p>La funci\u00f3n <code>map()</code> aplica una funci\u00f3n a cada elemento de un iterable y devuelve un objeto <code>map</code> (que puede convertirse en lista, tupla, entre otros).</p> Sintaxis<pre><code>map(funcion, iterable)\n</code></pre> <p>Un ejemplo sencillo del uso de <code>map()</code> se muestra en el siguiente bloque de c\u00f3digo:</p> Elevar al cuadrado cada n\u00famero<pre><code>numeros = [1, 2, 3, 4, 5]\ncuadrados = list(map(lambda x: x**2, numeros))\nprint(cuadrados)  # (1)!\n</code></pre> <ol> <li><code>[1, 4, 9, 16, 25]</code></li> </ol> <p>Tip</p> <p><code>map()</code> transforma cada elemento de la colecci\u00f3n seg\u00fan la funci\u00f3n indicada.  Es \u00fatil para aplicar la misma operaci\u00f3n a todos los elementos.</p>"},{"location":"material/S2/006/#filter","title":"<code>filter()</code>","text":"<p>La funci\u00f3n <code>filter()</code> selecciona \u00fanicamente los elementos que cumplen con una condici\u00f3n l\u00f3gica (que devuelva <code>True</code>).</p> Sintaxis<pre><code>filter(funcion_condicion, iterable)\n</code></pre> <p>Como ejemplo introductorio, se tiene el siguiente c\u00f3digo:</p> Quedarse solo con n\u00fameros pares<pre><code>numeros = [1, 2, 3, 4, 5, 6]\npares = list(filter(lambda x: x % 2 == 0, numeros))\nprint(pares)  # (1)!\n</code></pre> <ol> <li><code>[2, 4, 6]</code></li> </ol> <p>Info</p> <p><code>filter()</code> no transforma los datos, sino que descarta los que no cumplen con la condici\u00f3n.</p> <p>Preguntas para reforzar</p> <ul> <li>\u00bfQu\u00e9 diferencia hay entre <code>map()</code> y <code>filter()</code> en cuanto al tipo de operaci\u00f3n que realizan?</li> </ul>"},{"location":"material/S2/006/#comprensiones-y-expresiones-generadoras","title":"Comprensiones y expresiones generadoras","text":"<p>Adem\u00e1s de <code>map()</code>, <code>filter()</code> y <code>reduce()</code>, Python ofrece una sintaxis especial muy legible: las comprensiones y las expresiones generadoras. Estas permiten escribir operaciones de transformaci\u00f3n y filtrado en una sola l\u00ednea, de manera m\u00e1s clara que usando funciones integradas.</p>"},{"location":"material/S2/006/#comprensiones-de-listas","title":"Comprensiones de listas","text":"<p>Las comprensiones de listas permiten construir listas a partir de un iterable. Se aplican transformaciones y condiciones en una sola expresi\u00f3n.</p> Sintaxis<pre><code>[expresion for elemento in iterable if condicion]\n</code></pre> <p>Un ejemplo sencillo para introducir el tema, se muestra a continuaci\u00f3n:</p> Elevar al cuadrado los n\u00fameros del 1 al 5<pre><code>cuadrados = [x**2 for x in range(1, 6)]\nprint(cuadrados)  # [1, 4, 9, 16, 25]\n</code></pre> <p>A continuaci\u00f3n, se muestra una comparaci\u00f3n entre el uso de compresi\u00f3n de listas y las funciones integradas <code>map</code> y <code>filter</code> para elevar los n\u00fameros pares al cuadrado de una lista.</p> Con <code>map</code> / <code>filter</code>Con compresi\u00f3n de listas <pre><code>numeros = [1, 2, 3, 4, 5]\npares = list(filter(lambda x: x % 2 == 0, numeros))\ncuadrados = list(map(lambda x: x**2, pares))\n</code></pre> <pre><code>numeros = [1, 2, 3, 4, 5]\ncuadrados = [x**2 for x in numeros if x % 2 == 0]\n</code></pre>"},{"location":"material/S2/006/#ejemplos-practicos-para-compresion-de-listas","title":"Ejemplos pr\u00e1cticos para compresi\u00f3n de listas","text":"Filtrar nombres que empiezan con 'A'<pre><code>nombres = [\"Ana\", \"Pedro\", \"Alberto\", \"Luc\u00eda\"]\nresultado = [n for n in nombres if n.startswith(\"A\")]\nprint(resultado)  # (1)!\n</code></pre> <ol> <li><code>['Ana', 'Alberto']</code></li> </ol> Crear una lista de tuplas (n, n^2)<pre><code>parejas = [(n, n**2) for n in range(1, 6)]\nprint(parejas)  # (1)!\n</code></pre> <ol> <li><code>[(1,1), (2,4), (3,9), (4,16), (5,25)]</code></li> </ol>"},{"location":"material/S2/006/#expresiones-generadoras","title":"Expresiones generadoras","text":"<p>Una expresi\u00f3n generadora es similar a una comprensi\u00f3n de listas, pero en lugar de crear la lista completa en memoria, crea un objeto generador que produce los elementos bajo demanda.</p> Sintaxis<pre><code>(expresion for elemento in iterable if condicion)\n</code></pre> <p>Como primer ejemplo, se tiene el siguiente c\u00f3digo:</p> Generador que produce cuadrados de n\u00fameros pares<pre><code>generador = (x**2 for x in range(1, 6) if x % 2 == 0)\n\nprint(next(generador))  # (1)!\nprint(next(generador))  # (2)!\n</code></pre> <ol> <li><code>4</code></li> <li><code>16</code></li> </ol> <p>Los generadores funcionan muy bien con funciones como <code>sum()</code> y <code>any()</code> que consumen iterables:</p> Sumar los cuadrados de n\u00fameros pares<pre><code>suma = sum(x**2 for x in range(1, 6) if x % 2 == 0)\nprint(suma)  # (1)!\n</code></pre> <ol> <li><code>20</code></li> </ol> Verificar si hay ALG\u00daN n\u00famero mayor que 10<pre><code>existe = any(x &gt; 10 for x in [2, 5, 8, 11])\nprint(existe)  # (1)!\n</code></pre> <ol> <li><code>True</code></li> </ol>"},{"location":"material/S2/006/#diferencia-entre-lista-y-generador","title":"Diferencia entre lista y generador","text":"Comprensi\u00f3n de lista Expresi\u00f3n generadora Calcula todos los valores de una vez y los guarda en memoria. Calcula los valores uno a uno bajo demanda. Ocupa m\u00e1s memoria si la colecci\u00f3n es grande. Muy eficiente en memoria, ideal para secuencias grandes. Devuelve una lista. Devuelve un objeto generador (iterador)."},{"location":"material/S2/006/#ejercicio-final","title":"Ejercicio final","text":"<p>Dada una lista de n\u00fameros enteros, se quiere:</p> <ol> <li>Filtrar los n\u00fameros positivos.</li> <li>Obtener el cuadrado de cada n\u00famero positivo.</li> <li>Quedarnos solo con los que sean pares.</li> </ol> Con funciones integradasCon compresiones de listas <ol> <li> <p>Filtrar n\u00fameros positivos (<code>filter</code>) <pre><code>numeros = [-5, -2, 0, 1, 2, 3, 4, 5]\n\npositivos = list(filter(lambda x: x &gt; 0, numeros))\nprint(positivos)  # [1, 2, 3, 4, 5]\n</code></pre></p> </li> <li> <p>Obtener sus cuadrados (<code>map</code>) <pre><code>cuadrados = list(map(lambda x: x**2, positivos))\nprint(cuadrados)  # [1, 4, 9, 16, 25]\n</code></pre></p> </li> <li> <p>Filtrar los pares (<code>filter</code>) <pre><code>pares = list(filter(lambda x: x % 2 == 0, cuadrados))\nprint(pares)  # [4, 16]\n</code></pre></p> </li> </ol> <p>La misma operaci\u00f3n se puede escribir de forma m\u00e1s legible usando una comprensi\u00f3n de listas:</p> <pre><code>numeros = [-5, -2, 0, 1, 2, 3, 4, 5]\n\nresultado = sum([x**2 for x in numeros if x &gt; 0 and (x**2) % 2 == 0])\nprint(resultado)  # 20\n</code></pre>"},{"location":"material/S2/007/","title":"Clase 7: \u00c1rboles binarios","text":""},{"location":"material/S2/007/#definicion-general","title":"Definici\u00f3n general","text":"<p>Concepto general</p> <p>Un \u00e1rbol binario es una estructura de datos jer\u00e1rquica compuesta por elementos llamados nodos. Cada nodo puede tener como m\u00e1ximo dos hijos: un hijo izquierdo y un hijo derecho. Esta restricci\u00f3n lo distingue de los \u00e1rboles generales, donde un nodo puede tener cualquier cantidad de hijos.</p> <p>Los \u00e1rboles binarios se utilizan para representar estructuras donde la informaci\u00f3n se divide de manera recursiva, por ejemplo:</p> <ul> <li>La evaluaci\u00f3n de expresiones matem\u00e1ticas (<code>(3 + 5) * 2</code>).</li> <li>La organizaci\u00f3n jer\u00e1rquica de decisiones en un juego.</li> <li>La indexaci\u00f3n de datos en estructuras como los \u00e1rboles binarios de b\u00fasqueda (BST) o heaps.</li> </ul> <pre><code>graph TD\n    A[\"Juego de adivinanzas\"]\n    A --&gt; B[\"\u00bfAnimal terrestre?\"]\n    B --&gt; C[\"\u00bfTiene rayas?\"]\n    B --&gt; D[\"\u00bfVuela?\"]\n    C --&gt; E[\"Cebra\"]\n    C --&gt; F[\"Perro\"]\n    D --&gt; G[\"\u00c1guila\"]\n    D --&gt; H[\"Pez\"]</code></pre> <p>Idea central</p> <p>Un \u00e1rbol binario se construye recursivamente: cada nodo es a su vez la ra\u00edz de dos sub\u00e1rboles, los cuales tambi\u00e9n son \u00e1rboles binarios.</p>"},{"location":"material/S2/007/#componentes-de-un-arbol-binario","title":"Componentes de un \u00e1rbol binario","text":"<p>Cada nodo contiene tres elementos principales:</p> Componente Descripci\u00f3n Valor o dato La informaci\u00f3n almacenada (n\u00famero, texto, objeto) Referencia al hijo izquierdo (<code>izq</code>) Apunta al sub\u00e1rbol izquierdo o es <code>None</code> si no existe Referencia al hijo derecho (<code>der</code>) Apunta al sub\u00e1rbol derecho o es <code>None</code> si no existe <p>Ejemplo visual:</p> <pre><code>flowchart TB\n    R((10))\n    L((5))\n    R1((15))\n    L2((3))\n    L3((7))\n    R2((12))\n    R3((20))\n\n    R --&gt; L\n    R --&gt; R1\n    L --&gt; L2\n    L --&gt; L3\n    R1 --&gt; R2\n    R1 --&gt; R3</code></pre> <p>Definici\u00f3n formal</p> <p>Un \u00e1rbol binario es:</p> <ul> <li>Vac\u00edo (sin nodos), o</li> <li>Un nodo ra\u00edz que tiene dos sub\u00e1rboles binarios (izquierdo y derecho).</li> </ul>"},{"location":"material/S2/007/#terminologia","title":"Terminolog\u00eda","text":"T\u00e9rmino Significado Ra\u00edz Nodo superior del \u00e1rbol (sin padre). Hijo Nodo descendiente directo de otro. Padre Nodo que tiene hijos. Hoja Nodo sin hijos. Sub\u00e1rbol \u00c1rbol formado por un nodo y todos sus descendientes. Altura Longitud del camino m\u00e1s largo desde la ra\u00edz hasta una hoja. Nivel Distancia (en aristas) desde la ra\u00edz hasta el nodo. Tama\u00f1o N\u00famero total de nodos del \u00e1rbol. <pre><code>flowchart TB\n    A((Ra\u00edz))\n    B((Hijo Izq))\n    C((Hijo Der))\n    D((Hoja))\n    E((Hoja))\n    A --&gt; B\n    A --&gt; C\n    B --&gt; D\n    B --&gt; E</code></pre> <p>Observaciones clave</p> <ul> <li>No todos los nodos deben tener dos hijos; algunos pueden tener uno o ninguno.</li> <li>El \u00e1rbol vac\u00edo tambi\u00e9n se considera un \u00e1rbol binario v\u00e1lido.</li> <li>Un \u00e1rbol binario se puede ver como una colecci\u00f3n de sub\u00e1rboles conectados.</li> <li>Cada nodo es la ra\u00edz de su propio sub\u00e1rbol.</li> </ul>"},{"location":"material/S2/007/#la-clase-nodo","title":"La clase <code>Nodo</code>","text":"<p>Cada nodo almacena un valor y dos referencias a sus hijos. En Python, se puede representar con una clase sencilla:</p> <pre><code>class Nodo:\n    def __init__(self, valor):\n        self.valor = valor\n        self.izq = None\n        self.der = None\n</code></pre> <p>Estructura del nodo</p> <ul> <li><code>valor</code>: almacena el dato del nodo.</li> <li><code>izq</code>: referencia al sub\u00e1rbol izquierdo.</li> <li><code>der</code>: referencia al sub\u00e1rbol derecho.</li> </ul> <pre><code>graph LR\n    subgraph Nodo\n        A[\"valor = 10\"]\n        B[\"izq \u2192\"]\n        C[\"der \u2192\"]\n    end\n    B --&gt; L[\"Nodo(5)\"]\n    C --&gt; R[\"Nodo(15)\"]</code></pre>"},{"location":"material/S2/007/#construccion-manual-de-un-arbol-binario","title":"Construcci\u00f3n manual de un \u00e1rbol binario","text":"<p>Se puede crear un \u00e1rbol peque\u00f1o manualmente conectando los nodos entre s\u00ed.</p> <pre><code># Creaci\u00f3n de nodos individuales\nraiz = Nodo(10)\nraiz.izq = Nodo(5)\nraiz.der = Nodo(15)\nraiz.izq.izq = Nodo(3)\nraiz.izq.der = Nodo(7)\nraiz.der.izq = Nodo(12)\nraiz.der.der = Nodo(20)\n</code></pre> <p>Visualizaci\u00f3n del \u00e1rbol:</p> <pre><code>flowchart TB\n    A((10))\n    B((5))\n    C((15))\n    D((3))\n    E((7))\n    F((12))\n    G((20))\n    A --&gt; B\n    A --&gt; C\n    B --&gt; D\n    B --&gt; E\n    C --&gt; F\n    C --&gt; G</code></pre> <p>Ejemplo de impresi\u00f3n simple</p> <pre><code>print(raiz.valor)        # 10\nprint(raiz.izq.valor)    # 5\nprint(raiz.der.valor)    # 15\n</code></pre>"},{"location":"material/S2/007/#funciones-sobre-el-arbol","title":"Funciones sobre el \u00e1rbol","text":""},{"location":"material/S2/007/#altura-del-arbol","title":"Altura del \u00e1rbol","text":"<p>La altura de un \u00e1rbol es la longitud del camino m\u00e1s largo desde la ra\u00edz hasta una hoja. Se puede calcular recursivamente:</p> <pre><code>def altura(nodo):\n    if nodo is None:\n        return 0\n    return 1 + max(altura(nodo.izq), altura(nodo.der))\n</code></pre> <p>Tip</p> <p>Si el \u00e1rbol tiene un solo nodo, la altura es 1. Un \u00e1rbol vac\u00edo tiene altura 0.</p> <p>Ejemplo de llamada:</p> <pre><code>print(altura(raiz))  # 3\n</code></pre>"},{"location":"material/S2/007/#tamano-del-arbol","title":"Tama\u00f1o del \u00e1rbol","text":"<p>El tama\u00f1o representa el n\u00famero total de nodos que contiene el \u00e1rbol.</p> <pre><code>def tamano(nodo):\n    if nodo is None:\n        return 0\n    return 1 + tamano(nodo.izq) + tamano(nodo.der)\n</code></pre> <p>Note</p> <p>Esta funci\u00f3n recorre todos los nodos una vez, por lo que su complejidad temporal es O(n).</p> <p>Ejemplo:</p> <pre><code>print(tamano(raiz))  # 7\n</code></pre>"},{"location":"material/S2/007/#contar-hojas","title":"Contar hojas","text":"<p>Un nodo hoja es aquel que no tiene hijos. Se puede contar tambi\u00e9n de forma recursiva:</p> <pre><code>def contar_hojas(nodo):\n    if nodo is None:\n        return 0\n    if nodo.izq is None and nodo.der is None:\n        return 1\n    return contar_hojas(nodo.izq) + contar_hojas(nodo.der)\n</code></pre> <p>Ejemplo:</p> <pre><code>print(contar_hojas(raiz))  # 4\n</code></pre> <pre><code>flowchart TB\n    A((10))\n    B((5))\n    C((15))\n    D((3))\n    E((7))\n    F((12))\n    G((20))\n    A --&gt; B\n    A --&gt; C\n    B --&gt; D\n    B --&gt; E\n    C --&gt; F\n    C --&gt; G\n    class D,E,F,G hoja;\n    classDef hoja fill:#008F39,stroke:#2E8B57,color:#FFF;</code></pre>"},{"location":"material/S2/007/#resumen","title":"Resumen","text":"Funci\u00f3n Descripci\u00f3n Tipo de operaci\u00f3n Complejidad <code>altura</code> Devuelve la altura del \u00e1rbol Recursiva O(n) <code>tamano</code> Cuenta todos los nodos Recursiva O(n) <code>contar_hojas</code> Cuenta nodos sin hijos Recursiva O(n)"},{"location":"material/S2/007/#recorridos-en-profundidad-dfs","title":"Recorridos en profundidad (DFS)","text":"<p>Para esta parte, se van a tratar los tres tipos principales de recorridos en profundidad en \u00e1rboles binarios: preorden, en orden y postorden, junto con sus implementaciones recursivas e iterativas.</p>"},{"location":"material/S2/007/#concepto-general","title":"Concepto general","text":"<p>Un recorrido en profundidad (Depth-First Search, DFS) visita todos los nodos de un \u00e1rbol, yendo lo m\u00e1s profundo posible por cada rama antes de retroceder.</p> <pre><code>flowchart TD\n    R((10))\n    A((5))\n    B((15))\n    C((3))\n    D((7))\n    E((12))\n    F((20))\n    R --&gt; A\n    R --&gt; B\n    A --&gt; C\n    A --&gt; D\n    B --&gt; E\n    B --&gt; F</code></pre> <p>Orden general</p> <p>El orden en que se visitan los nodos depende del tipo de recorrido que se realice.</p>"},{"location":"material/S2/007/#tipos-de-recorridos-dfs","title":"Tipos de recorridos DFS","text":"Recorrido Orden de visita Descripci\u00f3n breve Preorden Nodo \u2192 Izquierda \u2192 Derecha Se procesa el nodo antes de sus hijos. En orden Izquierda \u2192 Nodo \u2192 Derecha Se procesa el nodo entre sus hijos. Postorden Izquierda \u2192 Derecha \u2192 Nodo Se procesa el nodo despu\u00e9s de sus hijos."},{"location":"material/S2/007/#implementacion-recursiva","title":"Implementaci\u00f3n recursiva","text":"PreordenEn ordenPostorden <pre><code>def preorden(nodo, resultado):\n    if nodo is None:\n        return\n    resultado.append(nodo.valor)     # Visitar nodo\n    preorden(nodo.izq, resultado)    # Recorrer izquierda\n    preorden(nodo.der, resultado)    # Recorrer derecha\n</code></pre> <pre><code>def en_orden(nodo, resultado):\n    if nodo is None:\n        return\n    en_orden(nodo.izq, resultado)\n    resultado.append(nodo.valor)     # Visitar nodo\n    en_orden(nodo.der, resultado)\n</code></pre> <pre><code>def postorden(nodo, resultado):\n    if nodo is None:\n        return\n    postorden(nodo.izq, resultado)\n    postorden(nodo.der, resultado)\n    resultado.append(nodo.valor)     # Visitar nodo\n</code></pre> <p>Tip</p> <p>Cada recorrido sigue una estructura recursiva similar. Lo \u00fanico que cambia es el momento en que se procesa el nodo.</p> <p>Ejemplo visual de recorrido</p> <pre><code>flowchart TB\n    A((10))\n    B((5))\n    C((15))\n    D((3))\n    E((7))\n    F((12))\n    G((20))\n    A --&gt; B\n    A --&gt; C\n    B --&gt; D\n    B --&gt; E\n    C --&gt; F\n    C --&gt; G</code></pre> Tipo Orden de visita Preorden 10, 5, 3, 7, 15, 12, 20 En orden 3, 5, 7, 10, 12, 15, 20 Postorden 3, 7, 5, 12, 20, 15, 10 <p>Usos comunes de los recorridos</p> <ul> <li>En un \u00e1rbol binario de b\u00fasqueda (BST), el recorrido en orden devuelve los valores ordenados.</li> <li>El recorrido postorden se usa com\u00fanmente para eliminar \u00e1rboles o evaluar expresiones.</li> </ul>"},{"location":"material/S2/007/#implementacion-iterativa","title":"Implementaci\u00f3n iterativa","text":"<p>A veces no se desea usar recursi\u00f3n (por ejemplo, por l\u00edmites de pila). En estos casos se utilizan estructuras de pila (<code>stack</code>) para simular la llamada recursiva.</p> PreordenEn orden <pre><code>def preorden_iter(nodo):\n    if nodo is None:\n        return []\n    pila, resultado = [nodo], []\n    while pila:\n        actual = pila.pop()\n        resultado.append(actual.valor)\n        if actual.der:\n            pila.append(actual.der)\n        if actual.izq:\n            pila.append(actual.izq)\n    return resultado\n</code></pre> <pre><code>def en_orden_iter(nodo):\n    resultado, pila = [], []\n    actual = nodo\n    while pila or actual:\n        while actual:\n            pila.append(actual)\n            actual = actual.izq\n        actual = pila.pop()\n        resultado.append(actual.valor)\n        actual = actual.der\n    return resultado\n</code></pre> <p>Tip</p> <ul> <li>En preorden, el nodo se procesa al ser desapilado.</li> <li>En en orden, el nodo se procesa despu\u00e9s de recorrer toda la rama izquierda.</li> </ul>"},{"location":"material/S2/007/#complejidad-temporal-y-espacial","title":"Complejidad temporal y espacial","text":"Tipo de recorrido Tiempo Espacio (pila) Recursivo O(n) O(h) Iterativo O(n) O(h) <p>Donde n es el n\u00famero de nodos y h la altura del \u00e1rbol.</p>"},{"location":"material/S2/007/#ejercicios","title":"Ejercicios","text":"<pre><code>flowchart TB\n    A((9))\n    B((4))\n    C((13))\n    D((2))\n    E((6))\n    F((11))\n    G((15))\n    H((5))\n    I((7))\n    J((14))\n    A --&gt; B\n    A --&gt; C\n    B --&gt; D\n    B --&gt; E\n    E --&gt; H\n    E --&gt; I\n    C --&gt; F\n    C --&gt; G\n    G --&gt; J</code></pre>"},{"location":"material/S2/007/#construir-el-arbol-e-imprimir-los-tres-recorridos","title":"Construir el \u00e1rbol e imprimir los tres recorridos","text":"EnunciadoC\u00f3digoSalida esperada <ol> <li>Construir en Python el \u00e1rbol exactamente como en el diagrama.</li> <li>Implementar funciones recursivas de <code>preorden</code>, <code>en_orden</code> y <code>postorden</code>.</li> <li>Imprimir las listas resultantes.</li> </ol> <pre><code>class Nodo:\n    def __init__(self, valor):\n        self.valor = valor\n        self.izq = None\n        self.der = None\n\n# Construcci\u00f3n manual del \u00e1rbol nuevo\nraiz = Nodo(9)\nraiz.izq = Nodo(4)\nraiz.der = Nodo(13)\n\nraiz.izq.izq = Nodo(2)\nraiz.izq.der = Nodo(6)\nraiz.izq.der.izq = Nodo(5)\nraiz.izq.der.der = Nodo(7)\n\nraiz.der.izq = Nodo(11)\nraiz.der.der = Nodo(15)\nraiz.der.der.izq = Nodo(14)\n\ndef preorden(n, out):\n    if n is None: return\n    out.append(n.valor)\n    preorden(n.izq, out)\n    preorden(n.der, out)\n\ndef en_orden(n, out):\n    if n is None: return\n    en_orden(n.izq, out)\n    out.append(n.valor)\n    en_orden(n.der, out)\n\ndef postorden(n, out):\n    if n is None: return\n    postorden(n.izq, out)\n    postorden(n.der, out)\n    out.append(n.valor)\n\n# Prueba\npo, ino, pso = [], [], []\npreorden(raiz, po)\nen_orden(raiz, ino)\npostorden(raiz, pso)\nprint(\"Preorden   :\", po)\nprint(\"En orden   :\", ino)\nprint(\"Postorden  :\", pso)\n</code></pre> <pre><code>Preorden   : [9, 4, 2, 6, 5, 7, 13, 11, 15, 14]\nEn orden   : [2, 4, 5, 6, 7, 9, 11, 13, 14, 15]\nPostorden  : [2, 5, 7, 6, 4, 11, 14, 15, 13, 9]\n</code></pre>"},{"location":"material/S2/007/#altura-y-tamano-sobre-el-nuevo-arbol","title":"Altura y tama\u00f1o sobre el nuevo \u00e1rbol","text":"EnunciadoC\u00f3digoExplicaci\u00f3n <ol> <li>Implementar <code>altura(nodo)</code> y <code>tamano(nodo)</code>.</li> <li>Verificar los resultados sobre el \u00e1rbol dado.</li> </ol> <pre><code>def altura(n):\n    if n is None:\n        return 0\n    return 1 + max(altura(n.izq), altura(n.der))\n\ndef tamano(n):\n    if n is None:\n        return 0\n    return 1 + tamano(n.izq) + tamano(n.der)\n\nprint(\"Altura:\", altura(raiz))  # esperado: 4\nprint(\"Tama\u00f1o:\", tamano(raiz))  # esperado: 10\n</code></pre> <ul> <li>Altura = 4 porque la ruta m\u00e1s larga puede ser <code>9 \u2192 13 \u2192 15 \u2192 14</code> (4 niveles) o <code>9 \u2192 4 \u2192 6 \u2192 7</code>.</li> <li>Tama\u00f1o = 10 nodos: {9,4,13,2,6,5,7,11,15,14}.</li> </ul>"},{"location":"material/S2/007/#versiones-iterativas-de-recorridos","title":"Versiones iterativas de recorridos","text":"EnunciadoC\u00f3digo <p>Reescribir los recorridos preorden y en orden en forma iterativa y comparar los resultados con la versi\u00f3n recursiva.</p> <pre><code>def preorden_iter(n):\n    if n is None: return []\n    pila, out = [n], []\n    while pila:\n        x = pila.pop()\n        out.append(x.valor)\n        if x.der: pila.append(x.der)\n        if x.izq: pila.append(x.izq)\n    return out\n\ndef en_orden_iter(n):\n    out, pila = [], []\n    act = n\n    while pila or act:\n        while act:\n            pila.append(act)\n            act = act.izq\n        act = pila.pop()\n        out.append(act.valor)\n        act = act.der\n    return out\n\nprint(\"Preorden iter:\", preorden_iter(raiz))  # [9, 4, 2, 6, 5, 7, 13, 11, 15, 14]\nprint(\"En orden iter:\", en_orden_iter(raiz))  # [2, 4, 5, 6, 7, 9, 11, 13, 14, 15]\n</code></pre>"},{"location":"material/S2/008/","title":"Clase 8: Ejercicios de \u00e1rboles binarios","text":"<p>En esta clase, se van a repasar los conceptos vistos la clase anterior de \u00e1rboles binarios, as\u00ed como aplicar el tema en ejercicios pr\u00e1cticos.</p>"},{"location":"material/S2/008/#verificacion-de-balance-en-un-arbol-binario","title":"Verificaci\u00f3n de balance en un \u00e1rbol binario","text":"<p>Un \u00e1rbol binario balanceado es aquel donde las alturas de sus sub\u00e1rboles izquierdo y derecho no difieren en m\u00e1s de una unidad para cada nodo. Esto garantiza que las operaciones como b\u00fasqueda o recorrido sean eficientes, y evita que el \u00e1rbol se degenere en una lista.</p> <p>Definici\u00f3n formal</p> <p>Un \u00e1rbol binario est\u00e1 balanceado si, para cada nodo: \\(|altura(\\text{izquierdo}) - altura(\\text{derecho})| \\le 1\\) y ambos sub\u00e1rboles tambi\u00e9n est\u00e1n balanceados.</p>"},{"location":"material/S2/008/#idea-principal","title":"Idea principal","text":"<p>El algoritmo se basa en recursi\u00f3n:</p> <ol> <li>Calcular la altura del sub\u00e1rbol izquierdo.</li> <li>Calcular la altura del sub\u00e1rbol derecho.</li> <li>Verificar que la diferencia sea menor o igual a 1.</li> <li>Aplicar el mismo proceso recursivamente a cada hijo.</li> </ol>"},{"location":"material/S2/008/#implementacion","title":"Implementaci\u00f3n","text":"<pre><code>class Nodo:\n    def __init__(self, valor):\n        self.valor = valor\n        self.izq = None\n        self.der = None\n\n# Calcula la altura de un \u00e1rbol\ndef altura(raiz):\n    if raiz is None:\n        return 0\n    return 1 + max(altura(raiz.izq), altura(raiz.der))\n\n# Verifica si el \u00e1rbol est\u00e1 balanceado\ndef esta_balanceado(raiz):\n    if raiz is None:\n        return True\n\n    altura_izq = altura(raiz.izq)\n    altura_der = altura(raiz.der)\n    diferencia = abs(altura_izq - altura_der)\n\n    return (diferencia &lt;= 1 and\n            esta_balanceado(raiz.izq) and\n            esta_balanceado(raiz.der))\n\n# Ejemplo de uso\nraiz = Nodo(1)\nraiz.izq = Nodo(2)\nraiz.der = Nodo(3)\nraiz.izq.izq = Nodo(4)\nraiz.izq.der = Nodo(5)\nraiz.der.der = Nodo(6)\n\nif esta_balanceado(raiz):\n    print(\"\u00c1rbol balanceado\")    # (1)!\nelse:\n    print(\"\u00c1rbol desbalanceado\")\n</code></pre> <ol> <li>Esta es la l\u00ednea que se imprime.</li> </ol>"},{"location":"material/S2/008/#arboles-binarios-de-busqueda-bst","title":"\u00c1rboles Binarios de B\u00fasqueda (BST)","text":"<p>Un \u00c1rbol Binario de B\u00fasqueda (BST) es una estructura que mantiene sus elementos ordenados de manera jer\u00e1rquica, lo cual permite realizar operaciones como b\u00fasqueda, inserci\u00f3n y eliminaci\u00f3n de forma eficiente.</p> <p>Propiedad del BST</p> <p>Para cada nodo del \u00e1rbol:</p> <ul> <li>Todos los valores del sub\u00e1rbol izquierdo son menores que el valor del nodo.</li> <li>Todos los valores del sub\u00e1rbol derecho son mayores que el valor del nodo.</li> </ul>"},{"location":"material/S2/008/#relacion-con-el-recorrido-inorden","title":"Relaci\u00f3n con el recorrido inorden","text":"<p>Un recorrido inorden en un BST siempre devuelve los valores en orden ascendente. Por ejemplo, si se insertan los valores <code>50, 30, 70, 20, 40, 60, 80</code>, el recorrido inorden producir\u00e1:</p> <pre><code>20, 30, 40, 50, 60, 70, 80\n</code></pre>"},{"location":"material/S2/008/#representacion-visual","title":"Representaci\u00f3n visual","text":"<pre><code>graph TD\n    A[\"50\"]\n    A --&gt; B[\"30\"]\n    A --&gt; C[\"70\"]\n    B --&gt; D[\"20\"]\n    B --&gt; E[\"40\"]\n    C --&gt; F[\"60\"]\n    C --&gt; G[\"80\"]</code></pre> <p>Note</p> <p>Cada inserci\u00f3n coloca el nuevo valor en la posici\u00f3n correcta seg\u00fan la propiedad del BST.</p>"},{"location":"material/S2/008/#implementacion_1","title":"Implementaci\u00f3n","text":"<pre><code>class Nodo:\n    def __init__(self, valor):\n        self.valor = valor\n        self.izq = None\n        self.der = None\n\n# Inserta un valor en el BST de forma recursiva\ndef insertar(raiz, valor):\n    if raiz is None:\n        # Ac\u00e1 se crea el nuevo nodo\n        return Nodo(valor)\n\n    if valor &lt; raiz.valor:\n        raiz.izq = insertar(raiz.izq, valor)\n    elif valor &gt; raiz.valor:\n        raiz.der = insertar(raiz.der, valor)\n    # Si el valor ya existe, no se inserta nuevamente\n    return raiz\n\n# Recorrido inorden: en orden ascendente\ndef inorden(raiz):\n    if raiz:\n        inorden(raiz.izq)\n        print(raiz.valor, end=\" \")\n        inorden(raiz.der)\n\n# Ejemplo de uso\nraiz = None\nvalores = [50, 30, 70, 20, 40, 60, 80]\n\nfor v in valores:\n    raiz = insertar(raiz, v)\n\nprint(\"Recorrido inorden del BST:\")\ninorden(raiz)\n</code></pre>"},{"location":"material/S2/008/#ejercicio-1-comparar-dos-arboles","title":"Ejercicio 1: Comparar dos \u00e1rboles","text":"<p>Se busca determinar si dos \u00e1rboles binarios tienen la misma estructura, independientemente de los valores almacenados en cada nodo.</p> <p>Objetivo</p> <p>Aplicar recursi\u00f3n para comparar la forma estructural de dos \u00e1rboles, sin importar los valores que contengan. Posteriormente, extender el algoritmo para verificar tambi\u00e9n si son id\u00e9nticos (misma estructura y mismos valores).</p>"},{"location":"material/S2/008/#idea-general","title":"Idea general","text":"<ol> <li>Si ambos nodos son <code>None</code>, se consideran iguales.</li> <li>Si uno es <code>None</code> y el otro no, se consideran diferentes.</li> <li>En caso contrario, se comparan:</li> <li>Las estructuras del sub\u00e1rbol izquierdo.</li> <li>Las estructuras del sub\u00e1rbol derecho.</li> <li>(Extensi\u00f3n) Los valores almacenados en cada nodo.</li> </ol>"},{"location":"material/S2/008/#representacion-visual_1","title":"Representaci\u00f3n visual","text":"<pre><code>graph TD\n    subgraph \u00c1rbol 1\n    A1[\"A\"] --&gt; B1[\"B\"]\n    A1 --&gt; C1[\"C\"]\n    B1 --&gt; D1[\"D\"]\n    end\n\n    subgraph \u00c1rbol 2\n    A2[\"X\"] --&gt; B2[\"Y\"]\n    A2 --&gt; C2[\"Z\"]\n    B2 --&gt; D2[\"W\"]\n    end</code></pre> <p>Ambos \u00e1rboles poseen la misma estructura, aunque los valores sean distintos.</p>"},{"location":"material/S2/008/#implementacion_2","title":"Implementaci\u00f3n","text":"<pre><code>class Nodo:\n    def __init__(self, valor):\n        self.valor = valor\n        self.izq = None\n        self.der = None\n\n# Compara la estructura de dos \u00e1rboles\ndef misma_estructura(a, b):\n    if a is None and b is None:\n        return True\n    if a is None or b is None:\n        return False\n    return (misma_estructura(a.izq, b.izq) and\n            misma_estructura(a.der, b.der))\n\n# Extensi\u00f3n: compara tambi\u00e9n los valores\ndef son_identicos(a, b):\n    if a is None and b is None:\n        return True\n    if a is None or b is None:\n        return False\n    return (a.valor == b.valor and\n            son_identicos(a.izq, b.izq) and\n            son_identicos(a.der, b.der))\n\n# Ejemplo de uso\n\n# \u00c1rbol 1\na = Nodo(1)\na.izq = Nodo(2)\na.der = Nodo(3)\n\n# \u00c1rbol 2\nb = Nodo(10)\nb.izq = Nodo(20)\nb.der = Nodo(30)\n\nprint(\"\u00bfTienen la misma estructura?\", misma_estructura(a, b)) # (1)!\nprint(\"\u00bfSon id\u00e9nticos?\", son_identicos(a, b))                 # (2)!\n</code></pre> <ol> <li><code>True</code></li> <li><code>False</code></li> </ol>"},{"location":"material/S2/008/#ejercicio-2-arbol-espejo","title":"Ejercicio 2: \u00c1rbol espejo","text":"<p>El \u00e1rbol espejo de un \u00e1rbol binario se obtiene al intercambiar los sub\u00e1rboles izquierdo y derecho de todos los nodos. El resultado es una versi\u00f3n reflejada del \u00e1rbol original.</p> <p>Objetivo</p> <p>Aplicar recursi\u00f3n para transformar un \u00e1rbol en su versi\u00f3n espejo e interpretar los cambios en los recorridos.</p>"},{"location":"material/S2/008/#representacion-visual_2","title":"Representaci\u00f3n visual","text":"<pre><code>graph TD\n    subgraph \"\u00c1rbol original\"\n    A1[\"A\"]\n    A1 --&gt; B1[\"B\"]\n    A1 --&gt; C1[\"C\"]\n    B1 --&gt; D1[\"D\"]\n    B1 --&gt; E1[\"E\"]\n    end\n\n    subgraph \"\u00c1rbol espejo\"\n    A2[\"A\"]\n    A2 --&gt; C2[\"C\"]\n    A2 --&gt; B2[\"B\"]\n    B2 --&gt; E2[\"E\"]\n    B2 --&gt; D2[\"D\"]\n    end</code></pre>"},{"location":"material/S2/008/#implementacion_3","title":"Implementaci\u00f3n","text":"<pre><code>class Nodo:\n    def __init__(self, valor):\n        self.valor = valor\n        self.izq = None\n        self.der = None\n\n# Convierte un \u00e1rbol a su versi\u00f3n espejo\ndef espejo(raiz):\n    if raiz is None:\n        return None\n\n    raiz.izq, raiz.der = raiz.der, raiz.izq  # Intercambia los hijos\n    espejo(raiz.izq)\n    espejo(raiz.der)\n    return raiz\n\n# Recorrido inorden\ndef inorden(raiz):\n    if raiz:\n        inorden(raiz.izq)\n        print(raiz.valor, end=\" \")\n        inorden(raiz.der)\n\n# Ejemplo de uso\n\n# \u00c1rbol original\nraiz = Nodo(\"A\")\nraiz.izq = Nodo(\"B\")\nraiz.der = Nodo(\"C\")\nraiz.izq.izq = Nodo(\"D\")\nraiz.izq.der = Nodo(\"E\")\n\nprint(\"Recorrido inorden original:\")          # (1)!\ninorden(raiz)\n\nespejo(raiz)\n\nprint(\"Recorrido inorden del \u00e1rbol espejo:\")  # (2)!\ninorden(raiz)\n</code></pre> <ol> <li><code>Recorrido inorden original: D B E A C</code></li> <li><code>Recorrido inorden del \u00e1rbol espejo: C A E B D</code></li> </ol>"},{"location":"material/S2/008/#ejercicio-3-arbol-de-expresiones-matematicas","title":"Ejercicio 3: \u00c1rbol de expresiones matem\u00e1ticas","text":"<p>Un \u00e1rbol de expresiones representa una operaci\u00f3n aritm\u00e9tica donde cada nodo interno es un operador (<code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>) y cada hoja es un operando num\u00e9rico. Este tipo de \u00e1rboles se utiliza en int\u00e9rpretes y compiladores para evaluar expresiones.</p> <p>Objetivo</p> <p>Comprender c\u00f3mo los \u00e1rboles binarios pueden representar operaciones matem\u00e1ticas y c\u00f3mo evaluarlas mediante recorridos recursivos.</p>"},{"location":"material/S2/008/#ejemplo-visual","title":"Ejemplo visual","text":"<pre><code>graph TD\n    A[\"*\"]\n    A --&gt; B[\"+\"]\n    A --&gt; C[\"4\"]\n    B --&gt; D[\"3\"]\n    B --&gt; E[\"2\"]</code></pre> <p>La expresi\u00f3n representada por este \u00e1rbol es: \\((3 + 2) \\cdot 4\\)</p>"},{"location":"material/S2/008/#implementacion_4","title":"Implementaci\u00f3n","text":"<pre><code>class Nodo:\n    def __init__(self, valor):\n        self.valor = valor\n        self.izq = None\n        self.der = None\n\n# Eval\u00faa una expresi\u00f3n aritm\u00e9tica representada como \u00e1rbol\ndef evaluar(raiz):\n    if raiz is None:\n        return 0\n\n    # Si es hoja, devuelve el valor num\u00e9rico\n    if raiz.izq is None and raiz.der is None:\n        return int(raiz.valor)\n\n    # Eval\u00faa los sub\u00e1rboles\n    izq = evaluar(raiz.izq)\n    der = evaluar(raiz.der)\n\n    # Aplica el operador\n    if raiz.valor == '+':\n        return izq + der\n    elif raiz.valor == '-':\n        return izq - der\n    elif raiz.valor == '*':\n        return izq * der\n    elif raiz.valor == '/':\n        return izq / der\n\n# Ejemplo de uso\nraiz = Nodo('*')\nraiz.izq = Nodo('+')\nraiz.der = Nodo('4')\nraiz.izq.izq = Nodo('3')\nraiz.izq.der = Nodo('2')\n\nresultado = evaluar(raiz)\nprint(\"Resultado:\", resultado)  # (1)!\n</code></pre> <ol> <li><code>Resultado: 20</code></li> </ol>"},{"location":"material/S2/008/#ejercicio-4-arbol-de-decisiones","title":"Ejercicio 4: \u00c1rbol de decisiones","text":"<p>Un \u00e1rbol de decisiones permite modelar procesos en los que se toman decisiones basadas en condiciones o respuestas. Cada nodo representa una pregunta, y cada hoja representa una acci\u00f3n o resultado final.</p> <p>Objetivo</p> <p>Aplicar \u00e1rboles binarios para representar procesos de decisi\u00f3n y recorrerlos seg\u00fan las respuestas del usuario.</p>"},{"location":"material/S2/008/#ejemplo-visual_1","title":"Ejemplo visual","text":"<pre><code>graph TD\n    A[\"\u00bfTiene fiebre?\"]\n    A --&gt;|\"S\u00ed\"| B[\"\u00bfTiene tos?\"]\n    A --&gt;|\"No\"| C[\"\u00bfDolor muscular?\"]\n    B --&gt;|\"S\u00ed\"| F[\"Gripe\"]\n    B --&gt;|\"No\"| G[\"Fiebre com\u00fan\"]\n    C --&gt;|\"S\u00ed\"| H[\"Estr\u00e9s\"]\n    C --&gt;|\"No\"| I[\"Normal\"]</code></pre>"},{"location":"material/S2/008/#implementacion_5","title":"Implementaci\u00f3n","text":"<pre><code>class NodoDecision:\n    def __init__(self, pregunta, si=None, no=None):\n        self.pregunta = pregunta\n        self.si = si\n        self.no = no\n\n# Recorre el \u00e1rbol seg\u00fan las respuestas del usuario\ndef recorrer(raiz):\n    if raiz.si is None and raiz.no is None:\n        print(\"Diagn\u00f3stico:\", raiz.pregunta)\n        return\n\n    respuesta = input(raiz.pregunta + \" (s/n): \").lower()\n    if respuesta == \"s\":\n        recorrer(raiz.si)\n    elif respuesta == \"n\":\n        recorrer(raiz.no)\n    else:\n        print(\"Respuesta no v\u00e1lida.\")\n        recorrer(raiz)\n\n# Ejemplo de uso\narbol = NodoDecision(\"\u00bfTiene fiebre?\",\n    NodoDecision(\"\u00bfTiene tos?\",\n        NodoDecision(\"Gripe\"),\n        NodoDecision(\"Fiebre com\u00fan\")\n    ),\n    NodoDecision(\"\u00bfTiene dolor muscular?\",\n        NodoDecision(\"Estr\u00e9s\"),\n        NodoDecision(\"Normal\")\n    )\n)\n\nrecorrer(arbol)\n</code></pre> <p>Posible interacci\u00f3n</p> <pre><code>\u00bfTiene fiebre? (s/n): s\n\u00bfTiene tos? (s/n): n\nDiagn\u00f3stico: Fiebre com\u00fan\n</code></pre>"},{"location":"material/S2/008/#ejercicio-5-camino-mas-largo-diametro-del-arbol","title":"Ejercicio 5: Camino m\u00e1s largo (di\u00e1metro del \u00e1rbol)","text":"<p>El di\u00e1metro de un \u00e1rbol binario es la longitud del camino m\u00e1s largo entre dos hojas. Este camino puede pasar por la ra\u00edz o por cualquier nodo intermedio.</p> <p>Objetivo</p> <p>Implementar un algoritmo recursivo para calcular el di\u00e1metro de un \u00e1rbol binario.</p>"},{"location":"material/S2/008/#idea-principal_1","title":"Idea principal","text":"<p>El di\u00e1metro se obtiene al comparar tres valores:</p> <ol> <li>El di\u00e1metro del sub\u00e1rbol izquierdo.</li> <li>El di\u00e1metro del sub\u00e1rbol derecho.</li> <li>La suma de las alturas de ambos sub\u00e1rboles (camino que pasa por el nodo actual).</li> </ol> <p>El mayor de los tres corresponde al di\u00e1metro del \u00e1rbol.</p>"},{"location":"material/S2/008/#representacion-visual_3","title":"Representaci\u00f3n visual","text":"<pre><code>graph TD\n    A[\"1\"]\n    A --&gt; B[\"2\"]\n    A --&gt; C[\"3\"]\n    B --&gt; D[\"4\"]\n    B --&gt; E[\"5\"]\n    D --&gt; F[\"6\"]</code></pre> <p>El camino m\u00e1s largo es <code>6 \u2192 4 \u2192 2 \u2192 1 \u2192 3</code>, con una longitud de 4.</p>"},{"location":"material/S2/008/#implementacion_6","title":"Implementaci\u00f3n","text":"<pre><code>class Nodo:\n    def __init__(self, valor):\n        self.valor = valor\n        self.izq = None\n        self.der = None\n\ndef altura(raiz):\n    if raiz is None:\n        return 0\n    return 1 + max(altura(raiz.izq), altura(raiz.der))\n\ndef diametro(raiz):\n    if raiz is None:\n        return 0\n\n    altura_izq = altura(raiz.izq)\n    altura_der = altura(raiz.der)\n\n    diam_izq = diametro(raiz.izq)\n    diam_der = diametro(raiz.der)\n\n    return max(altura_izq + altura_der + 1, max(diam_izq, diam_der))\n\n# Ejemplo de uso\nraiz = Nodo(1)\nraiz.izq = Nodo(2)\nraiz.der = Nodo(3)\nraiz.izq.izq = Nodo(4)\nraiz.izq.der = Nodo(5)\nraiz.izq.izq.izq = Nodo(6)\n\nprint(\"Di\u00e1metro del \u00e1rbol:\", diametro(raiz))  # (1)!\n</code></pre> <ol> <li><code>Di\u00e1metro del \u00e1rbol: 5</code></li> </ol>"},{"location":"material/S2/008/#ejercicio-6-jerarquia-organizacional","title":"Ejercicio 6: Jerarqu\u00eda organizacional","text":"<p>Un \u00e1rbol binario puede representar la estructura jer\u00e1rquica de una organizaci\u00f3n, donde cada nodo representa un empleado y los sub\u00e1rboles representan sus subordinados.</p> <p>Objetivo</p> <p>Aplicar \u00e1rboles binarios para modelar estructuras jer\u00e1rquicas y analizar informaci\u00f3n como niveles, cantidad de empleados o jerarqu\u00edas m\u00e1ximas.</p>"},{"location":"material/S2/008/#ejemplo-visual_2","title":"Ejemplo visual","text":"<pre><code>graph TD\n    A[\"Director General\"]\n    A --&gt; B[\"Gerente de Ventas\"]\n    A --&gt; C[\"Gerente de Producci\u00f3n\"]\n    B --&gt; D[\"Supervisor 1\"]\n    B --&gt; E[\"Supervisor 2\"]\n    C --&gt; F[\"T\u00e9cnico 1\"]\n    C --&gt; G[\"T\u00e9cnico 2\"]</code></pre>"},{"location":"material/S2/008/#implementacion_7","title":"Implementaci\u00f3n","text":"<pre><code>class Empleado:\n    def __init__(self, nombre):\n        self.nombre = nombre\n        self.izq = None   # Subordinado izquierdo\n        self.der = None   # Subordinado derecho\n\n# Cuenta el total de empleados\ndef contar_empleados(raiz):\n    if raiz is None:\n        return 0\n    return 1 + contar_empleados(raiz.izq) + contar_empleados(raiz.der)\n\n# Muestra la jerarqu\u00eda con indentaci\u00f3n\ndef mostrar_jerarquia(raiz, nivel=0):\n    if raiz is not None:\n        print(\"  \" * nivel + \"- \" + raiz.nombre)\n        mostrar_jerarquia(raiz.izq, nivel + 1)\n        mostrar_jerarquia(raiz.der, nivel + 1)\n\n# Ejemplo de uso\nraiz = Empleado(\"Director General\")\nraiz.izq = Empleado(\"Gerente de Ventas\")\nraiz.der = Empleado(\"Gerente de Producci\u00f3n\")\nraiz.izq.izq = Empleado(\"Supervisor 1\")\nraiz.izq.der = Empleado(\"Supervisor 2\")\nraiz.der.izq = Empleado(\"T\u00e9cnico 1\")\nraiz.der.der = Empleado(\"T\u00e9cnico 2\")\n\nprint(\"Estructura jer\u00e1rquica:\")\nmostrar_jerarquia(raiz)\n\nprint(\"\\nTotal de empleados:\", contar_empleados(raiz))\n</code></pre> <p>Salida esperada:</p> <pre><code>Estructura jer\u00e1rquica:\n- Director General\n  - Gerente de Ventas\n    - Supervisor 1\n    - Supervisor 2\n  - Gerente de Producci\u00f3n\n    - T\u00e9cnico 1\n    - T\u00e9cnico 2\n\nTotal de empleados: 7\n</code></pre>"},{"location":"material/S2/009/","title":"Clase 9: Aplicaciones y ejercicios sobre grafos","text":"<p>En esta clase, se van a aplicar los conceptos de representaci\u00f3n, recorrido y detecci\u00f3n de ciclos en grafos para resolver problemas pr\u00e1cticos de an\u00e1lisis y modelado.</p>"},{"location":"material/S2/009/#objetivos","title":"Objetivos","text":"<ul> <li>Modelar situaciones reales mediante grafos dirigidos y no dirigidos.</li> <li>Aplicar DFS y BFS para resolver problemas de conectividad y b\u00fasqueda.</li> <li>Analizar la existencia de componentes conexas en diferentes contextos.</li> </ul>"},{"location":"material/S2/009/#ejercicio-1-verificar-conectividad-en-un-grafo-no-dirigido","title":"Ejercicio 1: Verificar conectividad en un grafo no dirigido","text":"<p>Planteamiento</p> <p>Dado un grafo no dirigido, determine si todos los v\u00e9rtices est\u00e1n conectados.</p> <p>Sugerencia</p> <ul> <li>Use DFS o BFS desde un v\u00e9rtice inicial.</li> <li>Si alg\u00fan nodo no fue visitado, el grafo no es conexo.</li> </ul> <pre><code>graph LR\nA --- B\nA --- C\nB --- D\nC --- E\nF</code></pre> Soluci\u00f3n<pre><code>def dfs(nodo):\n    if nodo not in visitados:\n        visitados.add(nodo)\n        for vecino in grafo[nodo]:\n            dfs(vecino)\n\ngrafo = {\n          'A': ['B', 'C'],\n          'B': ['A', 'D'],\n          'C': ['A', 'E'],\n          'D': ['B'],\n          'E': ['C']\n        }\n\nvisitados = set()\n\ndfs('A')\n\nif len(visitados) == len(grafo):\n    print(\"El grafo es conexo.\")\nelse:\n    print(\"El grafo no es conexo.\")\n</code></pre>"},{"location":"material/S2/009/#ejercicio-2-propagacion-de-informacion-en-una-red","title":"Ejercicio 2: Propagaci\u00f3n de informaci\u00f3n en una red","text":"<p>Planteamiento</p> <p>Una empresa desea simular c\u00f3mo se propaga un mensaje en una red interna de computadoras. Cada computadora est\u00e1 conectada con algunas otras. Si una computadora recibe el mensaje, lo reenv\u00eda inmediatamente a todas las conectadas.</p> <p>Determine cu\u00e1ntas computadoras recibir\u00e1n el mensaje, dado un nodo inicial.</p> <p>Sugerencia</p> <ul> <li>Modele el problema como un grafo no dirigido.</li> <li>Use BFS para recorrer los equipos que recibir\u00e1n el mensaje.</li> <li>El n\u00famero total de nodos visitados representa la cantidad de computadoras notificadas.</li> </ul> <pre><code>graph LR\nA --- B\nA --- C\nB --- D\nB --- E\nC --- F\nE --- F\n\n%% Anotaci\u00f3n conceptual de niveles:\n%% Nivel 0: A\n%% Nivel 1: B, C\n%% Nivel 2: D, E, F</code></pre> Soluci\u00f3n<pre><code>from collections import deque\n\nred = {\n    'A': ['B', 'C'],\n    'B': ['A', 'D', 'E'],\n    'C': ['A', 'F'],\n    'D': ['B'],\n    'E': ['B', 'F'],\n    'F': ['C', 'E']\n    }\n\ninicio = 'A'\nvisitados = set([inicio])\ncola = deque([inicio])\n\nwhile cola:\n    nodo = cola.popleft()\n    for vecino in red[nodo]:\n        if vecino not in visitados:\n            visitados.add(vecino)\n            cola.append(vecino)\n\nprint(f\"Total de computadoras notificadas: {len(visitados)}\")\n</code></pre>"},{"location":"material/S2/009/#ejercicio-3-rutas-en-un-mapa-de-ciudades","title":"Ejercicio 3: Rutas en un mapa de ciudades","text":"<p>Planteamiento</p> <p>Modele un conjunto de ciudades y carreteras como un grafo no dirigido. Determine si es posible llegar de una ciudad origen a una ciudad destino. Implemente una b\u00fasqueda BFS para encontrar la ruta m\u00e1s corta (en n\u00famero de saltos).</p> <p>Ejemplo de entrada:</p> <pre><code>Ciudades: A, B, C, D, E\nCarreteras: A-B, A-C, B-D, C-E\nBuscar ruta de A a E\n</code></pre> Soluci\u00f3n<pre><code>from collections import deque\n\ngrafo = {\n    'A': ['B', 'C'],\n    'B': ['A', 'D'],\n    'C': ['A', 'E'],\n    'D': ['B'],\n    'E': ['C']\n}\n\ndef bfs_ruta(origen, destino):\n    visitados = set([origen])\n    cola = deque([[origen]])\n\n    while cola:\n        camino = cola.popleft()\n        nodo = camino[-1]\n\n        if nodo == destino:\n            return camino\n\n        for vecino in grafo[nodo]:\n            if vecino not in visitados:\n                visitados.add(vecino)\n                cola.append(camino + [vecino])\n\n    return None\n\nruta = bfs_ruta('A', 'E')\nprint(\"Ruta encontrada:\", ruta)\n</code></pre>"},{"location":"material/S2/009/#ejercicio-4-dependencias-de-tareas","title":"Ejercicio 4: Dependencias de tareas","text":"<p>Planteamiento</p> <p>Se tiene un conjunto de tareas con dependencias. Modele el problema como un grafo dirigido, donde una arista <code>u \u2192 v</code> indica que <code>u</code> debe realizarse antes que <code>v</code>. Determine si las tareas pueden completarse (es decir, si no hay ciclos).</p> <p>Sugerencia</p> <ul> <li>Si no hay ciclo, las tareas se pueden ejecutar en alg\u00fan orden.</li> </ul> <p>Ejemplo de entrada:</p> <pre><code>dependencias = {\n'A': ['B'],\n'B': ['C'],\n'C': []\n}\n</code></pre> Sin cicloCon ciclo <p><pre><code>graph LR\n  A --&gt; B\n  B --&gt; C\n  A --&gt; C</code></pre> - Realizable (<code>A, B, C</code>).</p> <p><pre><code>graph LR\n  A --&gt; B\n  B --&gt; C\n  C --&gt; A</code></pre> - No realizable (ciclo).</p> Soluci\u00f3n<pre><code># Detecci\u00f3n de ciclo en grafo dirigido mediante DFS y pila de recursion\ndependencias = {\n    'A': ['B'],\n    'B': ['C'],\n    'C': []\n}\n\nvisitado = set()\nen_pila = set()\n\ndef hay_ciclo(u):\n    visitado.add(u)\n    en_pila.add(u)\n    for v in dependencias[u]:\n        if v not in visitado and hay_ciclo(v):\n            return True\n        if v in en_pila:\n            return True\n    en_pila.remove(u)\n    return False\n\nciclo = any(hay_ciclo(u) for u in dependencias if u not in visitado)\nprint(\"Con ciclo\" if ciclo else \"Sin ciclo\")\n</code></pre>"},{"location":"material/S2/009/#ejercicio-5-componentes-conexas","title":"Ejercicio 5: Componentes conexas","text":"<p>Planteamiento</p> <p>Dado un grafo no dirigido, determine cu\u00e1ntas componentes conexas tiene. Cada recorrido DFS que inicie desde un nodo no visitado representa una nueva componente.</p> <pre><code>graph LR\n  subgraph C1\n    A --- B\n  end\n  subgraph C2\n    C --- D\n  end\n  subgraph C3\n    E\n  end</code></pre> Soluci\u00f3n<pre><code>grafo = {\n    'A': ['B'],\n    'B': ['A'],\n    'C': ['D'],\n    'D': ['C'],\n    'E': []\n    }\n\nvisitados = set()\ncomponentes = 0\n\ndef dfs(nodo):\n    if nodo not in visitados:\n        visitados.add(nodo)\n        for vecino in grafo[nodo]:\n            dfs(vecino)\n\nfor nodo in grafo:\n    if nodo not in visitados:\n        dfs(nodo)\n        componentes += 1\n\nprint(\"N\u00famero de componentes conexas:\", componentes)\n</code></pre>"},{"location":"material/S2/010/","title":"Clase 10: Introducci\u00f3n a Git y GitHub","text":"<p>\u00bfPor qu\u00e9 usar un sistema de control de versiones?</p> <p>En el desarrollo de software, los proyectos evolucionan constantemente. Se agregan funcionalidades, se corrigen errores y se prueban nuevas ideas. Sin un sistema que lleve registro de todos estos cambios, es muy f\u00e1cil perder trabajo o sobrescribir c\u00f3digo.</p> <p>Git resuelve estos problemas al permitir:</p> <ul> <li>Guardar diferentes versiones del proyecto (<code>commits</code>).</li> <li>Retroceder en el tiempo si algo falla.</li> <li>Trabajar en equipo sin sobrescribir archivos.</li> <li>Saber qui\u00e9n hizo qu\u00e9 y cu\u00e1ndo.</li> </ul> <p>GitHub, por su parte, es una plataforma en l\u00ednea que permite:</p> <ul> <li>Almacenar repositorios Git en la nube.</li> <li>Colaborar con otros desarrolladores.</li> <li>Revisar c\u00f3digo, crear ramas, reportar errores y gestionar proyectos.</li> </ul> <p>Resumen</p> <ul> <li>Git: Sistema local que gestiona las versiones del proyecto.</li> <li>GitHub: Plataforma en la nube donde se comparten y colaboran los repositorios Git.</li> </ul>"},{"location":"material/S2/010/#conceptos-fundamentales-de-git","title":"Conceptos fundamentales de Git","text":"<p>Git organiza el trabajo en tres \u00e1reas principales:</p> \u00c1rea Descripci\u00f3n Working Directory Donde se trabaja directamente con los archivos (el c\u00f3digo fuente actual). Staging Area (Index) Zona temporal donde se preparan los archivos para ser guardados. Repositorio local (.git) Donde se almacenan permanentemente las versiones confirmadas (commits). <p>Git registra cada cambio como un snapshot</p> <p>Cada commit es como una foto del proyecto en un momento determinado. Esto permite comparar versiones y restaurar estados anteriores f\u00e1cilmente.</p>"},{"location":"material/S2/010/#que-es-un-repositorio","title":"\u00bfQu\u00e9 es un repositorio?","text":"<p>Un repositorio es una carpeta donde Git almacena todo el historial de cambios del proyecto. Al inicializar un repositorio con:</p> <pre><code>git init\n</code></pre> <p>Se crea una subcarpeta oculta llamada <code>.git</code> que contiene:</p> <ul> <li>Los commits y metadatos.</li> <li>Las ramas (branches).</li> <li>Las configuraciones locales.</li> </ul> <p>Note</p> <p>Nunca se debe borrar la carpeta <code>.git</code>, pues se perder\u00eda todo el historial del proyecto.</p>"},{"location":"material/S2/010/#que-es-un-commit","title":"\u00bfQu\u00e9 es un commit?","text":"<p>Un commit representa una versi\u00f3n espec\u00edfica del proyecto con un mensaje descriptivo. Cada commit tiene un identificador \u00fanico (<code>SHA</code>) que lo diferencia de los dem\u00e1s.</p> <pre><code>git commit -m \"Agrega funci\u00f3n de login\"\n</code></pre> <p>Buenas pr\u00e1cticas</p> <ul> <li>Usar mensajes claros: <code>\"Agrega m\u00f3dulo de autenticaci\u00f3n\"</code>, <code>\"Corrige bug en c\u00e1lculo de total\"</code>.</li> <li>Realizar commits peque\u00f1os y frecuentes.</li> </ul>"},{"location":"material/S2/010/#diagrama-conceptual-flujo-basico-de-git","title":"Diagrama conceptual: flujo b\u00e1sico de Git","text":"<pre><code>sequenceDiagram\n    actor Usuario\n    participant WD as Working Directory\n    participant SA as Staging Area\n    participant RL as Repositorio Local\n    participant RR as Repositorio Remoto (GitHub)\n\n    Usuario-&gt;&gt;WD: Modifica archivos\n    Usuario-&gt;&gt;SA: git add archivo.py\n    Usuario-&gt;&gt;RL: git commit -m \"Mensaje\"\n    Usuario-&gt;&gt;RR: git push\n    RR--&gt;&gt;RL: git pull</code></pre>"},{"location":"material/S2/010/#instalacion-y-configuracion-inicial","title":"Instalaci\u00f3n y configuraci\u00f3n inicial","text":"<p>Instalaci\u00f3n de Git</p> <p>Git se puede descargar desde su p\u00e1gina oficial git-scm.com. En la instalaci\u00f3n se recomienda dejar las opciones por defecto.</p> <p>Una vez instalado, se puede verificar su versi\u00f3n con:</p> <pre><code>git --version\n</code></pre>"},{"location":"material/S2/010/#configuracion-del-usuario","title":"Configuraci\u00f3n del usuario","text":"<p>Git necesita saber qui\u00e9n realiza los cambios para poder asociarlos a los commits. Por eso se configura el nombre y el correo electr\u00f3nico:</p> <pre><code>git config --global user.name \"Nombre\"\ngit config --global user.email \"email@ejemplo.com\"\n</code></pre> <p>Importante</p> <p>Use el mismo nombre y correo de su cuenta de GitHub</p> <p>Para revisar la configuraci\u00f3n:</p> <pre><code>git config --list\n</code></pre> <p>Tip</p> <p>Esta informaci\u00f3n se guarda en un archivo oculto llamado <code>.gitconfig</code> dentro del directorio del usuario. Tambi\u00e9n se puede modificar directamente desde un editor de texto.</p>"},{"location":"material/S2/010/#comandos-esenciales-de-git","title":"Comandos esenciales de Git","text":"<p>El flujo de trabajo t\u00edpico con Git puede resumirse en cuatro pasos principales: inicializar, agregar, guardar y sincronizar.</p> <pre><code>graph TD\n    A[Crear repositorio] --&gt; B[Agregar archivos]\n    B --&gt; C[Confirmar cambios]\n    C --&gt; D[Sincronizar con GitHub]</code></pre>"},{"location":"material/S2/010/#crear-o-clonar-un-repositorio","title":"Crear o clonar un repositorio","text":"<p>Crear un repositorio nuevo:</p> <pre><code>git init\n</code></pre> <p>Pr\u00e1ctica m\u00e1s com\u00fan</p> <p>Lo usual es crear el repositorio en GitHub y luego clonarlo con el comando a continuaci\u00f3n.</p> <p>Clonar un repositorio existente desde GitHub:</p> <pre><code>git clone &lt;https://github.com/usuario/proyecto.git&gt;\n</code></pre>"},{"location":"material/S2/010/#revisar-el-estado-del-proyecto","title":"Revisar el estado del proyecto","text":"<pre><code>git status\n</code></pre> <p>Muestra qu\u00e9 archivos han cambiado, cu\u00e1les est\u00e1n listos para confirmar y cu\u00e1les no.</p>"},{"location":"material/S2/010/#agregar-archivos-al-area-de-preparacion","title":"Agregar archivos al \u00e1rea de preparaci\u00f3n","text":"<pre><code>git add archivo.py\n</code></pre> <p>O bien, agregar todos los archivos modificados (dentro del directorio actual):</p> <pre><code>git add .\n</code></pre>"},{"location":"material/S2/010/#guardar-los-cambios-commit","title":"Guardar los cambios (<code>commit</code>)","text":"<pre><code>git commit -m \"Mensaje descriptivo del cambio\"\n</code></pre>"},{"location":"material/S2/010/#ver-el-historial-de-cambios","title":"Ver el historial de cambios","text":"<pre><code>git log\n</code></pre> <p>Para un resumen m\u00e1s compacto:</p> <pre><code>git log --oneline\n</code></pre>"},{"location":"material/S2/010/#sincronizar-con-github","title":"Sincronizar con GitHub","text":"<p>Enviar cambios al repositorio remoto:</p> <pre><code>git push\n</code></pre> <p>Descargar los cambios m\u00e1s recientes:</p> <pre><code>git pull\n</code></pre> <p>Nota</p> <p>En algunos casos se usa <code>git push origin main</code> o <code>git pull origin main</code>. Esto indica expl\u00edcitamente el nombre del repositorio remoto (<code>origin</code>) y la rama (<code>main</code>). Sin embargo, Git normalmente recuerda esta configuraci\u00f3n despu\u00e9s del primer uso.</p>"},{"location":"material/S2/010/#restaurar-archivos-o-deshacer-cambios","title":"Restaurar archivos o deshacer cambios","text":"<p>Cuidado</p> <p>Tener cuidado con el uso de estos comandos porque se puede perder los cambios realizados si se realizan de forma incorrecta.</p> <p>Deshacer cambios no confirmados:</p> <pre><code>git restore archivo.py\n</code></pre> <p>Eliminar archivos del repositorio:</p> <pre><code>git rm archivo.txt\n</code></pre> <p>Comparar versiones antes de confirmar:</p> <pre><code>git diff\n</code></pre>"},{"location":"material/S2/010/#introduccion-a-ramas-branches","title":"Introducci\u00f3n a ramas (branches)","text":"<p>\u00bfQu\u00e9 es una rama?</p> <p>Una rama es una l\u00ednea de desarrollo independiente dentro de un mismo proyecto. Permite trabajar en nuevas funciones o pruebas sin afectar el c\u00f3digo principal.</p>"},{"location":"material/S2/010/#ver-ramas-existentes","title":"Ver ramas existentes","text":"<pre><code>git branch\n</code></pre> <p>La rama activa se marca con un asterisco (<code>*</code>).</p>"},{"location":"material/S2/010/#crear-una-nueva-rama","title":"Crear una nueva rama","text":"<pre><code>git branch nueva-rama\n</code></pre> <p>O crearla y cambiarse a ella en un solo paso:</p> <pre><code>git checkout -b nueva-rama\n</code></pre>"},{"location":"material/S2/010/#cambiar-de-rama","title":"Cambiar de rama","text":"<pre><code>git checkout main\n</code></pre>"},{"location":"material/S2/010/#fusionar-ramas-merge","title":"Fusionar ramas (<code>merge</code>)","text":"<pre><code>git merge nueva-rama\n</code></pre> <p>Tip</p> <p>Es recomendable realizar el merge desde la rama principal (<code>main</code>) despu\u00e9s de probar que los cambios funcionan correctamente. Sin embargo, la integraci\u00f3n de cambios tambi\u00e9n se puede realizar directamente por medio de un pull request en GitHub.</p>"},{"location":"material/S2/010/#eliminar-una-rama","title":"Eliminar una rama","text":"<pre><code>git branch -d nueva-rama\n</code></pre>"},{"location":"material/S2/010/#visualizacion-del-flujo-de-ramas","title":"Visualizaci\u00f3n del flujo de ramas","text":"<pre><code>gitGraph\n   commit id: \"Inicio\"\n   branch nueva-funcionalidad\n   checkout nueva-funcionalidad\n   commit id: \"Agrega m\u00f3dulo X\"\n   commit id: \"Corrige bug menor\"\n   checkout main\n   merge nueva-funcionalidad id: \"Merge final\"</code></pre>"},{"location":"oci/backtracking/","title":"Backtracking","text":""},{"location":"oci/backtracking/#que-es-backtracking","title":"\u00bfQu\u00e9 es backtracking?","text":"<p>Backtracking (o b\u00fasqueda con retroceso) es una t\u00e9cnica de dise\u00f1o algor\u00edtmico que permite explorar todas las soluciones posibles de un problema, descartando aquellas que no cumplen las condiciones.</p> <p>Se basa en construir una soluci\u00f3n paso a paso, y cuando se detecta que el camino actual no puede llevar a una soluci\u00f3n v\u00e1lida, el algoritmo retrocede (backtrack) y prueba una alternativa.</p> <pre><code>flowchart TD\n    A(\"Inicio\") --&gt; B[\"\u00bfEs soluci\u00f3n v\u00e1lida?\"]\n    B -- S\u00ed --&gt; C[\"Guardar soluci\u00f3n\"]\n    C --&gt; E[\"Avanzar y probar opci\u00f3n siguiente\"]\n    B -- No --&gt; D[\"\u00bfHay m\u00e1s opciones?\"]\n    D -- S\u00ed --&gt; E\n    E --&gt; B\n    D -- No --&gt; F(Fin)</code></pre>"},{"location":"oci/backtracking/#cuando-se-usa","title":"\u00bfCu\u00e1ndo se usa?","text":"<p>Se aplica cuando:</p> <ul> <li>Se necesita generar todas las combinaciones o permutaciones posibles.</li> <li>El espacio de soluciones es grande, pero se puede podar o descartar caminos inv\u00e1lidos r\u00e1pidamente (poda de b\u00fasqueda).</li> <li>No se conoce una estrategia voraz ni una f\u00f3rmula matem\u00e1tica directa para resolver el problema.</li> </ul>"},{"location":"oci/backtracking/#desventajas","title":"Desventajas","text":"<ul> <li>Es costoso en tiempo si no se aplican podas.</li> <li>En problemas con grandes espacios de b\u00fasqueda, puede ser ineficiente sin optimizaciones.</li> </ul>"},{"location":"oci/backtracking/#ejemplo-algoritmo-de-las-n-reinas","title":"Ejemplo: Algoritmo de las <code>N</code> Reinas","text":"<p>El problema de las N reinas consiste en colocar <code>N</code> reinas en un tablero de ajedrez de <code>N x N</code> de forma que ninguna reina se ataque entre s\u00ed. Las reinas se atacan si est\u00e1n en la misma fila, columna o diagonal. El objetivo es encontrar una o todas las configuraciones posibles v\u00e1lidas.</p> <pre><code>def es_seguro(tablero, fila, col, n):\n    # Verificar columna\n    for i in range(fila):\n        if tablero[i] == col:\n            return False\n\n    # Verificar diagonal izquierda\n    for i in range(fila):\n        if tablero[i] == col - (fila - i):\n            return False\n\n    # Verificar diagonal derecha\n    for i in range(fila):\n        if tablero[i] == col + (fila - i):\n            return False\n\n    return True\n\ndef resolver_n_reinas(n):\n    soluciones = []\n    tablero = [-1] * n  # tablero[i] = columna donde est\u00e1 la reina en la fila i\n\n    def backtrack(fila):\n        if fila == n:\n            soluciones.append(tablero[:])  # Se encontr\u00f3 una soluci\u00f3n v\u00e1lida\n            return\n\n        for col in range(n):\n            if es_seguro(tablero, fila, col, n):\n                tablero[fila] = col  # Colocar reina\n                backtrack(fila + 1)  # Ir a la siguiente fila\n                tablero[fila] = -1  # Backtrack (quitar reina)\n\n    backtrack(0)\n    return soluciones\n</code></pre> <p>1. Representaci\u00f3n del tablero</p> <ul> <li>Se usa una lista <code>tablero</code> de tama\u00f1o <code>n</code>, donde <code>tablero[i] = j</code> significa que hay una reina en la fila <code>i</code> y columna <code>j</code>.</li> <li>No se necesita una matriz: como colocamos una reina por fila, cada \u00edndice ya representa una fila.</li> </ul> <p>2. Funci\u00f3n <code>es_seguro()</code></p> <ul> <li>Verifica si una reina en la posici\u00f3n <code>(fila, col)</code> es atacada por alguna reina anterior:</li> <li>Columna: ya hay una reina en la misma columna.</li> <li>Diagonal izquierda: la reina se encuentra a la misma distancia a la izquierda.</li> <li>Diagonal derecha: la reina se encuentra a la misma distancia a la derecha.</li> </ul> <p>3. Funci\u00f3n <code>backtrack(fila)</code></p> <ul> <li>Si <code>fila == n</code>, se ha colocado una reina en cada fila, por lo tanto, se guarda una copia del tablero como soluci\u00f3n.</li> <li>Si no:</li> <li>Se prueban todas las columnas posibles para la fila actual.</li> <li>Para cada columna v\u00e1lida:<ul> <li>Se coloca una reina.</li> <li>Se avanza a la siguiente fila con una llamada recursiva.</li> <li>Si esa rama falla, se retrocede (backtrack) quitando la reina.</li> </ul> </li> </ul>"},{"location":"oci/backtracking/#ejemplo-permutaciones-y-combinaciones-de-un-conjunto","title":"Ejemplo: Permutaciones y combinaciones de un conjunto","text":"<p>Dado un conjunto de elementos distintos, por ejemplo:</p> <pre><code>conjunto = [1, 2, 3]\n</code></pre> <p>Se desea:</p> <ol> <li>Generar todas las permutaciones posibles (donde el orden importa).</li> <li>Generar todas las combinaciones posibles de tama\u00f1o <code>k</code> (donde el orden no importa).</li> </ol>"},{"location":"oci/backtracking/#1-permutaciones","title":"1. Permutaciones","text":"<pre><code>def permutaciones(conjunto):\n    resultado = []\n    visitado = [False] * len(conjunto)\n\n    def backtrack(parcial):\n        if len(parcial) == len(conjunto):\n            resultado.append(parcial[:])\n            return\n\n        for i in range(len(conjunto)):\n            if not visitado[i]:\n                visitado[i] = True\n                parcial.append(conjunto[i])\n                backtrack(parcial)\n                parcial.pop()\n                visitado[i] = False\n\n    backtrack([])\n    return resultado\n\n# Ejemplo\nprint(permutaciones([1, 2, 3]))\n</code></pre> <ul> <li>Se construye la soluci\u00f3n parcial en una lista <code>parcial</code>.</li> <li>Se usa un arreglo <code>visitado</code> para evitar reutilizar elementos.</li> <li>En cada paso se prueban todos los elementos no visitados.</li> <li>Cuando la soluci\u00f3n parcial tiene el mismo largo que el conjunto, se agrega como permutaci\u00f3n v\u00e1lida.</li> <li>Al salir del paso recursivo, se retrocede eliminando el \u00faltimo elemento y marcando como no visitado.</li> </ul>"},{"location":"oci/backtracking/#2-combinaciones","title":"2. Combinaciones","text":"<pre><code>def combinaciones(conjunto, k):\n    resultado = []\n\n    def backtrack(inicio, parcial):\n        if len(parcial) == k:\n            resultado.append(parcial[:])\n            return\n\n        for i in range(inicio, len(conjunto)):\n            parcial.append(conjunto[i])\n            backtrack(i + 1, parcial)\n            parcial.pop()\n\n    backtrack(0, [])\n    return resultado\n\n# Ejemplo\nprint(combinaciones([1, 2, 3, 4], 2))\n</code></pre> <ul> <li>Se construye una combinaci\u00f3n parcial.</li> <li>Se comienza desde <code>inicio</code> para evitar reusar elementos anteriores y as\u00ed mantener el orden y evitar duplicados.</li> <li>Si se alcanza tama\u00f1o <code>k</code>, se agrega como combinaci\u00f3n v\u00e1lida.</li> <li>Al retroceder, se elimina el \u00faltimo elemento para explorar otras posibilidades.</li> </ul>"},{"location":"oci/backtracking/#ejemplo-sudoku-solver","title":"Ejemplo: Sudoku Solver","text":"<pre><code>def es_valido(tablero, fila, col, num):\n    # Verifica si el n\u00famero ya est\u00e1 en la misma fila\n    for j in range(9):\n        if tablero[fila][j] == num:\n            return False\n\n    # Verifica si el n\u00famero ya est\u00e1 en la misma columna\n    for i in range(9):\n        if tablero[i][col] == num:\n            return False\n\n    # Verifica si el n\u00famero ya est\u00e1 en el subcuadro 3x3\n    inicio_fila = (fila // 3) * 3\n    inicio_col = (col // 3) * 3\n    for i in range(3):\n        for j in range(3):\n            if tablero[inicio_fila + i][inicio_col + j] == num:\n                return False\n\n    return True  # El n\u00famero es v\u00e1lido en esta celda\n\ndef resolver_sudoku(tablero):\n    # Recorremos cada celda del tablero\n    for fila in range(9):\n        for col in range(9):\n            if tablero[fila][col] == 0:\n                # Celda vac\u00eda: intentar colocar un n\u00famero del 1 al 9\n                for num in range(1, 10):\n                    if es_valido(tablero, fila, col, num):\n                        tablero[fila][col] = num  # Colocamos provisionalmente\n\n                        if resolver_sudoku(tablero):\n                            return True  # Se encontr\u00f3 una soluci\u00f3n v\u00e1lida\n\n                        tablero[fila][col] = 0  # Retroceder (backtrack)\n\n                # Ning\u00fan n\u00famero v\u00e1lido funcion\u00f3 en esta celda\n                return False\n\n    # No quedan celdas vac\u00edas, el tablero est\u00e1 completo\n    return True\n</code></pre> <p>1. Verificaci\u00f3n de validez (<code>es_valido</code>)</p> <p>Antes de colocar un n\u00famero en una celda, se comprueba que:</p> <ul> <li>No se repita en la fila.</li> <li>No se repita en la columna.</li> <li>No se repita en el cuadro 3x3 correspondiente.</li> </ul> <p>Esto asegura que las reglas del Sudoku se respeten antes de avanzar.</p> <p>2. Backtracking (<code>resolver_sudoku</code>)</p> <p>El algoritmo principal sigue estos pasos:</p> <ul> <li>Se busca la pr\u00f3xima celda vac\u00eda (con valor 0).</li> <li>Para esa celda, se intenta colocar cada n\u00famero del 1 al 9:</li> <li>Si el n\u00famero es v\u00e1lido, se coloca provisionalmente.</li> <li>Se llama recursivamente a <code>resolver_sudoku()</code> para resolver el resto del tablero.</li> <li>Si ning\u00fan n\u00famero funciona, se retrocede y se prueba otra opci\u00f3n.</li> </ul> <p>3. Corte de recursi\u00f3n</p> <p>El algoritmo termina exitosamente cuando ya no quedan celdas vac\u00edas. Se retorna <code>True</code> porque el tablero fue completado correctamente.</p>"},{"location":"oci/backtracking/#ejemplo-resolver-un-laberinto","title":"Ejemplo: Resolver un laberinto","text":"<p>Dado un laberinto representado como una matriz <code>N x N</code>, donde:</p> <ul> <li><code>1</code> indica un camino libre.</li> <li><code>0</code> indica una pared (no se puede pasar).</li> <li>El objetivo es encontrar un camino desde la celda de inicio <code>(0, 0)</code> hasta la celda de destino <code>(N-1, N-1)</code> moviendo solo en las 4 direcciones cardinales: arriba, abajo, izquierda y derecha.</li> <li>No se permite salir de la matriz ni pasar por celdas marcadas como <code>0</code>.</li> <li>El algoritmo debe marcar el camino encontrado.</li> </ul> <pre><code>def es_valido(laberinto, x, y, solucion):\n    N = len(laberinto)\n    # Verifica si (x, y) est\u00e1 dentro del tablero, es transitable y no ha sido visitado\n    return (\n        0 &lt;= x &lt; N and\n        0 &lt;= y &lt; N and\n        laberinto[x][y] == 1 and\n        solucion[x][y] == 0\n    )\n\ndef resolver_laberinto(laberinto):\n    N = len(laberinto)\n\n    # Crear matriz de soluci\u00f3n con ceros\n    solucion = [[0] * N for _ in range(N)]\n\n    # Intentar resolver desde (0, 0)\n    if backtrack_laberinto(laberinto, 0, 0, solucion):\n        return solucion  # Devuelve el camino marcado con 1\n    else:\n        return None  # No hay soluci\u00f3n\n\ndef backtrack_laberinto(laberinto, x, y, solucion):\n    N = len(laberinto)\n\n    # Caso base: se llega a la meta\n    if x == N - 1 and y == N - 1 and laberinto[x][y] == 1:\n        solucion[x][y] = 1\n        return True\n\n    # Verificar si se puede avanzar a (x, y)\n    if es_valido(laberinto, x, y, solucion):\n        solucion[x][y] = 1  # Marcar celda como parte del camino\n\n        # Moverse hacia abajo\n        if backtrack_laberinto(laberinto, x + 1, y, solucion):\n            return True\n\n        # Moverse hacia la derecha\n        if backtrack_laberinto(laberinto, x, y + 1, solucion):\n            return True\n\n        # Moverse hacia arriba\n        if backtrack_laberinto(laberinto, x - 1, y, solucion):\n            return True\n\n        # Moverse hacia la izquierda\n        if backtrack_laberinto(laberinto, x, y - 1, solucion):\n            return True\n\n        # Retroceso: ninguna direcci\u00f3n sirvi\u00f3\n        solucion[x][y] = 0\n        return False\n\n    return False\n</code></pre> <p>1. Representaci\u00f3n del laberinto</p> <ul> <li>Una matriz <code>N x N</code> donde <code>1</code> son celdas libres y <code>0</code> son obst\u00e1culos.</li> <li>Se inicia en <code>(0, 0)</code> y se busca llegar a <code>(N-1, N-1)</code>.</li> </ul> <p>2. Estructura del algoritmo</p> <ul> <li>Se crea una matriz <code>solucion</code> del mismo tama\u00f1o que el laberinto, inicializada en ceros.</li> <li>En cada paso, si la celda es v\u00e1lida, se marca como <code>1</code> (parte del camino).</li> <li>Se prueban movimientos en las 4 direcciones posibles.</li> <li>Si alguna de las llamadas recursivas retorna <code>True</code>, se propaga hacia atr\u00e1s.</li> </ul> <p>3. Retroceso (backtrack)</p> <ul> <li>Si desde una celda <code>(x, y)</code> no se puede llegar a la meta, se desmarca la celda (<code>solucion[x][y] = 0</code>) y se prueba otra direcci\u00f3n.</li> <li>Esto permite explorar otras rutas si una opci\u00f3n falla.</li> </ul> <p>4. Caso base</p> <ul> <li>Si se alcanza <code>(N-1, N-1)</code> y esa celda es transitable (<code>1</code>), se marca como parte de la soluci\u00f3n y se retorna <code>True</code>.</li> </ul> <p>5. Resultado</p> <ul> <li>Si hay un camino v\u00e1lido, la funci\u00f3n devuelve la matriz <code>solucion</code> con <code>1</code>s marcando el camino.</li> <li>Si no hay soluci\u00f3n, retorna <code>None</code>.</li> </ul>"},{"location":"oci/grafos/","title":"Algoritmos de Grafos","text":""},{"location":"oci/grafos/#introduccion-a-los-grafos","title":"Introducci\u00f3n a los Grafos","text":"<p>Un grafo es una estructura que modela relaciones entre pares de elementos. Cada elemento se llama nodo o v\u00e9rtice, y cada conexi\u00f3n entre dos nodos se llama arista.</p> <ul> <li>Un grafo puede ser:</li> <li>Dirigido: las aristas tienen una direcci\u00f3n (A \u2192 B).</li> <li>No dirigido: las aristas no tienen direcci\u00f3n (A \u2194 B).</li> <li>Ponderado: las aristas tienen un peso o costo.</li> </ul> <pre><code># Representaci\u00f3n con lista de adyacencia\ngrafo = {\n    'A': ['B', 'C'],\n    'B': ['A', 'D'],\n    'C': ['A', 'D'],\n    'D': ['B', 'C']\n}\n</code></pre> <p>Tambi\u00e9n se puede representar con una matriz de adyacencia:</p> <pre><code>grafo = [[0,1,1,0], [1,0,0,1], [1,0,0,1], [0,1,1,0]]\ngrafoLista = [[1,2], [0,3], [0, 3], [1,2]]\n# Por \u00edndice: [[2-1, 3-1], [1-1, 4-1], [1-1, 4-1], [2-1,3-1]]\n</code></pre>"},{"location":"oci/grafos/#depth-first-search-dfs","title":"Depth First Search (DFS)","text":"<p>La b\u00fasqueda en profundidad (DFS) es un algoritmo de recorrido de grafos que explora tan profundo como sea posible a lo largo de cada rama antes de retroceder.</p> <p>DFS se puede implementar de dos formas principales:</p> <ul> <li>Recursiva: L\u00edmitado por el stack en la recursi\u00f3n para grafos grandes.</li> <li>Iterativa: \u00fatil para evitar l\u00edmites de recursi\u00f3n.</li> </ul>"},{"location":"oci/grafos/#dfs-recursivo-con-lista-de-adyacencia","title":"DFS recursivo con lista de adyacencia","text":"<pre><code>def dfs(grafo, nodo, visitado=None):\n    if visitado is None:\n        visitado = set()  # Conjunto para registrar nodos ya visitados (evita repeticiones)\n    visitado.add(nodo)\n    print(nodo, end=' ')  # Procesa el nodo actual\n\n    # Recorre todos los vecinos del nodo actual\n    for vecino in grafo[nodo]:\n        if vecino not in visitado:\n            dfs(grafo, vecino, visitado)  # Llamada recursiva sobre el vecino no visitado\n</code></pre> <p>Explicaci\u00f3n:</p> <ul> <li>Se parte de un nodo inicial (por ejemplo, <code>nodo = 0</code>).</li> <li>Se marca el nodo como visitado.</li> <li>Se visitan recursivamente sus vecinos no visitados.</li> <li>Al terminar de visitar todos los descendientes de un nodo, se \"retrocede\" y contin\u00faa con otros caminos.</li> </ul>"},{"location":"oci/grafos/#dfs-iterativo-con-matriz-de-adyacencia","title":"DFS iterativo con matriz de adyacencia","text":"<pre><code>def dfs(grafo):\n    pila = [0]  # Empieza desde el nodo 0 por ejemplo\n    visitados = [0] * len(grafo)  # Marca si el nodo fue visitado y el orden en que fue visitado\n    cont = 1  # Contador para registrar el orden de visita\n\n    while pila:\n        top = pila.pop()  # Extrae el nodo del top de la pila\n        if not visitados[top]:\n            visitados[top] = cont  # Marca el nodo como visitado con el contador\n            cont += 1\n            # Recorre los vecinos (desde el nodo m\u00e1s alto al m\u00e1s bajo)\n            for i in reversed(range(len(grafo[top]))):\n                if grafo[top][i] == 1 and not visitados[i]:\n                    pila.append(i)  # Agrega vecinos no visitados a la pila\n    print(visitados)\n</code></pre> <p>Explicaci\u00f3n:</p> <ul> <li>Se utiliza una pila expl\u00edcita (lista).</li> <li>La matriz <code>grafo[i][j] == 1</code> indica que existe una arista entre el nodo <code>i</code> y <code>j</code>.</li> <li>El recorrido sigue apilando vecinos conforme se descubren, y va sacando nodos del top de la pila.</li> <li>Se visita el nodo m\u00e1s recientemente descubierto antes de los anteriores (LIFO).</li> </ul>"},{"location":"oci/grafos/#dfs-iterativo-con-lista-de-adyacencia","title":"DFS iterativo con lista de adyacencia","text":"<pre><code>def dfs(grafoLista):\n    pila = [0]  # Inicia desde el nodo 0, por ejemplo\n    visitados = [0] * len(grafoLista)\n    cont = 1\n\n    while pila:\n        top = pila.pop()\n        if not visitados[top]:\n            visitados[top] = cont\n            cont += 1\n            for vecino in grafoLista[top]:\n                if not visitados[vecino]:\n                    pila.append(vecino)\n    print(visitados)\n</code></pre> <p>Explicaci\u00f3n:</p> <ul> <li>Similar a la versi\u00f3n con matriz, pero se usa una lista de adyacencia, que es m\u00e1s eficiente en espacio para grafos dispersos.</li> <li><code>grafoLista[i]</code> contiene directamente una lista con los vecinos del nodo <code>i</code>, por lo que no se necesita revisar todos los \u00edndices como en una matriz.</li> </ul>"},{"location":"oci/grafos/#breadth-first-search-bfs","title":"Breadth First Search (BFS)","text":"<p>La b\u00fasqueda en anchura (BFS) es un algoritmo de recorrido de grafos que explora primero los nodos m\u00e1s cercanos al nodo de inicio, antes de avanzar hacia niveles m\u00e1s profundos.</p> <p>BFS se basa en una cola/deque (FIFO), lo que le permite recorrer los nodos nivel por nivel.</p>"},{"location":"oci/grafos/#bfs-iterativo-con-lista-de-adyacencia","title":"BFS iterativo con lista de adyacencia","text":"<pre><code>from collections import deque\n\ndef bfs(grafo, nodo_inicio):\n    visitado = set()\n    cola = deque([nodo_inicio]) # Inicializar cola\n    while cola:\n        nodo = cola.popleft()\n        if nodo not in visitado:\n            print(nodo, end=' ')\n            visitado.add(nodo)\n            # Agrega vecinos no visitados al final de la cola\n            cola.extend([vec for vec in grafo[nodo] if vec not in visitado])\n</code></pre> <p>Explicaci\u00f3n:</p> <ul> <li>Se comienza con el nodo de inicio.</li> <li>Se usa una <code>deque</code> como cola para extraer elementos del frente.</li> <li>Por cada nodo, se procesan sus vecinos inmediatos y se agregan a la cola si no han sido visitados.</li> <li>Se garantiza que todos los nodos a una misma distancia del nodo inicial se visiten antes de avanzar al siguiente nivel.</li> </ul>"},{"location":"oci/grafos/#bfs-iterativo-con-matriz-de-adyacencia","title":"BFS iterativo con matriz de adyacencia","text":"<pre><code>def bfs(grafo):\n    cola = [0]  # Nodo inicial\n    visitados = [0] * len(grafo)\n    cont = 1\n\n    while cola:\n        top = cola.pop()  # Al usar .pop(), se extrae del final (poco eficiente)\n        if not visitados[top]:\n            visitados[top] = cont\n            cont += 1\n            # Se insertan nuevos vecinos al inicio de la cola (simula FIFO)\n            for i in range(len(grafo[top])):\n                if grafo[top][i] == 1 and not visitados[i]:\n                    cola.insert(0, i)\n    print(visitados)\n</code></pre> <p>Explicaci\u00f3n:</p> <ul> <li>Esta versi\u00f3n utiliza una lista como cola, pero realiza <code>insert(0, ...)</code>, lo que puede ser ineficiente en listas grandes.</li> <li><code>grafo[i][j] == 1</code> indica que existe una arista entre <code>i</code> y <code>j</code>.</li> <li>Aunque funcional, esta versi\u00f3n no es tan eficiente como la que usa <code>deque</code>.</li> </ul>"},{"location":"oci/grafos/#bfs-iterativo-con-deque-y-matriz-de-adyacencia","title":"BFS iterativo con <code>deque</code> y matriz de adyacencia","text":"<pre><code>from collections import deque\n\ndef bfs(grafo):\n    cola = deque()\n    cola.append(0)\n    visitados = [0] * len(grafo)\n    cont = 1\n\n    while cola:\n        front = cola.popleft()\n        if not visitados[front]:\n            visitados[front] = cont\n            cont += 1\n            for i in range(len(grafo[front])):\n                if grafo[front][i] == 1 and not visitados[i]:\n                    cola.append(i)\n    print(visitados)\n</code></pre> <p>Explicaci\u00f3n:</p> <ul> <li>Utiliza <code>deque</code> para un rendimiento mejorado al insertar y extraer elementos de la cola.</li> <li>Explora nodos adyacentes nivel por nivel, lo cual garantiza el orden adecuado.</li> </ul>"},{"location":"oci/grafos/#orden-topologico-dag","title":"Orden Topol\u00f3gico (DAG)","text":"<p>El orden topol\u00f3gico es una enumeraci\u00f3n lineal de los nodos de un grafo dirigido ac\u00edclico (DAG), de forma que si existe una arista del nodo <code>u</code> al nodo <code>v</code>, entonces <code>u</code> aparece antes que <code>v</code> en el orden resultante.</p> <p>Este tipo de recorrido es fundamental para tareas que presentan dependencias entre elementos, como:</p> <ul> <li>Compilaci\u00f3n de m\u00f3dulos (donde un archivo depende de otros).</li> <li>Resoluci\u00f3n de cursos con requisitos previos.</li> </ul>"},{"location":"oci/grafos/#implementacion-usando-dfs","title":"Implementaci\u00f3n usando DFS","text":"<pre><code>def orden_topologico(grafo):\n    visitado = set()\n    pila = []\n\n    def dfs(nodo):\n        visitado.add(nodo)\n        for vecino in grafo.get(nodo, []):\n            if vecino not in visitado:\n                dfs(vecino)\n        pila.append(nodo)\n\n    for nodo in grafo:\n        if nodo not in visitado:\n            dfs(nodo)\n\n    return pila[::-1]  # Invierte la pila para obtener el orden correcto\n</code></pre> <p>Explicaci\u00f3n:</p> <ul> <li>Se recorre el grafo en profundidad (DFS) desde cada nodo no visitado.</li> <li>Al finalizar la exploraci\u00f3n de un nodo y todos sus descendientes, se agrega el nodo a una pila.</li> <li>Una vez completado el recorrido, se invierte la pila para obtener el orden topol\u00f3gico.</li> <li><code>grafo.get(nodo, [])</code> permite manejar grafos donde algunos nodos pueden no tener vecinos expl\u00edcitamente listados.</li> </ul> <p>Ejemplo:</p> <p>Para el grafo:</p> <pre><code>grafo = {\n    'A': ['C'],\n    'B': ['C', 'D'],\n    'C': ['E'],\n    'D': ['F'],\n    'E': ['H', 'F'],\n    'F': ['G'],\n    'G': [],\n    'H': []\n}\n</code></pre> <p>Una posible salida de <code>orden_topologico(grafo)</code> ser\u00eda:</p> <pre><code>['B', 'D', 'A', 'C', 'E', 'H', 'F', 'G']\n</code></pre> <ul> <li>Puede haber m\u00faltiples \u00f3rdenes v\u00e1lidos siempre que se respete la precedencia de las aristas.</li> <li>El orden topol\u00f3gico solo es posible si el grafo no contiene ciclos. Si se detecta un ciclo, el algoritmo debe manejarlo o reportarlo.</li> <li>Este algoritmo tiene una complejidad de O(V + E), donde <code>V</code> es el n\u00famero de v\u00e9rtices y <code>E</code> el n\u00famero de aristas.</li> </ul>"},{"location":"oci/grafos/#deteccion-de-ciclos","title":"Detecci\u00f3n de Ciclos","text":"<p>Detectar ciclos en un grafo permite determinar si existen caminos cerrados.</p> <p>Sirve para verificar si un grafo dirigido es un DAG (grafo dirigido ac\u00edclico), condici\u00f3n necesaria para aplicar un orden topol\u00f3gico.</p>"},{"location":"oci/grafos/#en-grafo-no-dirigido","title":"En grafo no dirigido","text":"<p>Se utiliza una b\u00fasqueda en profundidad (DFS) y se mantiene una referencia al nodo padre desde el cual se lleg\u00f3 al nodo actual. Esto evita confundir la arista que regresa al padre con un ciclo real.</p> <pre><code>def tiene_ciclo(grafo):\n    visitado = set()\n\n    def dfs(nodo, padre):\n        visitado.add(nodo)\n        for vecino in grafo[nodo]:\n            if vecino not in visitado:\n                if dfs(vecino, nodo):\n                    return True\n            elif vecino != padre:\n                return True\n        return False\n\n    for nodo in grafo:\n        if nodo not in visitado:\n            if dfs(nodo, None):\n                return True\n    return False\n</code></pre> <p>Explicaci\u00f3n:</p> <ul> <li>Al visitar un vecino ya visitado que no es el padre, se ha encontrado un ciclo.</li> <li>La funci\u00f3n recorre cada componente conexo del grafo.</li> <li>Se retorna <code>True</code> en cuanto se detecta el primer ciclo.</li> </ul> <p>Ejemplo:</p> <pre><code># Ciclo: 1-2-3-4-1\ngrafo = {\n    0: [1],\n    1: [0, 2],\n    2: [1, 3],\n    3: [2, 4],\n    4: [3, 1]\n}\n</code></pre> <p><code>tiene_ciclo(grafo)</code> retornar\u00e1 <code>True</code>.</p>"},{"location":"oci/grafos/#en-grafo-dirigido","title":"En grafo dirigido","text":"<p>En grafos dirigidos, se debe evitar visitar nodos en el mismo camino de recursi\u00f3n. Para ello, se emplean dos conjuntos:</p> <ul> <li><code>visitado</code>: nodos ya completamente procesados.</li> <li><code>en_recursion</code>: nodos que est\u00e1n actualmente en el camino de llamada recursiva.</li> </ul> <pre><code>def tiene_ciclo_dirigido(grafo):\n    visitado = set()\n    en_recursion = set()\n\n    def dfs(nodo):\n        visitado.add(nodo)\n        en_recursion.add(nodo)\n\n        for vecino in grafo.get(nodo, []):\n            if vecino not in visitado:\n                if dfs(vecino):\n                    return True\n            elif vecino in en_recursion:\n                return True  # Se encontr\u00f3 un ciclo\n\n        en_recursion.remove(nodo)\n        return False\n\n    for nodo in grafo:\n        if nodo not in visitado:\n            if dfs(nodo):\n                return True\n    return False\n</code></pre> <p>Explicaci\u00f3n:</p> <ul> <li>Si durante el recorrido se encuentra un nodo que ya est\u00e1 en el conjunto <code>en_recursion</code>, hay un ciclo.</li> <li>Al terminar de procesar un nodo, se elimina de <code>en_recursion</code>.</li> <li>Se explora el grafo desde todos los nodos que a\u00fan no han sido visitados.</li> </ul> <p>Ejemplo:</p> <pre><code># Ciclo dirigido: A \u2192 B \u2192 C \u2192 A\ngrafo = {\n    'A': ['B'],\n    'B': ['C'],\n    'C': ['A']\n}\n</code></pre> <p><code>tiene_ciclo_dirigido(grafo)</code> retornar\u00e1 <code>True</code>.</p>"},{"location":"oci/grafos/#componentes-conexas","title":"Componentes Conexas","text":"<p>Una componente conexa en un grafo no dirigido es un conjunto m\u00e1ximo de nodos donde existe al menos un camino entre cualquier par de nodos dentro del conjunto.</p> <p>Si un grafo no dirigido tiene varias componentes conexas, significa que hay grupos de nodos completamente aislados unos de otros.</p>"},{"location":"oci/grafos/#identificacion-de-componentes-conexas-con-dfs","title":"Identificaci\u00f3n de componentes conexas con DFS","text":"<pre><code>def componentes_conexas(grafo):\n    visitado = set()\n    componentes = []\n\n    def dfs(nodo, componente):\n        visitado.add(nodo)\n        componente.append(nodo)\n        for vecino in grafo[nodo]:\n            if vecino not in visitado:\n                dfs(vecino, componente)\n\n    for nodo in grafo:\n        if nodo not in visitado:\n            componente = []\n            dfs(nodo, componente)\n            componentes.append(componente)\n\n    return componentes\n</code></pre> <p>Explicaci\u00f3n:</p> <ul> <li>Se recorre el grafo desde cada nodo no visitado.</li> <li>Para cada nueva b\u00fasqueda, se crea una nueva lista <code>componente</code> que agrupa los nodos conectados entre s\u00ed.</li> <li>Se utiliza DFS para agregar todos los nodos alcanzables desde el nodo actual.</li> <li>Al terminar, se agregan todas las componentes encontradas a una lista principal <code>componentes</code>.</li> </ul>"},{"location":"oci/grafos/#ejemplo","title":"Ejemplo","text":"<pre><code>grafo = {\n    0: [1],\n    1: [0],\n    2: [3],\n    3: [2],\n    4: [],\n    5: [6],\n    6: [5]\n}\n</code></pre> <p>Este grafo tiene tres componentes conexas:</p> <pre><code>[[0, 1], [2, 3], [4], [5, 6]]\n</code></pre> <ul> <li>La complejidad del algoritmo es O(V + E), donde <code>V</code> es el n\u00famero de nodos y <code>E</code> el n\u00famero de aristas.</li> <li>Tambi\u00e9n se puede utilizar BFS en lugar de DFS, seg\u00fan se prefiera o por necesidades del entorno.</li> </ul>"},{"location":"oci/grafos/#puntos-de-articulacion-y-puentes-tarjan","title":"Puntos de Articulaci\u00f3n y Puentes (Tarjan)","text":"<p>En un grafo no dirigido, existen nodos y aristas cr\u00edticas cuya eliminaci\u00f3n puede afectar la conectividad del grafo:</p> <ul> <li>Un punto de articulaci\u00f3n (o v\u00e9rtice de corte) es un nodo cuya eliminaci\u00f3n incrementa el n\u00famero de componentes conexas.</li> <li>Un puente (o arista de corte) es una arista cuya eliminaci\u00f3n desconecta el grafo.</li> </ul>"},{"location":"oci/grafos/#algoritmo-de-tarjan","title":"Algoritmo de Tarjan","text":"<p>El algoritmo de Tarjan se basa en DFS y utiliza:</p> <ul> <li><code>disc[u]</code>: el tiempo en que se descubre el nodo <code>u</code>. Orden en el la DFS visita el nodo (<code>tiempo</code>).</li> <li><code>low[u]</code>: el menor tiempo de descubrimiento alcanzable <code>disc[]</code> desde <code>u</code> (ya sea por un hijo o por un retroceso), descendiendo en el DFS (se retrocede hacia un tiempo menor, lo cual indica un nodo previo).</li> <li><code>padre[u]</code>: el nodo padre desde el cual se lleg\u00f3 a <code>u</code> en el DFS.</li> </ul> <pre><code>def articulaciones_y_puentes(grafo):\n    tiempo = 0\n    visitado = set()\n    disc = {}\n    low = {}\n    padre = {}\n    articulaciones = set()\n    puentes = []\n\n    def dfs(u):\n        nonlocal tiempo\n        visitado.add(u)\n        disc[u] = low[u] = tiempo\n        tiempo += 1\n        hijos = 0\n\n        for v in grafo[u]:\n            if v not in visitado:\n                padre[v] = u\n                hijos += 1\n                dfs(v)\n                # Si `v` o un descendiente alcanza un nodo descubierto antes que `u`, entonces `u`\n                # tambi\u00e9n puede alcanzarlo y se actualiza con este valor\n                low[u] = min(low[u], low[v])\n\n                # Condici\u00f3n para punto de articulaci\u00f3n\n                if padre.get(u) is None and hijos &gt; 1:\n                    articulaciones.add(u)\n\n                # Si no existe un camino desde `v` o sus descendientes hacia un nodo descubierto antes que `u`\n                # entonces el \u00fanico camino hacia los anteriores, ser\u00eda a trav\u00e9s de `u`\n                if padre.get(u) is not None and low[v] &gt;= disc[u]:\n                    articulaciones.add(u)\n\n                # Condici\u00f3n para puente\n                # Si no se alcanza ning\u00fan nodo descubierto antes que `u`\n                if low[v] &gt; disc[u]:\n                    puentes.append((u, v))\n            elif v != padre.get(u):\n                # Caso de arista de retroceso\n                #\n                low[u] = min(low[u], disc[v])\n\n    for u in grafo:\n        if u not in visitado:\n            dfs(u)\n\n    return articulaciones, puentes\n</code></pre>"},{"location":"oci/grafos/#condiciones-para-punto-de-articulacion","title":"Condiciones para Punto de Articulaci\u00f3n","text":"<p>Existen dos casos en que un nodo <code>u</code> es punto de articulaci\u00f3n:</p>"},{"location":"oci/grafos/#a-u-es-la-raiz-del-arbol-dfs-y-tiene-mas-de-un-hijo","title":"a) <code>u</code> es la ra\u00edz del \u00e1rbol DFS y tiene m\u00e1s de un hijo","text":"<pre><code>if padre.get(u) is None and hijos &gt; 1:\n    articulaciones.add(u)\n</code></pre> <ul> <li>Esto significa que <code>u</code> origina m\u00faltiples ramas desconectadas entre s\u00ed.</li> <li>Si se elimina <code>u</code>, esas ramas se separan.</li> </ul>"},{"location":"oci/grafos/#b-u-no-es-raiz-y-tiene-un-hijo-v-tal-que-lowv-discu","title":"b) <code>u</code> no es ra\u00edz y tiene un hijo <code>v</code> tal que <code>low[v] &gt;= disc[u]</code>","text":"<pre><code>if padre.get(u) is not None and low[v] &gt;= disc[u]:\n    articulaciones.add(u)\n</code></pre> <ul> <li>Esto implica que desde <code>v</code> (y sus descendientes) no se puede alcanzar ning\u00fan ancestro de <code>u</code> sin pasar por <code>u</code>.</li> <li>Si se elimina <code>u</code>, <code>v</code> y su sub\u00e1rbol quedan desconectados.</li> </ul>"},{"location":"oci/grafos/#condicion-para-puente","title":"Condici\u00f3n para Puente","text":"<pre><code>if low[v] &gt; disc[u]:\n    puentes.append((u, v))\n</code></pre> <ul> <li>Significa que la arista <code>(u, v)</code> es la \u00fanica conexi\u00f3n entre los nodos <code>u</code> y <code>v</code>.</li> <li>No existe un camino alternativo desde <code>v</code> (ni sus descendientes) que regrese hacia <code>u</code> o sus ancestros.</li> </ul>"},{"location":"oci/grafos/#explicacion-del-algoritmo","title":"Explicaci\u00f3n del algoritmo","text":"<ol> <li>Al visitar <code>u</code>, se asigna <code>disc[u] = low[u] = tiempo</code>.</li> <li>Se recorre cada vecino <code>v</code> de <code>u</code>.</li> <li>Si <code>v</code> no est\u00e1 visitado, se hace DFS sobre <code>v</code>.</li> <li>Al volver de la recursi\u00f3n, se actualiza <code>low[u] = min(low[u], low[v])</code>.</li> <li>Se verifica si <code>u</code> es punto de articulaci\u00f3n y si <code>(u, v)</code> es un puente.</li> <li>Si <code>v</code> ya fue visitado y no es el padre de <code>u</code>, se actualiza:</li> </ol> <pre><code>low[u] = min(low[u], disc[v])\n</code></pre> <p>Esto corresponde a una arista de retroceso.</p>"},{"location":"oci/grafos/#ejemplo_1","title":"Ejemplo","text":"<pre><code>grafo = {\n    0: [1, 2],\n    1: [0, 2],\n    2: [0, 1, 3],\n    3: [2, 4, 5],\n    4: [3],\n    5: [3]\n}\n</code></pre> <p>Salida:</p> <pre><code>articulaciones = {2, 3}\npuentes = [(2, 3), (3, 4), (3, 5)]\n</code></pre> <ul> <li>El algoritmo tiene complejidad O(V + E).</li> <li>Solo aplica para grafos no dirigidos.</li> </ul>"},{"location":"oci/programacion_dinamica/","title":"Programaci\u00f3n Din\u00e1mica","text":""},{"location":"oci/programacion_dinamica/#que-es-la-programacion-dinamica","title":"\u00bfQu\u00e9 es la programaci\u00f3n din\u00e1mica?","text":"<p>La Programaci\u00f3n Din\u00e1mica (DP) es una t\u00e9cnica de dise\u00f1o algor\u00edtmico utilizada para resolver problemas que pueden dividirse en subproblemas m\u00e1s peque\u00f1os, donde estos subproblemas se repiten una y otra vez.</p> <p>En muchos algoritmos (como la recursi\u00f3n directa), se vuelven a calcular los mismos resultados m\u00faltiples veces, lo cual puede provocar un aumento exponencial de tiempo de ejecuci\u00f3n. La programaci\u00f3n din\u00e1mica resuelve esta ineficiencia guardando los resultados de subproblemas ya resueltos, para evitar recomputaciones innecesarias.</p>"},{"location":"oci/programacion_dinamica/#cuando-se-debe-usar-programacion-dinamica","title":"\u00bfCu\u00e1ndo se debe usar programaci\u00f3n din\u00e1mica?","text":"<ul> <li>Cuando el problema presenta subestructura \u00f3ptima, es decir, se puede construir una soluci\u00f3n \u00f3ptima a partir de soluciones \u00f3ptimas de subproblemas.</li> <li>Cuando existe superposici\u00f3n de subproblemas, es decir, se resuelven los mismos subproblemas muchas veces.</li> <li>Son comunes en problemas de conteo, caminos \u00f3ptimos, secuencias, subconjuntos, entre otros.</li> </ul>"},{"location":"oci/programacion_dinamica/#tipos-de-programacion-dinamica","title":"Tipos de programaci\u00f3n din\u00e1mica","text":"Caracter\u00edstica Top-Down (Memoizaci\u00f3n) Bottom-Up (Tabulaci\u00f3n) Estrategia Divide y vencer\u00e1s con recursividad Construcci\u00f3n iterativa desde los casos base Implementaci\u00f3n Recursiva + almacenamiento de resultados (memo) Iterativa usando una tabla o vector Desventaja Consume pila (riesgo de stack overflow) Puede ser m\u00e1s dif\u00edcil de escribir Orden de resoluci\u00f3n Del problema original hacia los subproblemas De los subproblemas m\u00e1s peque\u00f1os hacia el original"},{"location":"oci/programacion_dinamica/#ejemplo-fibonacci","title":"Ejemplo: Fibonacci","text":"<p>A continuaci\u00f3n se presentan tres formas de resolver el problema de Fibonacci utilizando Programaci\u00f3n Din\u00e1mica:</p> <ul> <li>Memoizaci\u00f3n autom\u00e1tica</li> <li>Memoizaci\u00f3n manual (top-down)</li> <li>Tabulaci\u00f3n iterativa (bottom-up).</li> </ul>"},{"location":"oci/programacion_dinamica/#1-memoizacion-automatica-con-lru_cache","title":"1. Memoizaci\u00f3n autom\u00e1tica con <code>@lru_cache</code>","text":"<pre><code>from functools import lru_cache\n\n# Decorador que almacena autom\u00e1ticamente los resultados previos\n@lru_cache(maxsize=None)\ndef fibonacci(n):\n    # Caso base: fib(0) = 0\n    if n == 0:\n        return 0\n    # Caso base: fib(1) = 1\n    if n == 1:\n        return 1\n    # Llamadas recursivas optimizadas por cach\u00e9\n    print(f\"Calculando fib({n})\")\n    return fibonacci(n - 1) + fibonacci(n - 2)\n</code></pre> <p>Explicaci\u00f3n del algoritmo:</p> <ul> <li>Se utiliza el decorador <code>@lru_cache</code> para guardar autom\u00e1ticamente los resultados previos.</li> <li>Al hacer una llamada con un valor ya calculado, se devuelve directamente sin volver a ejecutar la funci\u00f3n.</li> <li>Evita recomputaciones y reduce la complejidad de tiempo de exponencial a lineal.</li> <li>Es pr\u00e1ctico y conciso, ideal para prototipos o problemas sencillos.</li> </ul>"},{"location":"oci/programacion_dinamica/#2-memoizacion-manual-top-down","title":"2. Memoizaci\u00f3n manual (Top-Down)","text":"<pre><code>def fibonacci_top_down(n, memo=None):\n    # Se crea el diccionario memo solo en la primera llamada\n    if memo is None:\n        memo = {}\n\n    # Reutilizar resultado ya calculado\n    if n in memo:\n        return memo[n]\n\n    # Casos base\n    if n == 0:\n        return 0\n    if n == 1:\n        return 1\n\n    # Guardar el resultado calculado en memo\n    memo[n] = fibonacci_top_down(n - 1, memo) + fibonacci_top_down(n - 2, memo)\n    return memo[n]\n</code></pre> <p>Explicaci\u00f3n del algoritmo:</p> <ul> <li>Utiliza recursividad con un diccionario expl\u00edcito (<code>memo</code>) para guardar subresultados.</li> <li>Solo se calcula cada valor de Fibonacci una vez.</li> <li>Se puede adaptar f\u00e1cilmente a problemas con m\u00faltiples par\u00e1metros.</li> <li>Requiere un poco m\u00e1s de c\u00f3digo, pero da mayor control.</li> </ul>"},{"location":"oci/programacion_dinamica/#3-tabulacion-bottom-up","title":"3. Tabulaci\u00f3n (Bottom-Up)","text":"<pre><code>def fibonacci_bottom_up(n):\n    # Casos base\n    if n == 0:\n        return 0\n    if n == 1:\n        return 1\n\n    # Inicializar la tabla con valores base\n    fib = [0] * (n + 1)\n    fib[1] = 1\n\n    # Llenar la tabla de abajo hacia arriba\n    for i in range(2, n + 1):\n        fib[i] = fib[i - 1] + fib[i - 2]\n\n    return fib[n]\n</code></pre> <p>Explicaci\u00f3n del algoritmo:</p> <ul> <li>Se construye una lista <code>fib</code> para almacenar todos los resultados desde 0 hasta <code>n</code>.</li> <li>Se inicializan los casos base (<code>fib[0] = 0</code>, <code>fib[1] = 1</code>).</li> <li>Cada nuevo valor se calcula iterativamente a partir de los dos anteriores.</li> <li>No usa recursi\u00f3n, por lo que es m\u00e1s seguro para <code>n</code> grandes y evita desbordamientos de pila.</li> </ul>"},{"location":"oci/programacion_dinamica/#ejemplo-mochila-01","title":"Ejemplo: Mochila 0/1","text":"<p>Dado un conjunto de objetos, cada uno con un peso y un valor, y una mochila con una capacidad m\u00e1xima, determinar el valor m\u00e1ximo que se puede obtener sin exceder la capacidad. Cada objeto se puede tomar una sola vez.</p> <pre><code>def mochila(pesos, valores, capacidad):\n    n = len(pesos)  # N\u00famero de objetos\n\n    # Crear una tabla (n+1) x (capacidad+1) inicializada en 0\n    dp = [[0] * (capacidad + 1) for _ in range(n + 1)]\n\n    # Llenar la tabla iterativamente\n    for i in range(1, n + 1):\n        for w in range(capacidad + 1):\n            if pesos[i - 1] &lt;= w:\n                # Opci\u00f3n 1: no tomar el objeto\n                # Opci\u00f3n 2: tomar el objeto y sumar su valor\n                dp[i][w] = max(\n                    dp[i - 1][w],\n                    valores[i - 1] + dp[i - 1][w - pesos[i - 1]]\n                )\n            else:\n                # No cabe el objeto, se mantiene el valor anterior\n                dp[i][w] = dp[i - 1][w]\n\n    return dp[n][capacidad]\n\n# Ejemplo de prueba\npesos = [1, 3, 4]\nvalores = [15, 20, 30]\ncapacidad = 4\nprint(mochila(pesos, valores, capacidad))  # Salida esperada: 35\n</code></pre> <p>Explicaci\u00f3n del algoritmo:</p> <ul> <li>Se usa una tabla <code>dp[i][w]</code> donde:</li> <li><code>i</code> representa el n\u00famero de objetos considerados.</li> <li><code>w</code> representa la capacidad actual.</li> <li>Para cada objeto y para cada capacidad:</li> <li>Si el objeto cabe, se elige entre tomarlo o no, seg\u00fan qu\u00e9 opci\u00f3n da mayor valor.</li> <li>Si no cabe, se mantiene el valor anterior.</li> <li>La respuesta est\u00e1 en <code>dp[n][capacidad]</code>, usando todos los objetos disponibles.</li> </ul>"},{"location":"oci/programacion_dinamica/#ejemplo-longest-common-subsequence-lcs","title":"Ejemplo: Longest Common Subsequence (LCS)","text":"<p>Dadas dos cadenas, encontrar la longitud de la subsecuencia com\u00fan m\u00e1s larga que aparece en ambas. Una subsecuencia es una secuencia que aparece en el mismo orden, pero no necesariamente de forma contigua.</p> <pre><code>def lcs(cadena1, cadena2):\n    n = len(cadena1)\n    m = len(cadena2)\n\n    # Crear una tabla (n+1) x (m+1) inicializada en 0\n    dp = [[0] * (m + 1) for _ in range(n + 1)]\n\n    # Llenar la tabla comparando caracteres\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            if cadena1[i - 1] == cadena2[j - 1]:\n                # Si los caracteres coinciden, se extiende la subsecuencia\n                dp[i][j] = 1 + dp[i - 1][j - 1]\n            else:\n                # Si no coinciden, se toma el m\u00e1ximo de excluir uno u otro\n                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n\n    return dp[n][m]\n\n# Ejemplo de prueba\ncadena1 = \"abcde\"\ncadena2 = \"ace\"\nprint(lcs(cadena1, cadena2))  # Salida esperada: 3\n</code></pre> <p>Explicaci\u00f3n del algoritmo:</p> <ul> <li>Se usa una tabla <code>dp[i][j]</code> donde:</li> <li><code>i</code> representa los primeros <code>i</code> caracteres de <code>cadena1</code>.</li> <li><code>j</code> representa los primeros <code>j</code> caracteres de <code>cadena2</code>.</li> <li>Si los caracteres coinciden, se extiende la subsecuencia.</li> <li>Si no, se elige el mejor resultado entre:</li> <li>Excluir el car\u00e1cter actual de <code>cadena1</code>.</li> <li>Excluir el car\u00e1cter actual de <code>cadena2</code>.</li> <li>La respuesta final se encuentra en <code>dp[n][m]</code>, que representa la longitud del LCS entre ambas cadenas completas.</li> </ul>"},{"location":"practicas_evaluadas/S1/001/","title":"Calculadora sencilla en Python","text":"<p>Realice una calculadora que cumpla con los siguientes requerimientos:</p> <ul> <li>Muestra un mensaje de saludo al usuario al comenzar la ejecuci\u00f3n.</li> <li>Ingresa dos n\u00fameros de la terminal del tipo <code>float</code>.</li> <li>Realiza la suma, resta, multiplicaci\u00f3n y divisi\u00f3n de los n\u00fameros.</li> <li>Imprime los resultados de cada operaci\u00f3n en el formato: <code>{Operaci\u00f3n}: {Resultado}</code></li> <li>Agreguen comentarios para describir cada paso.</li> </ul> <p>Ejecuci\u00f3n esperada</p> <pre><code>Bienvenido a la calculadora de {nombre}\n\nIngrese el primer n\u00famero: 10\nIngrese el segundo n\u00famero: 20\n\nResultados:\nSuma: 30\nResta: -10\nMultiplicaci\u00f3n: 200\nDivisi\u00f3n: 0.5\n</code></pre>"},{"location":"practicas_evaluadas/S1/002/","title":"Pr\u00e1ctica 2","text":""},{"location":"practicas_evaluadas/S1/002/#practica-evaluada-2","title":"Pr\u00e1ctica Evaluada 2","text":"<p>Se debe implementar un programa en Python que presente un men\u00fa interactivo con las siguientes opciones:</p>"},{"location":"practicas_evaluadas/S1/002/#1-verificar-divisibilidad","title":"1. Verificar divisibilidad","text":"<ul> <li>El usuario ingresa dos n\u00fameros enteros, <code>a</code> y <code>b</code>.</li> <li>El programa determina si <code>a</code> es divisible por <code>b</code> y muestra un mensaje indicando si la divisi\u00f3n es exacta o no.</li> <li>Si <code>b</code> es 0, lo cual provoca una divisi\u00f3n indefinida, se debe de verificar antes de realizar la divisi\u00f3n con un <code>if</code> para mostrar un mensaje de error.</li> </ul>"},{"location":"practicas_evaluadas/S1/002/#2-manipulacion-de-string-con-slicing","title":"2. Manipulaci\u00f3n de string con slicing","text":"<ul> <li>El usuario ingresa una cadena de texto.</li> <li>Se debe mostrar la cadena en orden inverso.<ul> <li>Sugerencia: Con <code>string[::-1]</code> hace slicing desde el inicio hasta el final, con un paso de -1 (orden inverso).</li> </ul> </li> </ul>"},{"location":"practicas_evaluadas/S1/002/#3-extra-calculo-de-una-raiz-n-esima","title":"3. Extra: C\u00e1lculo de una ra\u00edz n-\u00e9sima","text":"<ul> <li>El usuario ingresa dos n\u00fameros: <code>x</code> y <code>n</code>, donde <code>x</code> es el n\u00famero del que se quiere calcular la ra\u00edz y <code>n</code> es el \u00edndice de la ra\u00edz.</li> <li>El programa calcula la ra\u00edz n-\u00e9sima de <code>x</code> usando la funci\u00f3n <code>x ** (1/n)</code>.</li> <li>Se debe validar que <code>n</code> sea un n\u00famero positivo y diferente de 0.</li> <li>Si <code>x</code> es negativo y <code>n</code> es par, se debe mostrar un mensaje de error, puesto que los n\u00fameros negativos no tienen ra\u00edces pares reales.</li> </ul>"},{"location":"practicas_evaluadas/S1/002/#requisitos","title":"Requisitos","text":"<ul> <li>El programa debe implementarse usando un men\u00fa con <code>if-elif-else</code>.</li> </ul>"},{"location":"practicas_evaluadas/S1/003/","title":"Pr\u00e1ctica Evaluada 3","text":""},{"location":"practicas_evaluadas/S1/003/#ejercicio-1-convertir-palabras-a-mayusculas-si-tienen-mas-de-5-letras","title":"Ejercicio 1: Convertir palabras a may\u00fasculas si tienen m\u00e1s de 5 letras","text":"<ul> <li>Use un <code>for</code> loop para recorrer la lista de palabras.</li> <li>Dentro del loop, revise la longitud de cada palabra con <code>len()</code>.</li> <li>Si la longitud es mayor a 5, use <code>.upper()</code> para convertir la palabra en may\u00fasculas.</li> <li>Guarde los resultados en una nueva lista. Esta debe ser declarada antes del <code>for</code>, no dentro, para poder modificarla (por el alcance o scope explicado en clase).</li> <li>Use <code>print()</code> para mostrar la lista resultante.</li> </ul> <pre><code>Entrada: [\"hola\", \"elefante\", \"mundo\", \"estrella\"]  \nSalida: [\"hola\", \"ELEFANTE\", \"mundo\", \"ESTRELLA\"]\n</code></pre>"},{"location":"practicas_evaluadas/S1/003/#ejercicio-2-reemplazar-vocales-en-una-palabra","title":"Ejercicio 2: Reemplazar vocales en una palabra","text":"<ul> <li>Use un <code>for</code> loop para recorrer cada letra de la palabra.</li> <li>Verifique si la letra es una vocal <code>(a, e, i, o, u)</code>.</li> <li>Si es una vocal, reemplazar por <code>*</code>, si no, deje la letra igual.</li> <li>Construya la nueva palabra con las letras modificadas. Defina una variable <code>palabra_nueva</code> antes del loop y vaya concatenando los nuevos caracteres conforme avanza en el loop.</li> <li>Use <code>print()</code> para mostrar el resultado.</li> </ul> <pre><code>Entrada: \"programacion\"  \nSalida: \"pr*gr*m*c**n\"\n</code></pre>"},{"location":"practicas_evaluadas/S1/004/","title":"Pr\u00e1ctica Evaluada 4","text":""},{"location":"practicas_evaluadas/S1/004/#enunciado","title":"Enunciado","text":"<p>Se solicita implementar una funci\u00f3n recursiva en Python que reciba una cadena de texto y devuelva el n\u00famero total de vocales que contiene.</p> <p>La funci\u00f3n no debe utilizar estructuras de repetici\u00f3n como <code>for</code> o <code>while</code>, ni m\u00e9todos como <code>.count()</code>.</p> <p>La funci\u00f3n debe contar tanto vocales min\u00fasculas como may\u00fasculas (<code>a, e, i, o, u, A, E, I, O, U</code>).</p>"},{"location":"practicas_evaluadas/S1/004/#archivo-requerido","title":"Archivo requerido","text":"<p>Se debe crear un archivo llamado <code>recursividad.py</code> con el siguiente contenido base:</p> <pre><code>def contar_vocales(cadena):\n    # Implementaci\u00f3n recursiva\n    pass\n\ntexto = input(\"Ingrese una cadena: \")\nprint(\"Cantidad de vocales:\", contar_vocales(texto))\n</code></pre>"},{"location":"practicas_evaluadas/S1/004/#pista","title":"Pista","text":"<p>Se recomienda revisar el primer car\u00e1cter de la cadena y verificar si es una vocal. En caso afirmativo, se debe sumar uno y llamar nuevamente a la funci\u00f3n con el resto de la cadena. Si no es vocal, simplemente se contin\u00faa con la llamada recursiva sin incrementar el contador.</p>"},{"location":"practicas_evaluadas/S1/004/#ejemplos-de-ejecucion","title":"Ejemplos de ejecuci\u00f3n","text":"<pre><code>Ingrese una cadena: Python es util\nCantidad de vocales: 4\n</code></pre>"},{"location":"practicas_evaluadas/S1/004/#restricciones","title":"Restricciones","text":"<ul> <li>No se permite el uso de ciclos (<code>for</code>, <code>while</code>).</li> <li>No se permite el uso de m\u00e9todos como <code>.count()</code> ni expresiones regulares.</li> <li>Se debe utilizar exclusivamente recursi\u00f3n y funciones propias.</li> </ul>"},{"location":"practicas_evaluadas/S1/004/#criterios-de-evaluacion","title":"Criterios de evaluaci\u00f3n","text":"Criterio Puntos Implementaci\u00f3n recursiva funcional de <code>contar_vocales</code> 50 Manejo correcto de may\u00fasculas y min\u00fasculas 20 Estructura clara, c\u00f3digo indentado 10 Entrada y salida definida 10 Documentaci\u00f3n y uso de comentarios relevantes 10 Total 100"},{"location":"practicas_evaluadas/S2/001/","title":"Pr\u00e1ctica evaluada 1: <code>CuentaBancaria</code>","text":"<p>Implemente una clase <code>CuentaBancaria</code> que modele una cuenta simple.</p>"},{"location":"practicas_evaluadas/S2/001/#requerimientos-funcionales","title":"Requerimientos funcionales","text":"<ul> <li>Atributos de instancia (inicializados en <code>__init__</code>):</li> <li><code>titular: str</code></li> <li><code>moneda: str</code> (por ejemplo <code>\"CRC\"</code> o <code>\"USD\"</code>)</li> <li><code>saldo: float</code><ul> <li>Inicia con el par\u00e1metro <code>saldo_inicial</code>, por defecto <code>0.0</code>. Recuerde el uso de par\u00e1metros predeterminados.</li> </ul> </li> <li>M\u00e9todos de instancia:</li> <li><code>consultar_saldo() -&gt; float</code>     Devuelve el saldo sin modificarlo (consultor).</li> <li><code>depositar(monto: float) -&gt; None</code>     Suma <code>monto</code> al saldo solo si <code>monto &gt; 0</code>.</li> <li><code>retirar(monto: float) -&gt; bool</code>     Resta <code>monto</code> del saldo solo si <code>0 &lt; monto &lt;= saldo</code>.     Retorna <code>True</code> si se realiz\u00f3 la operaci\u00f3n, <code>False</code> en caso contrario</li> </ul> <pre><code>classDiagram\n    class CuentaBancaria {\n      - titular: str\n      - moneda: str\n      - saldo: float\n      + consultar_saldo(): float\n      + depositar(monto: float): void\n      + retirar(monto: float): bool\n    }</code></pre>"},{"location":"practicas_evaluadas/S2/001/#requerimientos-de-demostracion","title":"Requerimientos de demostraci\u00f3n","text":"<ul> <li>Crear al menos dos objetos <code>CuentaBancaria</code> con estados iniciales distintos.</li> <li>Ejecutar una secuencia de operaciones (<code>depositar</code>, <code>retirar</code>, <code>consultar_saldo</code>) sobre cada objeto y mostrar por pantalla:</li> <li>El titular y el saldo despu\u00e9s de las operaciones.</li> <li>Que las operaciones sobre una cuenta no afectan el estado de la otra (estado independiente).</li> </ul>"},{"location":"practicas_evaluadas/S2/001/#restricciones","title":"Restricciones","text":"<ul> <li>No usar variables globales; toda la informaci\u00f3n debe vivir en las instancias.</li> <li>Entregue un \u00fanico archivo <code>cuenta_bancaria.py</code> con la soluci\u00f3n.</li> </ul>"},{"location":"practicas_evaluadas/S2/001/#criterios-de-evaluacion","title":"Criterios de evaluaci\u00f3n","text":"Criterio Descripci\u00f3n Puntos Definici\u00f3n de clase y <code>__init__</code> La clase existe, <code>__init__</code> recibe par\u00e1metros adecuados y crea los atributos <code>titular</code>, <code>moneda</code>, <code>saldo</code>. 15 Atributos de instancia Los atributos se inicializan en <code>__init__</code> y se acceden v\u00eda <code>self</code>. 10 <code>consultar_saldo()</code> (consultor) Retorna el saldo sin efectos secundarios. 10 <code>depositar(monto)</code> (mutador) Valida <code>monto &gt; 0</code> y actualiza el saldo correctamente. 15 <code>retirar(monto)</code> (mutador) Valida <code>0 &lt; monto &lt;= saldo</code>, actualiza correctamente y retorna <code>True/False</code> seg\u00fan corresponda. 20 Estado independiente Se crean al menos dos cuentas y se evidencia que operar sobre una no cambia la otra. 10 Demostraci\u00f3n y salida Secuencia de pruebas clara y resultados coherentes. 10 Estilo y buenas pr\u00e1cticas Nombres descriptivos, uso correcto de <code>self</code> y comentarios claros. 10 Total 100"},{"location":"practicas_evaluadas/S2/002/","title":"Pr\u00e1ctica evaluada 2: Red de contactos","text":"<p>Planteamiento</p> <p>En una red social, cada persona es un nodo y las amistades son aristas. Dada una persona, encuentre todas las que se encuentran a una distancia m\u00e1xima de 2 grados de separaci\u00f3n.</p> <p>Sugerencia</p> <ul> <li>Modele la red como un grafo no dirigido.</li> <li>Use BFS y detenga la b\u00fasqueda cuando la distancia supere 2.</li> <li>Devuelva la lista de nodos alcanzables.</li> </ul> <pre><code>graph LR\n  Ana --- Luis\n  Ana --- Maria\n  Luis --- Maria\n  Luis --- Carlos\n  Maria --- Elena\n  Carlos --- Pedro\n\n  %% Distancias desde Ana:\n  %% 0: Ana\n  %% 1: Luis, Maria\n  %% 2: Carlos, Elena</code></pre> <ul> <li>Respuesta esperada para <code>Ana</code>: <code>{Luis, Maria, Carlos, Elena}</code>.</li> </ul> <p>Tip</p> <ul> <li>Utilice una cola de <code>deque</code> con tuplas <code>(nodo, distancia)</code>.</li> <li>Corte la expansi\u00f3n cuando <code>distancia == 2</code>.</li> </ul> <pre><code>from collections import deque\n\nred = {\n    'Ana': ['Luis', 'Mar\u00eda'],\n    'Luis': ['Ana', 'Carlos', 'Maria'],\n    'Mar\u00eda': ['Ana', 'Elena', 'Luis'],\n    'Carlos': ['Luis', 'Pedro'],\n    'Elena': ['Mar\u00eda'],\n    'Pedro': ['Carlos']\n}\n\ndef contactos_en_dos_grados(inicio):\n    visitados = {inicio}\n    cola = deque([(inicio, 0)])\n    resultado = []\n\n    while cola:\n        # Sacar elemento de la cola\n\n        # Caso 1: Distancia entre 0 y 2 \u2013&gt; Agregar a la lista de resultado\n\n        # Caso 2: Distancia menor que 2 \u2013&gt; Recorrer vecinos\n        # En el loop, se agrega a visitados si no lo est\u00e1\n        # y se agrega a la cola\n\n    return resultado\n\nprint(contactos_en_dos_grados('Ana'))\n</code></pre>"},{"location":"practicas_evaluadas/S2/003/","title":"Pr\u00e1ctica evaluada 3: Git y GitHub","text":"<p>Objetivo general</p> <p>Poner en pr\u00e1ctica los comandos esenciales de Git y GitHub a trav\u00e9s de un proyecto en Python. Cada estudiante clonar\u00e1 un repositorio, personalizar\u00e1 sus datos, ejecutar\u00e1 el programa, y subir\u00e1 los resultados al repositorio remoto.</p>"},{"location":"practicas_evaluadas/S2/003/#clonar-el-repositorio","title":"Clonar el repositorio","text":"<ol> <li>En la p\u00e1gina del repositorio en GitHub, copiar la URL <code>HTTPS</code>.</li> <li>Abrir una terminal y clonar el repositorio con:    <pre><code>git clone https://github.com/usuario/nombre-repo.git\ncd nombre-repo\n</code></pre></li> <li>Verificar el contenido del proyecto:    <pre><code>ls\n</code></pre></li> </ol>"},{"location":"practicas_evaluadas/S2/003/#estructura-del-proyecto","title":"Estructura del proyecto","text":"<p>Cree una carpeta <code>practicas_evaluadas/pe03/</code> dentro del repositorio con:</p> <pre><code>mkdir -p practicas_evaluadas/pe03\n</code></pre> <p>Dentro de esta carpeta, realice la siguiente estructura:</p> <pre><code>.\n\u251c\u2500\u2500 practicas_evaluadas/\n\u2502   \u2514\u2500\u2500 pe03/\n\u2502       \u251c\u2500\u2500 README.md\n\u2502       \u251c\u2500\u2500 data/\n\u2502       \u2502   \u2514\u2500\u2500 estudiante.txt\n\u2502       \u251c\u2500\u2500 salida/\n\u2502       \u2502   \u2514\u2500\u2500 resumen.txt  (se genera al ejecutar el programa)\n\u2502       \u2514\u2500\u2500 src/\n\u2502           \u251c\u2500\u2500 app.py\n\u2502           \u2514\u2500\u2500 modelo.py\n\u251c\u2500\u2500 README.md\n\u2514\u2500\u2500 .gitignore\n</code></pre> <p>Anotaciones</p> <ul> <li><code>data/estudiante.txt</code> contiene los datos que cada estudiante debe personalizar.</li> <li><code>src/app.py</code> es el punto de entrada principal.</li> <li><code>src/modelo.py</code> define la clase <code>Estudiante</code> y la lectura/escritura de archivos.</li> <li><code>salida/resumen.txt</code> se genera autom\u00e1ticamente.</li> </ul>"},{"location":"practicas_evaluadas/S2/003/#contenido-de-los-archivos","title":"Contenido de los archivos","text":"<p>A continuaci\u00f3n, copie y pegue el siguiente c\u00f3digo en los archivos correspondientes dentro de la carpeta <code>practicas_evaluadas/pe03/</code>.</p>"},{"location":"practicas_evaluadas/S2/003/#readmemd","title":"<code>README.md</code>","text":"<p>Como documentaci\u00f3n general de lo realizado.</p> <pre><code># Descripci\u00f3n\n\nProyecto de pr\u00e1ctica evaluada que utiliza programaci\u00f3n orientada a objetos y manejo de archivos en Python.\nEl objetivo es generar un resumen con la informaci\u00f3n del estudiante y guardarlo en un archivo de texto.\n\n## Instrucciones\n\n1. Completar los datos en `data/estudiante.txt`.\n2. Ejecutar `python3 src/app.py` para generar el resumen.\n3. Verificar la creaci\u00f3n de `salida/resumen.txt`.\n4. Hacer commit y push de los cambios a GitHub.\n</code></pre>"},{"location":"practicas_evaluadas/S2/003/#gitignore","title":"<code>.gitignore</code>","text":"<p>Este archivo sirve para indicarle a Git los archivos y/o directorios que debe ignorar. A continuaci\u00f3n, se muestran algunos t\u00edpicos en el desarrollo de Python.</p> <pre><code>__pycache__/\n*.pyc\n.venv/\nvenv/\n.env\n</code></pre>"},{"location":"practicas_evaluadas/S2/003/#srcmodelopy","title":"<code>src/modelo.py</code>","text":"<pre><code>\"\"\"\n@file modelo.py\n@brief Clases de dominio para la pr\u00e1ctica (POO + archivos).\n\"\"\"\n\nfrom pathlib import Path\nfrom typing import Dict, List\n\n\nclass Estudiante:\n    \"\"\"\n    @brief Modelo de estudiante con datos b\u00e1sicos.\n    \"\"\"\n\n    def __init__(self, nombre: str, correo: str, materias: List[str] | None = None) -&gt; None:\n        self.nombre = nombre.strip()\n        self.correo = correo.strip()\n        self.materias = [m.strip() for m in (materias or []) if m.strip()]\n\n    def resumen(self) -&gt; str:\n        lineas = [\n            f\"Nombre: {self.nombre}\",\n            f\"Correo: {self.correo}\",\n            f\"Materias: {', '.join(self.materias) if self.materias else 'N/A'}\",\n        ]\n        return \"\\n\".join(lineas)\n\n\nclass GestorArchivos:\n    \"\"\"\n    @brief Utilidades para leer/escribir archivos de texto plano.\n    \"\"\"\n\n    @staticmethod\n    def leer_kv(ruta: Path) -&gt; Dict[str, str]:\n        \"\"\"\n        @brief Lee pares clave=valor, ignora l\u00edneas vac\u00edas y comentarios (#).\n        @param ruta: Ruta del archivo de datos.\n        @return Diccionario con claves en may\u00fascula.\n        \"\"\"\n        datos: Dict[str, str] = {}\n        with open(ruta, \"r\", encoding=\"utf-8\") as f:\n            for linea in f:\n                linea = linea.strip()\n                if not linea or linea.startswith(\"#\"):\n                    continue\n                if \"=\" not in linea:\n                    continue\n                clave, valor = linea.split(\"=\", 1)\n                datos[clave.strip().upper()] = valor.strip()\n        return datos\n\n    @staticmethod\n    def escribir_texto(ruta: Path, contenido: str) -&gt; None:\n        \"\"\"\n        @brief Escribe texto en la ruta indicada, crea carpetas si no existen.\n        \"\"\"\n        ruta.parent.mkdir(parents=True, exist_ok=True)\n        with open(ruta, \"w\", encoding=\"utf-8\") as f:\n            f.write(contenido)\n</code></pre>"},{"location":"practicas_evaluadas/S2/003/#srcapppy","title":"<code>src/app.py</code>","text":"<pre><code>\"\"\"\n@file app.py\n@brief Programa principal de la pr\u00e1ctica PE03.\n\"\"\"\n\nfrom pathlib import Path\nfrom modelo import Estudiante, GestorArchivos\n\nRUTA_BASE = Path(__file__).resolve().parents[1]\nRUTA_DATOS = RUTA_BASE / \"data\" / \"estudiante.txt\"\nRUTA_SALIDA = RUTA_BASE / \"salida\" / \"resumen.txt\"\n\n\ndef construir_estudiante() -&gt; Estudiante:\n    if not RUTA_DATOS.exists():\n        raise FileNotFoundError(f\"No se encontr\u00f3 el archivo de datos: {RUTA_DATOS}\")\n\n    kv = GestorArchivos.leer_kv(RUTA_DATOS)\n    nombre = kv.get(\"NOMBRE\", \"N/A\")\n    correo = kv.get(\"CORREO\", \"N/A\")\n\n    materias = []\n    if \"MATERIAS\" in kv and kv[\"MATERIAS\"]:\n        materias = [m.strip() for m in kv[\"MATERIAS\"].split(\",\")]\n\n    return Estudiante(nombre, correo, materias)\n\n\ndef main() -&gt; None:\n    estudiante = construir_estudiante()\n    texto = estudiante.resumen()\n    print(texto)\n    GestorArchivos.escribir_texto(RUTA_SALIDA, texto)\n    print(f\"\\nResumen generado correctamente en: {RUTA_SALIDA}\")\n\n\nif __name__ == \"__main__\":\n    main()\n</code></pre>"},{"location":"practicas_evaluadas/S2/003/#dataestudiantetxt","title":"<code>data/estudiante.txt</code>","text":"<p>Reemplazar los valores con su informaci\u00f3n personal:</p> <pre><code># Archivo de datos del estudiante\nNOMBRE=Nombre completo\nCORREO=Correo\nMATERIAS=Curso1, Curso2, Curso3\n</code></pre>"},{"location":"practicas_evaluadas/S2/003/#ejecutar-el-programa","title":"Ejecutar el programa","text":"<ol> <li>Ejecutar el programa principal desde el directorio <code>practicas_evaluadas/pe03/</code>:    <pre><code>python src/app.py\n</code></pre></li> <li>En la terminal se mostrar\u00e1 un resumen con la informaci\u00f3n personalizada.</li> <li>Verificar que se gener\u00f3 el archivo <code>salida/resumen.txt</code> con el mismo contenido.</li> </ol>"},{"location":"practicas_evaluadas/S2/003/#realizar-el-commit-de-los-cambios","title":"Realizar el commit de los cambios","text":"<ol> <li>Agregar los archivos modificados al staging area:    <pre><code>git add &lt;archivos&gt;\n</code></pre></li> <li>Verificar el estado de los archivos agregados:    <pre><code>git status\n</code></pre></li> <li>Confirmar los cambios con un mensaje descriptivo:    <pre><code>git commit -m \"Personaliza datos del estudiante y genera resumen\"\n</code></pre></li> <li>Comprobar el historial:    <pre><code>git log --oneline\n</code></pre></li> </ol>"},{"location":"practicas_evaluadas/S2/003/#subir-los-cambios-al-repositorio-remoto","title":"Subir los cambios al repositorio remoto","text":"<p>Enviar los cambios al repositorio en GitHub:</p> <pre><code>git push\n</code></pre>"},{"location":"practicas_evaluadas/S2/003/#verificar-los-resultados-en-github","title":"Verificar los resultados en GitHub","text":"<ol> <li>Recargar la p\u00e1gina del repositorio.</li> <li>Confirmar que los archivos modificados aparecen en la lista.</li> <li>Revisar el historial de commits y la fecha del cambio.</li> <li>Abrir el archivo <code>salida/resumen.txt</code> y verificar que contiene la informaci\u00f3n personalizada.</li> </ol>"},{"location":"practicas_evaluadas/S2/003/#evaluacion","title":"Evaluaci\u00f3n","text":"Criterio Ponderaci\u00f3n Clonaci\u00f3n correcta del repositorio 25% Personalizaci\u00f3n de datos 25% Ejecuci\u00f3n del programa 25% Commit y push exitosos 25%"},{"location":"tareas/S1/001/","title":"Tarea 1: Validaciones de Datos y Verificaci\u00f3n de Patr\u00f3n ABBA","text":""},{"location":"tareas/S1/001/#descripcion","title":"Descripci\u00f3n","text":"<p>Esta tarea consiste en dos ejercicios independientes en los que se utilizar\u00e1n m\u00e9todos de strings y la estructura de control <code>if-elif-else</code>. Ambos ejercicios se centran en la manipulaci\u00f3n de texto y la validaci\u00f3n de datos.</p> <p>Recuerde a\u00f1adir comentarios descriptivos a su soluci\u00f3n, as\u00ed como asignar nombres de variables claros.</p>"},{"location":"tareas/S1/001/#ejercicio-1-registro-de-usuario-y-validaciones-de-datos","title":"Ejercicio 1: Registro de Usuario y Validaciones de Datos","text":"<p>Se requiere un programa en Python que solicite informaci\u00f3n personal al usuario y valide que cada dato cumpla con ciertas condiciones antes de mostrar un resumen con la informaci\u00f3n ingresada.</p> <p>El programa debe solicitar y validar los siguientes datos:</p> <ol> <li>Nombre completo: Debe contener \u00fanicamente letras y espacios.<ul> <li>Sugerencia: <code>string.replace(\" \", \"\").isalpha()</code> se encarga de reemplazar de reemplazar los espacios en un string por caracteres vac\u00edos (similar a quitar los espacios) y luego verifica que el string posea \u00fanicamente letras. Esto se realiza porque <code>isalpha()</code> no reconoce a los espacios como letras.</li> </ul> </li> <li>Edad: Debe ser un n\u00famero entero positivo.</li> <li>Correo electr\u00f3nico: Debe contener el car\u00e1cter <code>@</code>.<ul> <li>Sugerencia: Busque en el string ingresado si contiene el caracter <code>@</code>.</li> </ul> </li> <li>N\u00famero de tel\u00e9fono: Debe contener solo d\u00edgitos y tener al menos 8 caracteres.  <ul> <li>Sugerencia: Verifique que el string ingresado tenga \u00fanicamente d\u00edgitos y que su largo sea mayor que 8.</li> </ul> </li> <li>Pa\u00eds de residencia: No puede estar vac\u00edo.<ul> <li>Sugerencia: Verifique que el string al quitarle los espacios alrededor sea distinto de <code>\"\"</code> (un string vac\u00edo).</li> </ul> </li> </ol> <p>Si un dato ingresado es inv\u00e1lido, se debe mostrar un mensaje de error explicando la raz\u00f3n. Finalmente, si todos los datos son v\u00e1lidos, el programa debe mostrar un resumen con la informaci\u00f3n ingresada.</p>"},{"location":"tareas/S1/001/#ejemplo-de-ejecucion","title":"Ejemplo de Ejecuci\u00f3n","text":"<pre><code>Ingrese su nombre completo: Juan P\u00e9rez\nIngrese su edad: 25\nIngrese su correo electr\u00f3nico: juanperez@gmail.com\nIngrese su n\u00famero de tel\u00e9fono: 87654321\nIngrese su pa\u00eds de residencia: Costa Rica\n\nRegistro exitoso. Informaci\u00f3n ingresada:\nNombre: Juan P\u00e9rez\nEdad: 25\nCorreo: juanperez@gmail.com\nTel\u00e9fono: 87654321\nPa\u00eds: Costa Rica\n</code></pre> <p>Si el usuario ingresa datos inv\u00e1lidos, el programa debe mostrar un mensaje de error:</p> <pre><code>Ingrese su nombre completo: Juan123\nError: El nombre solo debe contener letras y espacios.\n\nIngrese su edad: -5\nError: La edad debe ser un n\u00famero entero positivo.\n\nIngrese su correo electr\u00f3nico: juanperezgmail.com\nError: El correo debe contener '@' y un dominio v\u00e1lido.\n\nIngrese su n\u00famero de tel\u00e9fono: 12345\nError: El n\u00famero de tel\u00e9fono debe contener al menos 8 d\u00edgitos.\n\nNo se pudo realizar el registro del usuario.\n</code></pre>"},{"location":"tareas/S1/001/#criterios-de-evaluacion","title":"Criterios de Evaluaci\u00f3n","text":"<ul> <li>Validaci\u00f3n de Nombre (10%): Se debe comprobar que el nombre solo contenga letras y espacios.</li> <li>Validaci\u00f3n de Edad (10%): Debe asegurarse que sea un n\u00famero entero positivo.</li> <li>Validaci\u00f3n de Correo Electr\u00f3nico (10%): Se debe verificar que tenga una estructura v\u00e1lida con <code>@</code>.</li> <li>Validaci\u00f3n de N\u00famero de Tel\u00e9fono (10%): Debe contener solo d\u00edgitos y al menos 8 caracteres.</li> <li>Presentaci\u00f3n del Resumen (10%): Si todos los datos son v\u00e1lidos, debe mostrarse un resumen claro con la informaci\u00f3n ingresada.</li> </ul>"},{"location":"tareas/S1/001/#ejercicio-2-verificacion-de-un-patron-abba","title":"Ejercicio 2: Verificaci\u00f3n de un Patr\u00f3n ABBA","text":"<p>Escriba un c\u00f3digo en Python que valide si un string cumple con la estructura ABBA (dos palabras que se repiten en orden reflejado).</p>"},{"location":"tareas/S1/001/#requisitos","title":"Requisitos","text":"<ul> <li>Solicitar al usuario dos palabras distintas.</li> <li>Solicitar un string compuesto por esas palabras en alg\u00fan orden (siempre ser\u00e1 un string de cuatro palabras, sin necesidad de validaci\u00f3n).</li> <li>Comparar si las palabras ingresadas siguen el orden ABBA.</li> <li>Mostrar un mensaje indicando si el string cumple o no con el patr\u00f3n.</li> </ul>"},{"location":"tareas/S1/001/#ejemplo-de-ejecucion_1","title":"Ejemplo de Ejecuci\u00f3n","text":"<pre><code>Escriba el string #1: mundo\nEscriba el string #2: hola\nEscriba un string que contenga las palabras anteriores en alg\u00fan orden: hola mundo mundo hola\nEl string S\u00cd cumple con el orden ABBA.\n</code></pre> <p>Otro ejemplo: <pre><code>Escriba el string #1: mundo\nEscriba el string #2: hola\nEscriba un string que contenga las palabras anteriores en alg\u00fan orden: hola hola mundo mundo\nEl string NO cumple con el orden ABBA.\n</code></pre></p>"},{"location":"tareas/S1/001/#pistas-para-la-implementacion","title":"Pistas para la Implementaci\u00f3n","text":"<ul> <li>Utilizar <code>split()</code> para dividir el string con las palabras repetidas en una lista de palabras.</li> <li>Acceder a los elementos de la lista por sus \u00edndices: <code>palabras[0]</code>, <code>palabras[1]</code>, y as\u00ed sucesivamente.</li> <li>Comparar los valores de la lista para verificar si siguen el orden ABBA.</li> <li>Se puede usar <code>if-elif-else</code> para realizar la comparaci\u00f3n.</li> </ul>"},{"location":"tareas/S1/001/#criterios-de-evaluacion_1","title":"Criterios de Evaluaci\u00f3n","text":"<ul> <li>Recepci\u00f3n de Palabras (10%): Se debe solicitar ambas palabras y el string principal.</li> <li>Separaci\u00f3n del String (10%): Se debe dividir correctamente el string en palabras utilizando <code>split()</code>.</li> <li>Verificaci\u00f3n de Patr\u00f3n ABBA (20%): Comparar las palabras ingresadas y determinar si siguen el patr\u00f3n ABBA.</li> <li>Mensaje al Usuario (10%): Se deben mostrar mensajes adecuados indicando si el patr\u00f3n se cumple o no.</li> </ul>"},{"location":"tareas/S1/001/#entrega","title":"Entrega","text":"<ul> <li>El c\u00f3digo de cada ejercicio debe estar en archivos separados (<code>ejercicio1.py</code> y <code>ejercicio2.py</code>).</li> <li>Subir los archivos <code>.py</code> al entorno de Google Classroom designado para el curso.</li> </ul>"},{"location":"tareas/S1/002/","title":"Tarea 2: Listas y Bucles <code>for</code> Anidados","text":""},{"location":"tareas/S1/002/#descripcion","title":"Descripci\u00f3n","text":"<p>Esta tarea consiste en tres ejercicios independientes que emplean listas, bucles <code>for</code> y validaciones b\u00e1sicas de entrada. Los ejercicios se enfocan en el uso de estructuras repetitivas, generaci\u00f3n de salidas en distintos formatos y validaci\u00f3n de strings num\u00e9ricos.</p> <p>Recuerde a\u00f1adir comentarios descriptivos, as\u00ed como utilizar nombres de variables claros en cada uno de sus programas.</p>"},{"location":"tareas/S1/002/#ejercicio-1-generar-lista-con-los-primeros-n-cuadrados","title":"Ejercicio 1: Generar lista con los primeros <code>n</code> cuadrados","text":"<ol> <li>Solicite al usuario un string que cumpla con las siguientes condiciones:</li> <li>Contiene \u00fanicamente d\u00edgitos.</li> <li>Representa un n\u00famero positivo (mayor que 0).</li> <li>Si el valor ingresado es v\u00e1lido, convierta el string a un n\u00famero entero <code>n</code>.</li> <li>Cree una lista con los primeros <code>n</code> cuadrados (es decir, de \\(1^2\\) a \\(n^2\\)).</li> <li>Muestre la lista generada al usuario.</li> </ol>"},{"location":"tareas/S1/002/#ejemplo-de-ejecucion","title":"Ejemplo de Ejecuci\u00f3n","text":"<pre><code>Ingrese un n\u00famero: 5\n[1, 4, 9, 16, 25]\n</code></pre> <p>Si el dato ingresado no es v\u00e1lido, debe mostrarse un mensaje de error adecuado.</p>"},{"location":"tareas/S1/002/#ejercicio-2-dibujar-un-triangulo-con-asteriscos","title":"Ejercicio 2: Dibujar un tri\u00e1ngulo con asteriscos","text":"<ol> <li>Solicite al usuario un string que cumpla las siguientes condiciones:</li> <li>Contiene \u00fanicamente d\u00edgitos.</li> <li>Representa un n\u00famero positivo.</li> <li>Si el valor es v\u00e1lido, convierta el string a un n\u00famero entero <code>n</code>.</li> <li>Dibuje un tri\u00e1ngulo rect\u00e1ngulo de altura <code>n</code> usando asteriscos (<code>*</code>).</li> <li>El tri\u00e1ngulo debe crecer l\u00ednea por l\u00ednea desde 1 hasta <code>n</code> asteriscos.</li> </ol>"},{"location":"tareas/S1/002/#ejemplo-de-ejecucion_1","title":"Ejemplo de Ejecuci\u00f3n","text":"<pre><code>Ingrese un n\u00famero: 4\n*\n**\n***\n****\n</code></pre>"},{"location":"tareas/S1/002/#ejercicio-3-tabla-de-multiplicar-del-1-al-5","title":"Ejercicio 3: Tabla de multiplicar del 1 al 5","text":"<p>Cree un programa en Python que muestre las tablas de multiplicar del 1 al 5, desde el 1 hasta el 10 (ver ejemplo de salida).</p> <ol> <li>Utilice bucles <code>for</code> anidados.</li> <li>No debe recibir entradas del usuario.</li> <li>Cada l\u00ednea debe mostrar una multiplicaci\u00f3n en el formato <code>a x b = resultado</code>.</li> </ol>"},{"location":"tareas/S1/002/#ejemplo-de-salida","title":"Ejemplo de Salida","text":"<pre><code>1 x 1 = 1\n1 x 2 = 2\n...\n3 x 5 = 15\n...\n5 x 10 = 50\n</code></pre>"},{"location":"tareas/S1/002/#entrega","title":"Entrega","text":"<ul> <li>El c\u00f3digo de cada ejercicio debe colocarse en archivos separados:  </li> <li><code>ejercicio1.py</code>, <code>ejercicio2.py</code> y <code>ejercicio3.py</code>.</li> <li>Suba los tres archivos <code>.py</code> al entorno de Google Classroom designado.</li> </ul>"},{"location":"tareas/S1/002/#criterios-de-evaluacion-100-puntos","title":"Criterios de Evaluaci\u00f3n (100 puntos)","text":""},{"location":"tareas/S1/002/#ejercicio-1-generar-lista-con-cuadrados-30-puntos","title":"Ejercicio 1: Generar lista con cuadrados (30 puntos)","text":"<ul> <li>Validaci\u00f3n de entrada: 10 puntos  </li> <li>Generaci\u00f3n correcta de la lista: 10 puntos  </li> <li>Impresi\u00f3n clara del resultado: 10 puntos  </li> </ul>"},{"location":"tareas/S1/002/#ejercicio-2-triangulo-con-asteriscos-30-puntos","title":"Ejercicio 2: Tri\u00e1ngulo con asteriscos (30 puntos)","text":"<ul> <li>Validaci\u00f3n de entrada: 10 puntos  </li> <li>Uso correcto de bucles <code>for</code>: 10 puntos  </li> <li>Formato correcto del tri\u00e1ngulo: 10 puntos  </li> </ul>"},{"location":"tareas/S1/002/#ejercicio-3-tabla-de-multiplicar-40-puntos","title":"Ejercicio 3: Tabla de multiplicar (40 puntos)","text":"<ul> <li>Bucle anidado correcto para todas las combinaciones: 15 puntos  </li> <li>Formato adecuado de salida (<code>a x b = c</code>): 10 puntos  </li> <li>Cobertura completa del 1 al 5 y 1 al 10: 15 puntos</li> </ul>"},{"location":"tareas/S1/003/","title":"Tarea 3: Sistema de gesti\u00f3n de logs de eventos","text":""},{"location":"tareas/S1/003/#enunciado","title":"Enunciado","text":"<p>Desarrolle un programa en Python que permita gestionar un archivo de logs llamado <code>logs.txt</code>. Cada l\u00ednea del archivo representa un evento del sistema con la siguiente estructura:</p> <pre><code>[tipo] mensaje\n</code></pre> <p>donde <code>tipo</code> puede ser: - <code>INFO</code> \u2013 mensajes informativos - <code>ERROR</code> \u2013 errores del sistema - <code>WARNING</code> \u2013 advertencias</p>"},{"location":"tareas/S1/003/#ejemplo-de-contenido","title":"Ejemplo de contenido","text":"<pre><code>[INFO] Inicio del sistema\n[ERROR] No se pudo conectar a la base de datos\n[WARNING] Memoria al 90%\n</code></pre>"},{"location":"tareas/S1/003/#funcionalidades-del-programa","title":"Funcionalidades del programa","text":"<p>El programa debe permitir al usuario:</p> <ol> <li>Agregar evento nuevo</li> <li>Mostrar un submen\u00fa para seleccionar el tipo de evento: <code>INFO</code>, <code>ERROR</code>, <code>WARNING</code>.</li> <li>Solicitar el mensaje del evento.</li> <li> <p>Guardar la entrada en <code>logs.txt</code> con formato <code>[TIPO] mensaje</code>.</p> </li> <li> <p>Ver todos los eventos registrados</p> </li> <li> <p>Leer el archivo y mostrar todas las l\u00edneas.</p> </li> <li> <p>Filtrar eventos por tipo</p> </li> <li> <p>Mostrar solo los eventos que coincidan con el tipo seleccionado.</p> </li> <li> <p>Eliminar eventos por tipo</p> </li> <li> <p>Eliminar todas las entradas de un tipo espec\u00edfico.      Pista: Leer todas las l\u00edneas, filtrar las que no coincidan y sobrescribir el archivo usando el modo <code>'w'</code>.</p> </li> <li> <p>Mostrar resumen de eventos</p> </li> <li> <p>Mostrar cu\u00e1ntos eventos hay en total y cu\u00e1ntos hay por tipo (<code>INFO</code>, <code>ERROR</code>, <code>WARNING</code>).</p> </li> <li> <p>Salir del programa</p> </li> </ol>"},{"location":"tareas/S1/003/#archivos-requeridos","title":"Archivos requeridos","text":""},{"location":"tareas/S1/003/#mainpy","title":"<code>main.py</code>","text":"<ul> <li>Muestra el men\u00fa principal y el submen\u00fa de tipos.</li> <li>Llama a las funciones definidas en <code>log_utils.py</code>.</li> </ul>"},{"location":"tareas/S1/003/#log_utilspy","title":"<code>log_utils.py</code>","text":"<p>Debe contener las siguientes funciones:</p> <pre><code>def agregar_log(tipo, mensaje):\n    # Escribe una nueva l\u00ednea en `logs.txt` en formato [TIPO] mensaje\n    pass\n\ndef leer_logs():\n    # Devuelve una lista de todas las entradas\n    pass\n\ndef filtrar_logs(tipo):\n    # Devuelve solo las entradas del tipo indicado\n    pass\n\ndef eliminar_logs_por_tipo(tipo):\n    # Reescribe `logs.txt` sin las l\u00edneas del tipo indicado\n    pass\n\ndef contar_logs(lista_logs):\n    # Retorna total de eventos y cu\u00e1ntos hay de cada tipo\n    pass\n</code></pre>"},{"location":"tareas/S1/003/#criterios-de-evaluacion","title":"Criterios de evaluaci\u00f3n","text":"Criterio Puntos Escritura y lectura correcta con <code>open()</code> 25 Uso de m\u00faltiples archivos (<code>main.py</code>, <code>log_utils.py</code>) 10 Implementaci\u00f3n de <code>try-except</code> para errores de archivo 10 Submen\u00fa correcto para seleccionar tipo de evento 10 Filtro y conteo de eventos por tipo 10 Eliminaci\u00f3n funcional por tipo (reescritura de archivo) 15 Validaci\u00f3n b\u00e1sica de entradas 10 Dise\u00f1o claro del men\u00fa y c\u00f3digo legible 5 Documentaci\u00f3n clara 5 Total 100"},{"location":"tareas/S2/001/","title":"Tarea 1: Sistema de gesti\u00f3n de cursos, estudiantes y profesores","text":"<p>Desarrolle un programa en Python que simule un sistema de gesti\u00f3n de cursos, estudiantes y profesores, aplicando los principios de programaci\u00f3n orientada a objetos vistos en clase:</p> <ul> <li>Clases y objetos</li> <li>Encapsulamiento de datos (<code>@property</code>, getters/setters)</li> <li>Herencia</li> </ul> <p>El sistema debe permitir registrar estudiantes y profesores, crear cursos, asignar profesores a cursos, matricular estudiantes y generar reportes b\u00e1sicos.</p> <p>La asignaci\u00f3n va a ser realizada en grupos de 3 personas. S\u00f3lo una persona debe entregar los archivos y debe indicar por medio de un comentario en Classroom los 3 integrantes del equipo. Asimismo, en cada uno de los archivos, en la parte superior deben incluir un comentario con <code>\"\"\" \"\"\"</code> para indicar los 3 integrantes del equipo.</p>"},{"location":"tareas/S2/001/#requisitos-de-diseno","title":"Requisitos de dise\u00f1o","text":""},{"location":"tareas/S2/001/#clase-persona","title":"Clase <code>Persona</code>","text":"Elemento Detalle Atributos <code>nombre</code> (<code>str</code>)<code>edad</code> (<code>int</code>) M\u00e9todos <code>presentar()</code>: retorna <code>\"{nombre}\"</code>"},{"location":"tareas/S2/001/#clase-estudiante-hereda-de-persona","title":"Clase <code>Estudiante</code> (hereda de <code>Persona</code>)","text":"Elemento Detalle Atributos <code>_carrera</code> (<code>str</code>, encapsulado con <code>@property</code>) M\u00e9todos <code>presentar()</code>: sobrescribe el del padre para incluir la carrera. Retorna <code>{nombre} ({_carrera})</code><code>matricular(curso)</code>: agrega el curso a su lista de cursos inscritos. Validaciones <code>_carrera</code> no puede ser cadena vac\u00eda."},{"location":"tareas/S2/001/#clase-profesor-hereda-de-persona","title":"Clase <code>Profesor</code> (hereda de <code>Persona</code>)","text":"Elemento Detalle Atributos <code>_especialidad</code> (<code>str</code>, encapsulado con <code>@property</code>) M\u00e9todos <code>presentar()</code>: sobrescribe el del padre para incluir la especialidad. Retorna <code>{nombre} ({_especialidad})</code> Validaciones <code>_especialidad</code> no puede ser cadena vac\u00eda."},{"location":"tareas/S2/001/#clase-curso","title":"Clase <code>Curso</code>","text":"Elemento Detalle Atributos <code>nombre</code> (<code>str</code>)<code>codigo</code> (<code>str</code>)<code>profesor</code> (inicialmente <code>None</code> y ser asignado, instancia de <code>Profesor</code>)<code>estudiantes</code> (lista compuesta por instancias de la clase <code>Estudiante</code>) M\u00e9todos <code>asignar_profesor(profesor)</code>: asigna el profesor al curso.<code>agregar_estudiante(estudiante)</code>: agrega el estudiante a la lista.<code>listar_estudiantes()</code>: muestra todos los estudiantes matriculados.<code>info()</code>: retorna el nombre del curso, el c\u00f3digo y el profesor asignado."},{"location":"tareas/S2/001/#composicion","title":"Composici\u00f3n","text":"Relaci\u00f3n Detalle Curso tiene un profesor y una lista de estudiantes. Estudiante puede estar en varios cursos."},{"location":"tareas/S2/001/#menu-interactivo","title":"Men\u00fa interactivo","text":"<p>Debe permitir seleccionar las siguientes opciones:</p> Opci\u00f3n Acci\u00f3n 1 Registrar estudiante 2 Registrar profesor 3 Crear curso 4 Asignar profesor a curso 5 Matricular estudiante en curso 6 Ver estudiantes en un curso 7 Ver cursos de un estudiante 8 Ver informaci\u00f3n de un curso (incluye profesor y estudiantes) 9 Salir"},{"location":"tareas/S2/001/#archivos-requeridos","title":"Archivos requeridos","text":""},{"location":"tareas/S2/001/#mainpy","title":"<code>main.py</code>","text":"<ul> <li>Presenta el men\u00fa principal.</li> <li>Gestiona las opciones y la interacci\u00f3n con el usuario.</li> </ul>"},{"location":"tareas/S2/001/#modelospy","title":"<code>modelos.py</code>","text":"<p>Debe contener las clases implementadas:</p> <pre><code>class Persona:\n    pass\n\nclass Estudiante(Persona):\n    pass\n\nclass Profesor(Persona):\n    pass\n\nclass Curso:\n    pass\n</code></pre>"},{"location":"tareas/S2/001/#ejemplo-de-uso-esperado","title":"Ejemplo de uso esperado","text":"<pre><code>--- Men\u00fa ---\n1. Registrar estudiante\n2. Registrar profesor\n3. Crear curso\n4. Asignar profesor a curso\n5. Matricular estudiante en curso\n6. Ver estudiantes en un curso\n7. Ver cursos de un estudiante\n8. Ver informaci\u00f3n de un curso\n9. Salir\n\nOpci\u00f3n: 1\nNombre: Ana\nEdad: 20\nCarrera: Ingenier\u00eda\n\nOpci\u00f3n: 2\nNombre: Luis\nEdad: 45\nEspecialidad: Matem\u00e1ticas\n\nOpci\u00f3n: 3\nNombre del curso: Programaci\u00f3n\nC\u00f3digo: PY001\n\nOpci\u00f3n: 4\nCurso: Programaci\u00f3n\nProfesor: Luis\n\nOpci\u00f3n: 5\nEstudiante: Ana\nCurso: Programaci\u00f3n\n\nOpci\u00f3n: 8\nCurso Programaci\u00f3n (PY001)\nProfesor: Luis (Matem\u00e1ticas)\nEstudiantes: Ana (Ingenier\u00eda)\n</code></pre>"},{"location":"tareas/S2/001/#recomendaciones-y-pistas","title":"Recomendaciones y pistas","text":""},{"location":"tareas/S2/001/#identificadores-y-registros","title":"Identificadores y registros","text":"<ul> <li> <p>Usar diccionarios para guardar los datos:</p> <ul> <li><code>estudiantes: dict[str, Estudiante]</code> (clave: nombre).</li> <li><code>profesores: dict[str, Profesor]</code> (clave: nombre).</li> <li><code>cursos: dict[str, Curso]</code> (clave: <code>codigo</code> del curso).</li> </ul> </li> <li> <p>Crear funciones de ayuda para obtener instancias:</p> <ul> <li><code>obtener_estudiante(nombre)</code>, <code>obtener_profesor(nombre)</code>, <code>obtener_curso(codigo)</code>.</li> <li>Al crear un estudiante, profesor o curso, se deber\u00eda agregar a un diccionario de <code>estudiantes</code>, <code>profesores</code>, <code>cursos</code>, donde se pueden buscar TODOS los estudiantes, profesores y cursos bas\u00e1ndose en los nombres o c\u00f3digos dependiendo del caso.</li> <li>Cada una de ellas debe retornar <code>estudiantes[nombre]</code>, <code>profesores[nombre]</code>, <code>cursos[codigo]</code>, que consiste en una instancia de la clase correspondiente.</li> </ul> </li> </ul>"},{"location":"tareas/S2/001/#encapsulamiento-y-validaciones","title":"Encapsulamiento y validaciones","text":"<ul> <li> <p>En <code>Estudiante</code>:</p> <ul> <li><code>_carrera</code> con <code>@property</code> + <code>@setter</code> (no vac\u00eda).</li> </ul> </li> <li> <p>En <code>Profesor</code>:</p> <ul> <li><code>_especialidad</code> con <code>@property</code> + <code>@setter</code> (no vac\u00eda).</li> </ul> </li> <li> <p>Validar tambi\u00e9n:</p> <ul> <li><code>nombre</code> no vac\u00edo para <code>Estudiante</code> y <code>Profesor</code>, <code>edad &gt;= 0</code>, <code>codigo</code> no vac\u00edo en <code>Curso</code>.</li> </ul> </li> <li> <p>En <code>Curso</code>:</p> <ul> <li> <p>Mantener la lista interna de estudiantes como privada (<code>_estudiantes</code>) y exponer solo m\u00e9todos:</p> <ul> <li><code>agregar_estudiante(estudiante)</code>: evita duplicados.</li> <li><code>listar_estudiantes()</code>: retorna datos (el men\u00fa se encarga de imprimir).</li> </ul> </li> <li> <p><code>profesor</code> puede iniciar en <code>None</code>. M\u00e9todo <code>asignar_profesor()</code> valida instancia.</p> </li> </ul> </li> </ul>"},{"location":"tareas/S2/001/#patron-para-el-menu","title":"Patr\u00f3n para el men\u00fa","text":"<ul> <li> <p>Bucle principal <code>while continuar:</code></p> <ul> <li>Mostrar opciones</li> <li>Leer opci\u00f3n validada (<code>int</code> de 1..9)</li> <li>Llamar funciones en cada caso (<code>registrar_estudiante()</code>)</li> </ul> </li> </ul>"},{"location":"tareas/S2/001/#criterios-de-evaluacion","title":"Criterios de evaluaci\u00f3n","text":"Criterio Puntos Implementaci\u00f3n correcta de clases y objetos 10 Uso de herencia (<code>Persona</code> \u2192 <code>Estudiante</code>, <code>Profesor</code>) 15 Uso de encapsulamiento con <code>@property</code> y validaciones 15 Implementaci\u00f3n de composici\u00f3n (<code>Curso</code> contiene profesor y estudiantes) 15 Men\u00fa interactivo con todas las funcionalidades 20 C\u00f3digo modular en m\u00faltiples archivos (<code>main.py</code>, <code>modelos.py</code>) 10 Buenas pr\u00e1cticas (nombres claros, comentarios, docstrings) 5 Ejecuci\u00f3n sin errores y manejo b\u00e1sico de entradas inv\u00e1lidas (<code>try-except</code>) 5 Documentaci\u00f3n clara 5 Total 100"},{"location":"tareas/S2/002/","title":"Tarea 2: \u00c1rboles Binarios","text":"<p>Objetivo general</p> <p>Aplicar los conocimientos aprendidos sobre \u00e1rboles binarios para implementar un \u00e1rbol binario de b\u00fasqueda (BST) que permita realizar b\u00fasquedas, recorridos y operaciones b\u00e1sicas sobre los nodos.</p>"},{"location":"tareas/S2/002/#descripcion-general","title":"Descripci\u00f3n general","text":"<p>Un \u00e1rbol binario de b\u00fasqueda (Binary Search Tree) es una estructura donde cada nodo cumple la propiedad:</p> <p>Los valores menores se ubican en el sub\u00e1rbol izquierdo Los valores mayores o iguales se ubican en el sub\u00e1rbol derecho.</p> <p>El objetivo de esta tarea es implementar un BST que permita:</p> <ul> <li>Realizar b\u00fasquedas.</li> <li>Calcular altura y n\u00famero de hojas.</li> <li>Obtener valores m\u00ednimos y m\u00e1ximos.</li> <li>Recorrer el \u00e1rbol en preorden, en orden y postorden.</li> </ul>"},{"location":"tareas/S2/002/#estructura-de-clases","title":"Estructura de clases","text":"<p>Cree dos clases principales:</p> <ul> <li>Clase <code>Nodo</code></li> </ul> <pre><code>class Nodo:\n    def __init__(self, valor):\n        self.valor = valor\n        self.izq = None\n        self.der = None\n</code></pre> <ul> <li>Clase <code>ArbolBST</code></li> </ul> <p>Contendr\u00e1 la ra\u00edz y los m\u00e9todos solicitados:</p> M\u00e9todo Descripci\u00f3n <code>buscar(valor)</code> Retorna <code>True</code> si el valor existe en el \u00e1rbol, <code>False</code> en caso contrario. <code>en_orden()</code> Devuelve una lista con los valores en orden ascendente. <code>preorden()</code> Devuelve la lista en orden de recorrido preorden. <code>postorden()</code> Devuelve la lista en orden postorden. <code>minimo()</code> Retorna el valor m\u00e1s peque\u00f1o del \u00e1rbol. <code>maximo()</code> Retorna el valor m\u00e1s grande del \u00e1rbol. <code>altura()</code> Calcula la altura del \u00e1rbol. <code>contar_hojas()</code> Devuelve el n\u00famero total de hojas. <p>Sugerencia</p> <p>Todos los recorridos y c\u00e1lculos pueden implementarse de forma recursiva utilizando funciones auxiliares internas.</p>"},{"location":"tareas/S2/002/#programa-principal-mainpy","title":"Programa principal (<code>main.py</code>)","text":"<p>En el archivo principal, se debe:</p> <ol> <li> <p>Crear un \u00e1rbol BST con los siguientes valores ya predefinidos:</p> <pre><code>valores = [8, 3, 10, 1, 6, 14, 4, 7, 13]\n</code></pre> <p>Note</p> <p>Cree este \u00e1rbol manualmente, asignando nodos. No es necesario utilizar  un m\u00e9todo de inserci\u00f3n.</p> </li> <li> <p>Mostrar en pantalla:</p> <ul> <li>Los tres recorridos (preorden, en orden, postorden).</li> <li>La altura del \u00e1rbol.</li> <li>El n\u00famero de hojas.</li> <li>El valor m\u00ednimo y m\u00e1ximo.</li> <li>Una b\u00fasqueda de ejemplo (<code>buscar(6)</code> y <code>buscar(9)</code>).</li> </ul> </li> </ol>"},{"location":"tareas/S2/002/#representacion-visual-del-bst","title":"Representaci\u00f3n visual del BST","text":"<p>Observe que hay nodos que deben estar en <code>None</code> (el \u00e1rbol no est\u00e1 completo). Deben asignar correctamente si el nodo izquierdo o derecho es el que est\u00e1 en <code>None</code>, de forma que se mantengan las reglas del BST.</p> <pre><code>flowchart TB\n    A((8))\n    B((3))\n    C((10))\n    D((1))\n    E((6))\n    F((14))\n    G((4))\n    H((7))\n    I((13))\n    A --&gt; B\n    A --&gt; C\n    B --&gt; D\n    B --&gt; E\n    E --&gt; G\n    E --&gt; H\n    C --&gt; F\n    F --&gt; I</code></pre>"},{"location":"tareas/S2/002/#resultados-esperados","title":"Resultados esperados","text":"Operaci\u00f3n Resultado esperado <code>en_orden()</code> <code>[1, 3, 4, 6, 7, 8, 10, 13, 14]</code> <code>preorden()</code> <code>[8, 3, 1, 6, 4, 7, 10, 14, 13]</code> <code>postorden()</code> <code>[1, 4, 7, 6, 3, 13, 14, 10, 8]</code> <code>altura()</code> <code>4</code> <code>contar_hojas()</code> <code>4</code> <code>minimo()</code> <code>1</code> <code>maximo()</code> <code>14</code> <code>buscar(6)</code> <code>True</code> <code>buscar(9)</code> <code>False</code>"},{"location":"tareas/S2/002/#criterios-de-evaluacion","title":"Criterios de evaluaci\u00f3n","text":"Criterio Descripci\u00f3n Puntos Estructura correcta de las clases <code>Nodo</code> y <code>ArbolBST</code> Dise\u00f1o y relaciones adecuadas entre nodos 20 Implementaci\u00f3n funcional de los recorridos Los tres recorridos devuelven listas correctas 20 Funciones adicionales (<code>buscar</code>, <code>minimo</code>, <code>maximo</code>, <code>altura</code>, <code>contar_hojas</code>) Resultados v\u00e1lidos y consistentes 25 Correcta construcci\u00f3n del \u00e1rbol base y demostraci\u00f3n de resultados \u00c1rbol reflejado correctamente en las pruebas 20 Claridad del c\u00f3digo y documentaci\u00f3n Comentarios, estilo y legibilidad 15 <p>Recuerde...</p> <p>Pruebe cada m\u00e9todo individualmente antes de integrarlo.</p> <p>Para la entrega: un \u00fanico archivo <code>bst.py</code> que contenga las clases y el c\u00f3digo de prueba.</p>"}]}